---
title: 重排序
date: 2018-06-23 16:09:49
tags:
- java
- jvm
categories:
- java
- jvm
toc: true
---
## 分类
1. 编译器重排序
2. 处理器重排序
3. 内存重排序

## 目的
重排序存在的目的是为了更好的执行性能优化
<!-- more -->
## 屏障
名称|含义|作用|实现
:--:|:--:|:--:|:--:
loadLoad|load1; loadLoad; load2|所有的load2操作都发生在|sfence
storeStore|store1; storeStore; store2;|所有的store1都在store2之前|lfence
loadStore|load1; loadStore; store|所有的load操作发生在store之前
storeLoad|store1; storeLoad; load1|所有的store1操作发生在load1之前|mfence
**tip:**
1. storeLoad是全能型屏障，但是需要刷新缓存，性能损耗较大。
2. mfence和lock的区别，作用类似，但是lock可能会锁住内存总线。
3. MESI协议，缓存一致性协议，storeLoad需要。   

# 内存结构
![处理器内存结构](/images/处理器内存.png)

# MESI
是Cache一致性协议，缓存行里面有两个bit，表示当前缓存行是否有效。

状态|描述
:-|:-
Modified|数据有效，但是和内存中的不一致
Exclusive|数据有效，并且只有当前一个副本
Shared|数据有效，但是有多个副本
Invalid|数据无效，需要重新从内存读取

# long，double
jvm规范中，针对于非volatile类型修饰的long，double的写入，jmm是分为两次32字节操作的。
但是在目前的商用虚拟机中，64字节的写入操作是**原子的**，不需要担心此类问题。

# volatile
## 作用
保证可见性，以及防止重排序
## 原理
```java
volatile int count = 0;

storeStore
count=10;
storeLoad // sfence

loadLoad
if (count > 10) {}
loadStore
```

# final
1. final域的写入操作之后插入了storeStore，禁止重排序到构造函数之外，**为了防止对象引用逃逸**
2. 读对象的引用和对象final域操作之间插入loadLoad屏障，**为了防止读到未完全初始化的对象**

# synchronized
synchronized也是有同步作用存在，退出同步块之前，会把object对象刷新回主内存。
```java
synchronized (object) {
}
```

# 思考题
问: 
下面的输出是什么？
答:
输出是40000。
```java
public class VariableTest {
    static int count = 0;
    static int max = 20_000;

    public static void main(String[] args) throws InterruptedException {
        Thread thread1 = new Thread(() -> {
            for (int i = 0; i < max; i++) {
                while (System.currentTimeMillis() % 2 == 0)
                    Thread.yield();

                count += 1;
                LockSupport.parkNanos(1000_000);
            }
        });
        thread1.start();

        Thread thread2 = new Thread(() -> {
            for (int i = 0; i < max; i++) {
                while (System.currentTimeMillis() % 2 == 1)
                    Thread.yield();

                count += 1;
                LockSupport.parkNanos(1000_000);
            }
        });
        thread2.start();

        thread1.join();
        thread2.join();
        System.out.println(count);
    }
}
```