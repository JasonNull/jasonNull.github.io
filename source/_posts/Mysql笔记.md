---
title: Mysql笔记
date: 2018-06-24 15:26:18
tags:
- 中间件
- mysql
categories:
- 中间件
toc: true
---
#### mysql架构
<img src="/images/mysql结构.jpg" width="50%" height="50%">
<!-- more -->

#### 架构层面
1. 读写分离（使用mycat，或者mysql自带的都行）
2. 读多写少用myisam
3. 读写都多用innodb
4. 对mysql引擎进行调优，适当增加内存缓存

这边有一个考点，如何进行分库分表的不宕机数据迁移
1. 不用随机分片规则（hash取模），使用范围分片的规则
2. 做数据的拷贝，然后停机一段时间，将现有数据在多个表上都拷贝一份
3. 将id和库的映射关系，记录下来，比如说放在nosql数据库中

#### 表结构
1. 分库分表
2. 表分区（mysql自带）
3. 使用合适的字段类型，合适的字段长度
4. 不使用外键
5. 建合适的索引，不要滥用索引

#### sql优化
1. explain查看所有的sql语句，查看是否命中索引
2. Group By以及Order By的字段是否命中索引（会使用filesort）
3. 使用索引的最左前缀匹配原则
4. 少用Join，join的字段应该走索引
5. 不使用约束（外键约束，check约束）
6. like查询走搜索引擎

#### 不走索引总结
1. 对索引列使用了函数，或者数学运算等操作
2. 不能使用like %XXX
3. 字符串列与数字直接比较
4. 尽量避免or
5. 判断字段是否为NULL
6. IN, NOT IN, EXISTS等（范围扫描走，集合扫描不走）

#### 索引
1. 数据结构：B+树（与B树的区别），![B+树](/images/B+树.png)
2. 分类：聚集索引和非聚集索引（聚集索引通常只有一个，数据按照聚集索引组织在一起）
3. innodb索引规则：
    - 没有主键则使用唯一索引做主键索引
    - 存在多个唯一索引则按照索引顺序使用
    - 不存在唯一索引，则建立占六个字节的匿名主键索引
4. 联合索引的原理是B+树的叶子节点按照联合索引的各个字段来排序
5. 联合索引中，区分度比较高的列应该放在前面，这样一次查询能够确定的数据范围比较小
6. 走主键索引比较快，因为比二级索引少一次查询
7. innodb插入比较慢，因为主要是涉及到索引的调整
8. innodb默认是行锁，行锁锁的是索引(个人认为是同时锁多个索引)，如果查询语句没有走索引，就会升级为表锁
9. limit的原理是扫描数据，最好是能够直接扫描索引，不用去根据id再去扫描完整数据
10. innodb的**可重复读**避免了幻读，主要是通过间隙锁（主要是针对范围加锁）或者是行锁与间隙锁一起
11. 行锁的实现是位图，通过一个bitmap记录了哪些行被加锁了

#### 事务
1. 原子性，一致性，隔离性，持久性
2. 默认事务隔离级别是可重复读
3. mysql通过mvcc来实现事务的隔离级别的

#### mvcc
multi version concurrency control，多版本并发控制。
事务的隔离级别是通过mvcc实现的，数据一般会存在有多个版本。
mysql中的读取叫做快照读，读取的时候会根据当前的隔离级别，建立一个读取的快照（里面保存了可以对数据读取的事务的版本）。
##### 下面是索引的结构
trx_id：该数据被提交修改了多少次（每行数据从0开始增长）
db_roll_ptr：在数据在undolog中的
![索引结构](/images/MVCC1.jpg)
具体的操作
![mvcc流程](/images/MVCC2.jpg)

#### 隔离级别
隔离级别|出现现象|原因
:-:|:-:|:-:
未提交读|脏读，不可重复读，幻读|会直接读取当前行数据，即使当前行数据未提交
已提交读|不可重复读，幻读|会读取当前最新的已经提交的修改，但是避免不了幻读，<br/>因为一个事务当中可能读取到其他事务的多次修改
可重复读|幻读|会根据当前快照中的数据事务版本号，去undo log中读取当前事务开始时候的初始数据
串行化|无|串行化就是直接加了排他锁
innodb的可重复读还解决了幻读的问题，

#### log
1. redo log，mysql的很多修改都是直接修改的内存，并且将修改记录到了redo log中。redo log用于防止mysql被突然重启，但是还有内存中的修改并未被刷新到磁盘上的现象出现。mysql重启的时候，会读取redo log，用于重新执行那些已经提交的修改。
2. undo log，用于记录事务的反向操作，可以用于事务的回滚
3. bin log，服务器端对数据操作的日志，通常用于数据恢复和数据同步，mysql的主从同步就是slave去master上拉取最新的binlog去执行

#### 字段新增
1. 复制旧表结构为新表
2. 新增一个字段
3. 将旧表数据复制过来（这时候就开始加表锁了）
4. 删除旧表，重命名新表

**如何优化**
复制结构到新表，新增一个字段，将旧表数据复制过来，然后在旧表上面设置触发器，对数据的修改，同时全部通过触发器同步到新表之中，最后删除旧表，重命名新表

#### 查询过程
1. 查询缓存（相同语句，直接走缓存回去了）
2. 词法分析，语法分析，语义分析，生成解析树
3. 交给查询优化器优化
4. 执行引擎执行
![mysql查询过程](/images/mysql查询过程.png)

#### 索引
1. system，表中只有一行数据或为空
2. const，查询结果只有一行数据，唯一索引或主键索引
3. eq_ref，连接查询时，使用唯一索引查询
4. ref，普通非唯一索引
5. range，索引的范围扫描
6. index，索引全扫描
7. all，表全扫描

#### 三范式
1. 第一范式：属性不可拆分（地址可以再拆分为省市区）
2. 非主属性完全依赖于码（学生姓名完全依赖于学号）
3. 非主属性之间没有任何传递依赖（班主任工号和班主任姓名）

#### 字符集
1. 数据库字符集
2. 表字符集
3. 列字符集