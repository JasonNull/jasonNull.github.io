{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/favicon.png","path":"favicon.png","modified":1,"renderable":0},{"_id":"source/images/g1内存示意.png","path":"images/g1内存示意.png","modified":1,"renderable":0},{"_id":"source/images/hotspot架构.png","path":"images/hotspot架构.png","modified":1,"renderable":0},{"_id":"source/images/javac流程.gif","path":"images/javac流程.gif","modified":1,"renderable":0},{"_id":"source/images/skip-list.jpg","path":"images/skip-list.jpg","modified":1,"renderable":0},{"_id":"source/images/tcp状态.gif","path":"images/tcp状态.gif","modified":1,"renderable":0},{"_id":"source/images/处理器内存.png","path":"images/处理器内存.png","modified":1,"renderable":0},{"_id":"source/images/CLH.jpg","path":"images/CLH.jpg","modified":1,"renderable":0},{"_id":"source/images/B+树.png","path":"images/B+树.png","modified":1,"renderable":0},{"_id":"source/images/MVCC1.jpg","path":"images/MVCC1.jpg","modified":1,"renderable":0},{"_id":"source/images/MVCC2.jpg","path":"images/MVCC2.jpg","modified":1,"renderable":0},{"_id":"source/images/jit流程.gif","path":"images/jit流程.gif","modified":1,"renderable":0},{"_id":"source/images/putVal1.png","path":"images/putVal1.png","modified":1,"renderable":0},{"_id":"source/images/mysql结构.jpg","path":"images/mysql结构.jpg","modified":1,"renderable":0},{"_id":"source/images/mysql查询过程.png","path":"images/mysql查询过程.png","modified":1,"renderable":0},{"_id":"source/images/常用集合.png","path":"images/常用集合.png","modified":1,"renderable":0},{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"source/images/get1.png","path":"images/get1.png","modified":1,"renderable":0},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/favicon.png","path":"css/images/favicon.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"source/images/get2.png","path":"images/get2.png","modified":1,"renderable":0},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"source/images/AQS.jpg","path":"images/AQS.jpg","modified":1,"renderable":0},{"_id":"source/images/putVal2.png","path":"images/putVal2.png","modified":1,"renderable":0},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":1,"renderable":1},{"_id":"source/images/MarkWord.png","path":"images/MarkWord.png","modified":1,"renderable":0}],"Cache":[{"_id":"source/.DS_Store","hash":"76757ef03ca6d250a6a5c4bcdf1fc8bbbdc4bea8","modified":1529930633466},{"_id":"source/favicon.png","hash":"e9bb82157ddf12ac83675920eaf70abb921b22b7","modified":1529728590608},{"_id":"themes/landscape/.gitignore","hash":"58d26d4b5f2f94c2d02a4e4a448088e4a2527c77","modified":1529685471996},{"_id":"themes/landscape/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1529685471965},{"_id":"themes/landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1529685471965},{"_id":"themes/landscape/README.md","hash":"37fae88639ef60d63bd0de22314d7cc4c5d94b07","modified":1529685471996},{"_id":"themes/landscape/.DS_Store","hash":"a50d25982028610496bfc072292a1a49ea7b160c","modified":1529734816745},{"_id":"themes/landscape/_config.yml","hash":"012fea49a0ec0879ffdaa83aa718ffc209e22315","modified":1529748230083},{"_id":"themes/landscape/package.json","hash":"544f21a0b2c7034998b36ae94dba6e3e0f39f228","modified":1529685471996},{"_id":"source/_posts/Atomic分析.md","hash":"50b8d03246ee469b9f33d23e851a094d9c5459ec","modified":1529749965010},{"_id":"source/_posts/AQS分析.md","hash":"64156a30d0afea2d06784c0a48724156268b725f","modified":1530025624916},{"_id":"source/_posts/DTS功能构思.md","hash":"7235a90f2d7177cbd3529053707968489c0e915b","modified":1530430650017},{"_id":"source/_posts/DTS技术调研前言.md","hash":"853e90e11fe28f3d6c9fff83c394d5694464e70d","modified":1530429312924},{"_id":"source/_posts/DTS排期.md","hash":"6d3d661f3dd69d88f922b6139e58dda52a698131","modified":1530428921562},{"_id":"source/_posts/DTS技术调研：分库分表.md","hash":"833ae840f20c0abbfcfccb2f2c1546ef42add755","modified":1530593607009},{"_id":"source/_posts/Map分析.md","hash":"9a77dff56c0c3982d8a0ced78410e1c79726d05e","modified":1529930924952},{"_id":"source/_posts/FutureTask分析.md","hash":"fbaafddb8d69f6a43e5d4945043c1cd0b96189c5","modified":1529751758216},{"_id":"source/_posts/List分析.md","hash":"bf0b6cd95fc6d54faa87099bc7263d1a195110ce","modified":1529751095413},{"_id":"source/_posts/Mysql笔记.md","hash":"104e0cb97c1f275b57dd2ccca6f0bbd33c3815b3","modified":1529826981758},{"_id":"source/_posts/Queue分析.md","hash":"3d9f22c98a84406f3f2ae7cc1afeb1bccf904312","modified":1529751317237},{"_id":"source/_posts/ScheduledThreadPoolExecutor分析.md","hash":"08a0aa0a542b0a7e80132598e2c306ab2d04445a","modified":1529748854860},{"_id":"source/_posts/Set分析.md","hash":"92dbbacd344b8ecaa32c3d81f1a6c5610c6efcc8","modified":1529751079350},{"_id":"source/_posts/RocketMQ笔记.md","hash":"7372be69b34df3bb55544e6e745327cb06f18e5a","modified":1529828288213},{"_id":"source/_posts/Redis笔记.md","hash":"cc292f0f689689cced826822f50ed806afb9bf73","modified":1529828057013},{"_id":"source/_posts/Thread分析.md","hash":"5f9a65b6a74ef59990a3ae31d97f501b2cee908d","modified":1529748845674},{"_id":"source/_posts/ThreadLocal分析.md","hash":"1f27ae1a6073d52e3bebecee64dce43e6ae96b4f","modified":1529749418091},{"_id":"source/_posts/Unsafe分析.md","hash":"773f6aff809dc2e8a1688abbf2fe79e8012f086c","modified":1529749879548},{"_id":"source/_posts/ThreadPoolExecutor分析.md","hash":"d366a2351835853ff402f7bb5a465585c254fbca","modified":1529751566313},{"_id":"source/_posts/gc日志.md","hash":"6542915e41440d0f7588a5fd773c2aa82858613f","modified":1529747684013},{"_id":"source/_posts/gc介绍.md","hash":"35e67563917c34f270c73efc3214cdd137b6c38d","modified":1529751479184},{"_id":"source/_posts/happen-before.md","hash":"7553d0d8f5c2bc2f4f78388aa02ab53dcf10db7a","modified":1529747686731},{"_id":"source/_posts/hello-world.md","hash":"e5f65ae9b3ae33d6ab9cf80078c688a44c32f4a6","modified":1529747689932},{"_id":"source/_posts/hotspot.md","hash":"602ef4867d54a4dbaa8dffab7e7946c89363332e","modified":1529747692588},{"_id":"source/_posts/instanceof.md","hash":"050f3485f3e5e33e7308bdb2d69099efc9617f1c","modified":1529747695891},{"_id":"source/_posts/io.md","hash":"0a79f9595e190c6cd0830f1741ccb9bd6aafc30d","modified":1529747712706},{"_id":"source/_posts/tcp.md","hash":"dca3b3dd6d22f689c92dce3aee2381fe4c6eef19","modified":1529747719590},{"_id":"source/_posts/jmm.md","hash":"e1cb9f53bdd97877abc34a052a53592cb74589dc","modified":1529747715005},{"_id":"source/_posts/synchronized.md","hash":"548fd85563b5c3dd52a3718c7bc8f96bbb74c606","modified":1529747717379},{"_id":"source/_posts/分布式理论.md","hash":"a3945f6dc1f932fee16d001bc53140a954379240","modified":1529827959305},{"_id":"source/_posts/代码优化.md","hash":"2e10438a90d93b0c91d11a36ac4e03117368049f","modified":1529747722096},{"_id":"source/_posts/分布式锁.md","hash":"b9507d5507c76912c68caa9798d51005d4f79bc9","modified":1529828014320},{"_id":"source/_posts/微服务.md","hash":"79a22088c0b0576a0bb0b4fc18d25557304f13b4","modified":1529827702387},{"_id":"source/_posts/包装类型.md","hash":"95a781c220941cba75d58a93c0e8cc7160b62233","modified":1529747724327},{"_id":"source/_posts/攻击防范.md","hash":"a1a58bf72708c80fe009b94780eaba3674b3c750","modified":1529747727130},{"_id":"source/_posts/死锁.md","hash":"b64a9fc52b8f81821f7c88f755fc3c0fd837a5b1","modified":1529751621706},{"_id":"source/_posts/编码.md","hash":"cd09bcdea526bbdb058084abfd1d7d39e293e182","modified":1529747734630},{"_id":"source/_posts/缓存预热，缓存穿透，缓存雪崩.md","hash":"5d0764b45938692e1c89ef4e9d8b28362f3a3667","modified":1529827971671},{"_id":"source/_posts/类加载.md","hash":"af551ecefd8c4e5377d41db1acf17bdaadd91e29","modified":1529751628426},{"_id":"source/_posts/重排序.md","hash":"546b85f98f9d541f0e557cd6e0eef9ada4fc71ab","modified":1529747743635},{"_id":"source/_posts/设计模式.md","hash":"280f4f3773f9332cc7cb62134d5c3c6e52d54545","modified":1529747737247},{"_id":"source/_posts/锁分类.md","hash":"a4a518f0d817d48eb49f74db686fe8b3a4ab034b","modified":1529749763786},{"_id":"source/_posts/集合.md","hash":"5dea7afb1b0f0e20719f748af5b48441aa4e439d","modified":1529751652710},{"_id":"source/_posts/语法糖.md","hash":"4d3d19ea6748dc30e6bc08401eb4e0ac29e25e58","modified":1529747740859},{"_id":"source/images/g1内存示意.png","hash":"e27ef533650af0999975208580886544340550c4","modified":1529685471962},{"_id":"source/images/hotspot架构.png","hash":"331c33d00f4e2c17586b8f42de4099713dae6fee","modified":1529741584563},{"_id":"source/images/javac流程.gif","hash":"f58d618625a68f244541143aa6b109f3255558d8","modified":1529741113922},{"_id":"source/images/skip-list.jpg","hash":"0b25a5cee9d310bb0dc403356a54de07afd6a43c","modified":1529826943547},{"_id":"source/images/tcp状态.gif","hash":"51e327b155854b66b2ea359ca15404804ab6a15e","modified":1529742258808},{"_id":"source/images/处理器内存.png","hash":"ac36c0baa12db091dd8cb0923c62e136e4451ab7","modified":1529741605068},{"_id":"themes/landscape/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1529685471993},{"_id":"themes/landscape/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1529685471991},{"_id":"themes/landscape/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1529685471992},{"_id":"themes/landscape/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1529685471994},{"_id":"themes/landscape/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1529685471993},{"_id":"themes/landscape/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1529685471992},{"_id":"themes/landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1529685471995},{"_id":"themes/landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1529685471995},{"_id":"themes/landscape/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1529685471993},{"_id":"themes/landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1529685471994},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1529685471995},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1529685471994},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1529685471967},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1529685471966},{"_id":"themes/landscape/layout/layout.ejs","hash":"f155824ca6130080bb057fa3e868a743c69c4cf5","modified":1529685471968},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1529685471966},{"_id":"themes/landscape/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1529685471997},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1529685471974},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1529685471966},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1529685471967},{"_id":"themes/landscape/source/.DS_Store","hash":"9976837b2772b9b28d4b35e0c5543b4cd84ad3e3","modified":1529734816744},{"_id":"source/images/CLH.jpg","hash":"ec2047057157acceecb412b3b19e2a5a866ed983","modified":1529750013439},{"_id":"source/images/B+树.png","hash":"b5dce96706cf029e1b3dad131ac34cc53e5a2e99","modified":1528375869530},{"_id":"source/images/MVCC1.jpg","hash":"4099b6ed584280714df6b54ef07ee146f647299c","modified":1528443932000},{"_id":"source/images/MVCC2.jpg","hash":"00161c62709deac9145fb654cfa2240c6deb929f","modified":1528445008000},{"_id":"source/images/jit流程.gif","hash":"108d46716fb98e7be300982a8b5d64822e81e89a","modified":1529741113937},{"_id":"source/images/putVal1.png","hash":"2fc14ece21a151ef2d9afea99ddee90408d37834","modified":1529930587241},{"_id":"source/images/mysql结构.jpg","hash":"6b098808617ef95c21cd619549e8fb2cc170312a","modified":1528387271814},{"_id":"source/images/mysql查询过程.png","hash":"6129cadc7fb8627c5ab6ad07c4b8cdca499cbb14","modified":1528520829437},{"_id":"source/images/常用集合.png","hash":"62e66b9bbc4483eaec39ed8abf9b9e7bb4cdba1a","modified":1529750723927},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"d0d753d39038284d52b10e5075979cc97db9cd20","modified":1529685471973},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"950ddd91db8718153b329b96dc14439ab8463ba5","modified":1529685471971},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1529685471971},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"948dc0466506fd0ffdd11dc0f7c4abb81a9c166a","modified":1529745762047},{"_id":"themes/landscape/layout/_partial/gauges-analytics.ejs","hash":"aad6312ac197d6c5aaf2104ac863d7eba46b772a","modified":1529685471972},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1529685471971},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"93518893cf91287e797ebac543c560e2a63b8d0e","modified":1529685471973},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"dc8d4a2f9d92d2624c6e6c4ca81fa4e60570e579","modified":1529727540439},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1529685471973},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"71015776b8dc62f6b149783d54b3b4cbd993990c","modified":1529808378655},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1529685471974},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1529685471976},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1529685471975},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"0d4f064733f8b9e45c0ce131fe4a689d570c883a","modified":1529685471976},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1529685471976},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1529685471975},{"_id":"themes/landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1529685471990},{"_id":"themes/landscape/source/css/.DS_Store","hash":"9f8f5ffb1ae8bdd4eeb8cb3e413a905784fc9f3c","modified":1529734817506},{"_id":"themes/landscape/source/css/_variables.styl","hash":"628e307579ea46b5928424313993f17b8d729e92","modified":1529685471985},{"_id":"themes/landscape/source/css/style.styl","hash":"a70d9c44dac348d742702f6ba87e5bb3084d65db","modified":1529685471989},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1529685471980},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1529685471981},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1529685471979},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1529685471978},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1529685471980},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1529685471978},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1529685471980},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1529685471978},{"_id":"themes/landscape/source/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1529685471991},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1529685471979},{"_id":"source/images/get1.png","hash":"d14a782a60903ee1906897419ddeb1d84a5f251b","modified":1529930603034},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1529685471970},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1529685471968},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1529685471970},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1529685471969},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1529685471970},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1529685471969},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"7d4aff34913eb11dfefa7a69a75c61723fc8d480","modified":1529930389392},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1529685471987},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1529685471988},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1529685471987},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1529685471987},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"bf4e7be1968dad495b04e83c95eac14c4d0ad7c0","modified":1529685471986},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1529685471988},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1529685471988},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1529685471986},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1529685471987},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1529685471984},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1529685471984},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1529685471989},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1529685471990},{"_id":"themes/landscape/source/css/images/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1529734827113},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1529685471990},{"_id":"themes/landscape/source/css/images/favicon.png","hash":"dbc4cac8bc52a7bf32e36f64efdccee1aef43ca4","modified":1529734793041},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1529685471982},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1529685471983},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1529685471983},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1529685471982},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1529685471983},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1529685471982},{"_id":"source/images/get2.png","hash":"55a90322e349acaff59496c3bd08c096284e13f0","modified":1529930609058},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1529685471990},{"_id":"source/images/AQS.jpg","hash":"bf5f78a0dc1df74390d5377e6aef817cf8e6e1e1","modified":1529750009010},{"_id":"source/images/putVal2.png","hash":"e5f7112e6d0bb57f6366fbe804997fb218ffbfe3","modified":1529930596315},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1529685471989},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1529685471985},{"_id":"source/images/MarkWord.png","hash":"000eb1a1a28874f55acaffc2c5716836e3d730fe","modified":1529740869605},{"_id":"public/content.json","hash":"ee5646abfa3396f7fe4c978d621d0924ae118fe0","modified":1530630788713},{"_id":"public/2018/07/01/DTS排期/index.html","hash":"1eee849bab965f2615209e7e1a6a1f17c5284a0a","modified":1530630789058},{"_id":"public/2018/06/24/微服务/index.html","hash":"fcafde0e5fcb1fde7a8c7312ccfcd77865ffa979","modified":1530630789058},{"_id":"public/2018/06/24/分布式理论/index.html","hash":"fa23e1e7c56aaf75e418962a14b5fa42a5f4cb4b","modified":1530630789058},{"_id":"public/2018/06/24/Redis笔记/index.html","hash":"35174af9e1f04ee507ce000b7d4fee0dfd193e12","modified":1530630789058},{"_id":"public/2018/06/23/Set分析/index.html","hash":"bf241e8dd5dfdd06c9da8c0d06d5305bf26f65d4","modified":1530630789058},{"_id":"public/2018/06/23/死锁/index.html","hash":"13125a2fee77636ec7fd3ab0001f2db7fc746e5a","modified":1530630789058},{"_id":"public/2018/06/23/编码/index.html","hash":"911240b0cc3e74b68c692d807a477991d3dba27d","modified":1530630789058},{"_id":"public/2018/06/23/包装类型/index.html","hash":"e7adcc601e6ba7b213ecbc8e78b39537430de84f","modified":1530630789059},{"_id":"public/2018/06/23/tcp/index.html","hash":"061ab3ab2d9200e4a710db7fc18fbdd01ad4daa5","modified":1530630789059},{"_id":"public/2018/06/23/hotspot/index.html","hash":"7349ac02a17eb6033bb812b51b34d4d4c5b1ccfb","modified":1530630789059},{"_id":"public/2018/06/23/代码优化/index.html","hash":"e11e05834c8e1b1c701713e1bdc58f1d1493cedc","modified":1530630789059},{"_id":"public/2018/06/23/happen-before/index.html","hash":"3f7c84df7cb6c8994f9c40b286c29e93829a74e6","modified":1530630789059},{"_id":"public/2018/06/22/hello-world/index.html","hash":"8e5b06c114880ce62c1b309ae580718d9fd69a42","modified":1530630789059},{"_id":"public/archives/page/5/index.html","hash":"c28f172bcb396f73309e29a2549a7ed225b2c1e4","modified":1530630789059},{"_id":"public/archives/2018/page/5/index.html","hash":"4d029027d095bcc8f8420b5bf1b3e9c53e2444e2","modified":1530630789059},{"_id":"public/archives/2018/06/page/5/index.html","hash":"8bdadbd65a25bd55852fc36cd3313d9ca626b659","modified":1530630789059},{"_id":"public/archives/2018/07/index.html","hash":"e0594b2ebe35e7d78d6003d372cb8dc23f9d92c8","modified":1530630789060},{"_id":"public/categories/java/page/4/index.html","hash":"f8e6fa218c9996fc1bcd8639fbdd1b37a4cf27ac","modified":1530630789060},{"_id":"public/categories/中间件/index.html","hash":"be93a8473ccd09b8f0c0a9789474f55207c6e354","modified":1530630789060},{"_id":"public/categories/开源/index.html","hash":"30a6714ce9abefe9e6fb9d90b6ec2f71eb857504","modified":1530630789060},{"_id":"public/categories/java/并发/index.html","hash":"c19e0c2d21e38a63d71e240981eafe0aedba22b5","modified":1530630789060},{"_id":"public/categories/java/集合/index.html","hash":"ce20fc65faa29c556783d93051bb0b2f77c730ce","modified":1530630789060},{"_id":"public/categories/java/多线程/index.html","hash":"790b535dfc52650b0be02807aed184a4aacfb847","modified":1530630789060},{"_id":"public/categories/框架/index.html","hash":"b8d72b5eb011fc30af9a1121a06bc27b5196e947","modified":1530630789060},{"_id":"public/categories/随笔/index.html","hash":"3a97a1d4bdf48e8cc1f8934c0d9dc0a20de9eb74","modified":1530630789061},{"_id":"public/categories/java/基础/index.html","hash":"c341843ec26c56742ad6a30f1bb27b636a05cf69","modified":1530630789061},{"_id":"public/categories/分布式/index.html","hash":"11027223538671f585eae422e83f6d83d890754e","modified":1530630789061},{"_id":"public/categories/分布式/微服务/index.html","hash":"faadf188e360d0e3c5331306613b32efcc5917f9","modified":1530630789061},{"_id":"public/tags/并发/index.html","hash":"4d6080172dc699711d191b8d1e063639fba4bea0","modified":1530630789061},{"_id":"public/tags/源码/page/2/index.html","hash":"ae0cda7a4175236b8461ad747b4ce3aac7b264c0","modified":1530630789061},{"_id":"public/tags/中间件/index.html","hash":"02eac71991c773e4995c62b79a792d63a3c68f72","modified":1530630789061},{"_id":"public/tags/开源/index.html","hash":"d5538265ddfcb6e48ea7807d942c2dc174c37b79","modified":1530630789061},{"_id":"public/tags/集合/index.html","hash":"0112c1e1ad58521ff226c1f5f8b2b10daa70b5b9","modified":1530630789061},{"_id":"public/tags/多线程/index.html","hash":"9c6ae9862e516817b31e289b822a3c4f87ca86f8","modified":1530630789061},{"_id":"public/tags/框架/index.html","hash":"f4d76e181bcadc375f0547777c9edfcab69c3b17","modified":1530630789062},{"_id":"public/tags/sharding-jdbc/index.html","hash":"72b067aa7b10f65fda5ff5cbc63f6e45b97f5916","modified":1530630789062},{"_id":"public/tags/mysql/index.html","hash":"115b0970aebc2f802ebafc2e8f29582606f81165","modified":1530630789062},{"_id":"public/tags/rocketmq/index.html","hash":"8d9c1bbabdab5fc9546fa085e99352d695f42803","modified":1530630789062},{"_id":"public/tags/redis/index.html","hash":"8d7e95bbf67e6df1ee4d5533163f25e686292427","modified":1530630789062},{"_id":"public/tags/gc/index.html","hash":"47b27206e9ea00151acb6702c634ccbfefac6b00","modified":1530630789062},{"_id":"public/tags/cms/index.html","hash":"b553c3b415f3849aef2da5fd6ad14cafec5d1499","modified":1530630789062},{"_id":"public/tags/g1/index.html","hash":"ae33a851fa260f916f686f91adfdad29bb826950","modified":1530630789062},{"_id":"public/tags/jmm/index.html","hash":"ee00af30a41369792ffbb6e60c769d5625fcce55","modified":1530630789062},{"_id":"public/tags/随笔/index.html","hash":"5cbc3058cd5d105429c7893c2fb0f8abfbba709c","modified":1530630789062},{"_id":"public/tags/基础/index.html","hash":"f9aacc6cd7338998614412ff230645bd9388c524","modified":1530630789062},{"_id":"public/tags/关键字/index.html","hash":"4f1c1b8789351508cc746af9fe2009eb5660f673","modified":1530630789063},{"_id":"public/tags/io/index.html","hash":"fed66c41b3742c948368b8ce91aeeda78f9b63a5","modified":1530630789063},{"_id":"public/tags/tcp/index.html","hash":"127644f3b0d953e46a207582e38159c73ca2960e","modified":1530630789063},{"_id":"public/tags/网络/index.html","hash":"afba8952591f878990f2197b31fb5dabd7f174bf","modified":1530630789063},{"_id":"public/tags/分布式/index.html","hash":"741a5a47496eed8041c308f8ee1bff12d03c475f","modified":1530630789063},{"_id":"public/tags/jit/index.html","hash":"aec15e874f0413b54a789b48a4bb3c937b341e05","modified":1530630789063},{"_id":"public/tags/锁/index.html","hash":"290770b930854ac770458b6b52341b71c972e82f","modified":1530630789063},{"_id":"public/tags/微服务/index.html","hash":"d33b14d9e161fe1a9a67a500dc4e2f2e9a6bdb13","modified":1530630789063},{"_id":"public/tags/攻击/index.html","hash":"5c3f95d16b0cc82726ba6356fbb123ff8138978e","modified":1530630789063},{"_id":"public/tags/设计模式/index.html","hash":"9b99d68bd411f1498271a01719718a7bed53b6de","modified":1530630789063},{"_id":"public/2018/07/02/DTS技术调研：分库分表/index.html","hash":"29238d064da93bffa4eae8ae458f96039674b24e","modified":1530630789063},{"_id":"public/2018/06/28/DTS技术调研前言/index.html","hash":"661c96005f65b7c53e8457b5827f447d75928efb","modified":1530630789063},{"_id":"public/2018/06/26/DTS功能构思/index.html","hash":"5db84ea5c9818bd04d714be4d6d6596fb6a4a4f9","modified":1530630789064},{"_id":"public/2018/06/25/Map分析/index.html","hash":"7623d7e72a79f8aa6d49b4fc1ea14f0d427ee8f5","modified":1530630789064},{"_id":"public/2018/06/24/AQS分析/index.html","hash":"f2042eb2897b872ce3f514fef7f4c799331ac668","modified":1530630789064},{"_id":"public/2018/06/24/RocketMQ笔记/index.html","hash":"28b2aeefdacd2f2ff24c972a939b12e7724ca621","modified":1530630789064},{"_id":"public/2018/06/24/分布式锁/index.html","hash":"68598e9ee836d5a72fe5d06eddd1f200628810ae","modified":1530630789064},{"_id":"public/2018/06/24/缓存预热，缓存穿透，缓存雪崩/index.html","hash":"41fda4c92d43d1165d3ade0199fe4725de47e2f0","modified":1530630789064},{"_id":"public/2018/06/24/Mysql笔记/index.html","hash":"198c91e052b3b400125ed256a9ffe4c651a8941c","modified":1530630789064},{"_id":"public/2018/06/23/Queue分析/index.html","hash":"873680b21ec20d35d81f818db66a6bf284654ca4","modified":1530630789064},{"_id":"public/2018/06/23/List分析/index.html","hash":"e8bb9ece93e67c7d4bc32214f11a7f6c104b800b","modified":1530630789064},{"_id":"public/2018/06/23/集合/index.html","hash":"319f181562cbec3f8c6e4e7242cbff6a75c5d8ec","modified":1530630789064},{"_id":"public/2018/06/23/锁分类/index.html","hash":"f97b55e174d36cfb7fc8b9f4744b8d41b379fa3c","modified":1530630789064},{"_id":"public/2018/06/23/Unsafe分析/index.html","hash":"2c6f99087df9f7e16af91566e120b612dd0ae4b1","modified":1530630789065},{"_id":"public/2018/06/23/Atomic分析/index.html","hash":"f7425086236ea6f0dff7bb182dc46494329c1ff8","modified":1530630789065},{"_id":"public/2018/06/23/ThreadPoolExecutor分析/index.html","hash":"2fee90a04f445a4c1c931bc87e9c3120490d3cec","modified":1530630789065},{"_id":"public/2018/06/23/ThreadLocal分析/index.html","hash":"6e4baaecb27409f11586eb98c5f25c0803d8bf9a","modified":1530630789065},{"_id":"public/2018/06/23/Thread分析/index.html","hash":"a57e851fb25e6c322399dae722c59d1e7208dd36","modified":1530630789065},{"_id":"public/2018/06/23/ScheduledThreadPoolExecutor分析/index.html","hash":"12ff9705342330034e5c3e83a621c0d42917c0ac","modified":1530630789065},{"_id":"public/2018/06/23/FutureTask分析/index.html","hash":"4864dc149b52ee59534c78a4ba0f3ec711ae76aa","modified":1530630789065},{"_id":"public/2018/06/23/设计模式/index.html","hash":"56fdc30f7e197825711e841a930d7925abc487df","modified":1530630789065},{"_id":"public/2018/06/23/语法糖/index.html","hash":"222d1639c1753345e1667e7358043ec70d987eda","modified":1530630789065},{"_id":"public/2018/06/23/攻击防范/index.html","hash":"38e22121108edf66588545cfa9aa30a8d9285da5","modified":1530630789065},{"_id":"public/2018/06/23/instanceof/index.html","hash":"72d263b33bd6d56900bf3dfc4e71239a84864552","modified":1530630789065},{"_id":"public/2018/06/23/io/index.html","hash":"c87d3a30f021ba59dee91cbb91c83c147b2d4de0","modified":1530630789065},{"_id":"public/2018/06/23/重排序/index.html","hash":"8efde2562772ec2417fba47b4d90e22f8b0bce20","modified":1530630789065},{"_id":"public/2018/06/23/类加载/index.html","hash":"c332e3e9f5200c7b743886c4adffdc8fc6615402","modified":1530630789065},{"_id":"public/2018/06/23/synchronized/index.html","hash":"2ad8e587145a8282c28dc6242ede5c1cc54e5185","modified":1530630789066},{"_id":"public/2018/06/23/jmm/index.html","hash":"9652a690f93ccdc57c3e58487671395a1b60cc42","modified":1530630789066},{"_id":"public/2018/06/22/gc介绍/index.html","hash":"abb5a3c2afd23e5babaa0c2e34432c05d4783aff","modified":1530630789066},{"_id":"public/2018/06/22/gc日志/index.html","hash":"2cad67f76c5df0156dcaba2576dcdb3ebe0b6528","modified":1530630789066},{"_id":"public/archives/index.html","hash":"fe5dd54cee816ce25480336a4ee3ed678650f2a8","modified":1530630789066},{"_id":"public/archives/page/2/index.html","hash":"5f1f87b8a677fc30b20d45aa7ec19ac99a5fcf39","modified":1530630789066},{"_id":"public/archives/page/3/index.html","hash":"fedce8d118d6b3ecbe6bca60503aded16c1f3e76","modified":1530630789067},{"_id":"public/archives/page/4/index.html","hash":"b568711d17a084d18a57151aca84c6c0543413f0","modified":1530630789068},{"_id":"public/archives/2018/index.html","hash":"80207881716c9091da3dd62ffd1efd8482043fc1","modified":1530630789068},{"_id":"public/archives/2018/page/2/index.html","hash":"4358d836b30de75623029b0cd7a3dee48ab63902","modified":1530630789068},{"_id":"public/archives/2018/page/3/index.html","hash":"fcb3df72c681734f2312fc4d41596361fc9d68f8","modified":1530630789068},{"_id":"public/archives/2018/page/4/index.html","hash":"8aa003080d54801b7e8aa06b40f200da43d04e5c","modified":1530630789069},{"_id":"public/archives/2018/06/index.html","hash":"b29a537d839b9bd1e7e7f38ab7aecba89acaab1e","modified":1530630789069},{"_id":"public/archives/2018/06/page/2/index.html","hash":"4ba9aa8307ff228368748d87aa40fa7abafa5d5c","modified":1530630789069},{"_id":"public/archives/2018/06/page/3/index.html","hash":"1849a726a5622da84115f9223231fb8f73f3c1cc","modified":1530630789069},{"_id":"public/archives/2018/06/page/4/index.html","hash":"f987893f4807fe8c64b881797f258b9b1d3afbc6","modified":1530630789069},{"_id":"public/index.html","hash":"76266faf3b6bce5fe4ecd6596fb824984459fa77","modified":1530630789069},{"_id":"public/page/2/index.html","hash":"e9d37219d9a17fc02afa0f9d9fac13181d5908e5","modified":1530630789069},{"_id":"public/page/3/index.html","hash":"674b0925eeda5fde68369048191c4fc5484779e2","modified":1530630789069},{"_id":"public/page/4/index.html","hash":"f16f4f74018eb6e2b18fa8481ea5a4b9b5f065d5","modified":1530630789070},{"_id":"public/page/5/index.html","hash":"031b6383cfae9abccf897b4b3d09164d5d159eca","modified":1530630789070},{"_id":"public/categories/java/index.html","hash":"50f0137f5085645f0d6c3fc743cd2881a21e241b","modified":1530630789070},{"_id":"public/categories/java/page/2/index.html","hash":"b9217c5fed646f81aa7a7f26402acc748c0bdfad","modified":1530630789070},{"_id":"public/categories/java/page/3/index.html","hash":"d12f9ab309a249df0254d4815a78cf80cce2b103","modified":1530630789070},{"_id":"public/categories/java/jvm/index.html","hash":"5c369954f586a5fb5f94c5db56d79c50329d22b5","modified":1530630789070},{"_id":"public/tags/java/index.html","hash":"ba8d8819c6127842faad40cb246d637ef891335c","modified":1530630789070},{"_id":"public/tags/java/page/2/index.html","hash":"3c943b3b006d03f3ac039ea0b750edd9e8853a3f","modified":1530630789070},{"_id":"public/tags/java/page/3/index.html","hash":"5972dfbdf3e077774a175b2792a65d0f77f86b0a","modified":1530630789070},{"_id":"public/tags/源码/index.html","hash":"01ecb95d48e82645665ca5edcc9258c647f05a42","modified":1530630789070},{"_id":"public/tags/jvm/index.html","hash":"cd04440b83019bc173710922eb3fe6aaed561788","modified":1530630789070},{"_id":"public/favicon.png","hash":"e9bb82157ddf12ac83675920eaf70abb921b22b7","modified":1530630789095},{"_id":"public/images/g1内存示意.png","hash":"e27ef533650af0999975208580886544340550c4","modified":1530630789095},{"_id":"public/images/hotspot架构.png","hash":"331c33d00f4e2c17586b8f42de4099713dae6fee","modified":1530630789095},{"_id":"public/images/javac流程.gif","hash":"f58d618625a68f244541143aa6b109f3255558d8","modified":1530630789095},{"_id":"public/images/skip-list.jpg","hash":"0b25a5cee9d310bb0dc403356a54de07afd6a43c","modified":1530630789095},{"_id":"public/images/tcp状态.gif","hash":"51e327b155854b66b2ea359ca15404804ab6a15e","modified":1530630789095},{"_id":"public/images/处理器内存.png","hash":"ac36c0baa12db091dd8cb0923c62e136e4451ab7","modified":1530630789096},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1530630789096},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1530630789096},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1530630789096},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1530630789096},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1530630789096},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1530630789096},{"_id":"public/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1530630789097},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1530630789097},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1530630789097},{"_id":"public/css/images/favicon.png","hash":"dbc4cac8bc52a7bf32e36f64efdccee1aef43ca4","modified":1530630789097},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1530630789097},{"_id":"public/images/CLH.jpg","hash":"ec2047057157acceecb412b3b19e2a5a866ed983","modified":1530630789593},{"_id":"public/images/B+树.png","hash":"b5dce96706cf029e1b3dad131ac34cc53e5a2e99","modified":1530630789593},{"_id":"public/images/jit流程.gif","hash":"108d46716fb98e7be300982a8b5d64822e81e89a","modified":1530630789595},{"_id":"public/images/MVCC2.jpg","hash":"00161c62709deac9145fb654cfa2240c6deb929f","modified":1530630789595},{"_id":"public/images/MVCC1.jpg","hash":"4099b6ed584280714df6b54ef07ee146f647299c","modified":1530630789595},{"_id":"public/images/putVal1.png","hash":"2fc14ece21a151ef2d9afea99ddee90408d37834","modified":1530630789595},{"_id":"public/images/mysql结构.jpg","hash":"6b098808617ef95c21cd619549e8fb2cc170312a","modified":1530630789595},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1530630789595},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1530630789643},{"_id":"public/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1530630789643},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1530630789643},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1530630789643},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1530630789643},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1530630789643},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1530630789643},{"_id":"public/css/style.css","hash":"07748dab66942849a44239e709eec9247bdfaaf4","modified":1530630789643},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1530630789643},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1530630789644},{"_id":"public/images/常用集合.png","hash":"62e66b9bbc4483eaec39ed8abf9b9e7bb4cdba1a","modified":1530630789644},{"_id":"public/images/mysql查询过程.png","hash":"6129cadc7fb8627c5ab6ad07c4b8cdca499cbb14","modified":1530630789644},{"_id":"public/images/get1.png","hash":"d14a782a60903ee1906897419ddeb1d84a5f251b","modified":1530630789655},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1530630789655},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1530630789655},{"_id":"public/images/get2.png","hash":"55a90322e349acaff59496c3bd08c096284e13f0","modified":1530630789659},{"_id":"public/images/putVal2.png","hash":"e5f7112e6d0bb57f6366fbe804997fb218ffbfe3","modified":1530630789662},{"_id":"public/images/AQS.jpg","hash":"bf5f78a0dc1df74390d5377e6aef817cf8e6e1e1","modified":1530630789662},{"_id":"public/images/MarkWord.png","hash":"000eb1a1a28874f55acaffc2c5716836e3d730fe","modified":1530630789665}],"Category":[{"name":"java","_id":"cjj5u1tul00021av8z20dc4b5"},{"name":"中间件","_id":"cjj5u1tuv000b1av8gnq4j3j7"},{"name":"开源","_id":"cjj5u1tuz000f1av8o16h8vra"},{"name":"并发","parent":"cjj5u1tul00021av8z20dc4b5","_id":"cjj5u1tv3000m1av8wezuswre"},{"name":"集合","parent":"cjj5u1tul00021av8z20dc4b5","_id":"cjj5u1tv8000t1av8hzpcp59g"},{"name":"多线程","parent":"cjj5u1tul00021av8z20dc4b5","_id":"cjj5u1tvf00181av8yqj0wlnm"},{"name":"框架","_id":"cjj5u1tvi001g1av8jvxcu66s"},{"name":"jvm","parent":"cjj5u1tul00021av8z20dc4b5","_id":"cjj5u1twe002v1av8ksgzk38n"},{"name":"随笔","_id":"cjj5u1twt003i1av8u7wedllg"},{"name":"基础","parent":"cjj5u1tul00021av8z20dc4b5","_id":"cjj5u1tx2003z1av8h1k98g1d"},{"name":"分布式","_id":"cjj5u1txa004z1av8j1fu2cet"},{"name":"微服务","parent":"cjj5u1txa004z1av8j1fu2cet","_id":"cjj5u1txn00661av8ptyprwo2"}],"Data":[],"Page":[],"Post":[{"title":"Atomic分析","date":"2018-06-23T10:25:39.000Z","toc":true,"_content":"# AtomicInteger\n粗暴一些，直接分析源码了\n<!-- more -->\n以下几个方法着重体现了，AtomicInteger主要是调用Unsafe实现的，具体请看[Unsafe](/2018/06/23/Unsafe分析)\n```java\npublic class AtomicInteger extends Number implements java.io.Serializable {\n    private static final long serialVersionUID = 6214790243416807050L;\n    private static final Unsafe unsafe = Unsafe.getUnsafe();\n    private static final long valueOffset;\n\n    static {\n        try {\n            // 获取value属性的偏移量，通过Unsafe直接去操作\n            valueOffset = unsafe.objectFieldOffset\n                (AtomicInteger.class.getDeclaredField(\"value\"));\n        } catch (Exception ex) { throw new Error(ex); }\n    }\n\n    private volatile int value;\n\n    public final void lazySet(int newValue) {\n        // 深度思考，这边为什么使用count = newValue\n        // 因为\"count = newValue\"会插入storeLoad屏障\n        // 而putOrderedInt插入的是storeStore屏障\n        unsafe.putOrderedInt(this, valueOffset, newValue);\n    }\n\n    public final int getAndAdd(int delta) {\n        return unsafe.getAndAddInt(this, valueOffset, delta);\n    }\n\n    public final int incrementAndGet() {\n        return unsafe.getAndAddInt(this, valueOffset, 1) + 1;\n    }\n\n    public final int decrementAndGet() {\n        return unsafe.getAndAddInt(this, valueOffset, -1) - 1;\n    }\n\n    public final int addAndGet(int delta) {\n        return unsafe.getAndAddInt(this, valueOffset, delta) + delta;\n    }\n}\n```\n# AtomicFloat\n实现可以使用`Float.floatToIntBits()`函数。","source":"_posts/Atomic分析.md","raw":"---\ntitle: Atomic分析\ndate: 2018-06-23 18:25:39\ntags:\n- java\n- 并发\n- 源码\ncategories:\n- java\n- 并发\ntoc: true\n---\n# AtomicInteger\n粗暴一些，直接分析源码了\n<!-- more -->\n以下几个方法着重体现了，AtomicInteger主要是调用Unsafe实现的，具体请看[Unsafe](/2018/06/23/Unsafe分析)\n```java\npublic class AtomicInteger extends Number implements java.io.Serializable {\n    private static final long serialVersionUID = 6214790243416807050L;\n    private static final Unsafe unsafe = Unsafe.getUnsafe();\n    private static final long valueOffset;\n\n    static {\n        try {\n            // 获取value属性的偏移量，通过Unsafe直接去操作\n            valueOffset = unsafe.objectFieldOffset\n                (AtomicInteger.class.getDeclaredField(\"value\"));\n        } catch (Exception ex) { throw new Error(ex); }\n    }\n\n    private volatile int value;\n\n    public final void lazySet(int newValue) {\n        // 深度思考，这边为什么使用count = newValue\n        // 因为\"count = newValue\"会插入storeLoad屏障\n        // 而putOrderedInt插入的是storeStore屏障\n        unsafe.putOrderedInt(this, valueOffset, newValue);\n    }\n\n    public final int getAndAdd(int delta) {\n        return unsafe.getAndAddInt(this, valueOffset, delta);\n    }\n\n    public final int incrementAndGet() {\n        return unsafe.getAndAddInt(this, valueOffset, 1) + 1;\n    }\n\n    public final int decrementAndGet() {\n        return unsafe.getAndAddInt(this, valueOffset, -1) - 1;\n    }\n\n    public final int addAndGet(int delta) {\n        return unsafe.getAndAddInt(this, valueOffset, delta) + delta;\n    }\n}\n```\n# AtomicFloat\n实现可以使用`Float.floatToIntBits()`函数。","slug":"Atomic分析","published":1,"updated":"2018-06-23T10:32:45.010Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5u1tud00001av8z7l81cof","content":"<h1 id=\"AtomicInteger\"><a href=\"#AtomicInteger\" class=\"headerlink\" title=\"AtomicInteger\"></a>AtomicInteger</h1><p>粗暴一些，直接分析源码了<br><a id=\"more\"></a><br>以下几个方法着重体现了，AtomicInteger主要是调用Unsafe实现的，具体请看<a href=\"/2018/06/23/Unsafe分析\">Unsafe</a><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AtomicInteger</span> <span class=\"keyword\">extends</span> <span class=\"title\">Number</span> <span class=\"keyword\">implements</span> <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">6214790243416807050L</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> valueOffset;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 获取value属性的偏移量，通过Unsafe直接去操作</span></span><br><span class=\"line\">            valueOffset = unsafe.objectFieldOffset</span><br><span class=\"line\">                (AtomicInteger.class.getDeclaredField(<span class=\"string\">\"value\"</span>));</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception ex) &#123; <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(ex); &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> value;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">lazySet</span><span class=\"params\">(<span class=\"keyword\">int</span> newValue)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 深度思考，这边为什么使用count = newValue</span></span><br><span class=\"line\">        <span class=\"comment\">// 因为\"count = newValue\"会插入storeLoad屏障</span></span><br><span class=\"line\">        <span class=\"comment\">// 而putOrderedInt插入的是storeStore屏障</span></span><br><span class=\"line\">        unsafe.putOrderedInt(<span class=\"keyword\">this</span>, valueOffset, newValue);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">getAndAdd</span><span class=\"params\">(<span class=\"keyword\">int</span> delta)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> unsafe.getAndAddInt(<span class=\"keyword\">this</span>, valueOffset, delta);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">incrementAndGet</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> unsafe.getAndAddInt(<span class=\"keyword\">this</span>, valueOffset, <span class=\"number\">1</span>) + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">decrementAndGet</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> unsafe.getAndAddInt(<span class=\"keyword\">this</span>, valueOffset, -<span class=\"number\">1</span>) - <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">addAndGet</span><span class=\"params\">(<span class=\"keyword\">int</span> delta)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> unsafe.getAndAddInt(<span class=\"keyword\">this</span>, valueOffset, delta) + delta;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"AtomicFloat\"><a href=\"#AtomicFloat\" class=\"headerlink\" title=\"AtomicFloat\"></a>AtomicFloat</h1><p>实现可以使用<code>Float.floatToIntBits()</code>函数。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"AtomicInteger\"><a href=\"#AtomicInteger\" class=\"headerlink\" title=\"AtomicInteger\"></a>AtomicInteger</h1><p>粗暴一些，直接分析源码了<br>","more":"<br>以下几个方法着重体现了，AtomicInteger主要是调用Unsafe实现的，具体请看<a href=\"/2018/06/23/Unsafe分析\">Unsafe</a><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AtomicInteger</span> <span class=\"keyword\">extends</span> <span class=\"title\">Number</span> <span class=\"keyword\">implements</span> <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">6214790243416807050L</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> valueOffset;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 获取value属性的偏移量，通过Unsafe直接去操作</span></span><br><span class=\"line\">            valueOffset = unsafe.objectFieldOffset</span><br><span class=\"line\">                (AtomicInteger.class.getDeclaredField(<span class=\"string\">\"value\"</span>));</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception ex) &#123; <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(ex); &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> value;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">lazySet</span><span class=\"params\">(<span class=\"keyword\">int</span> newValue)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 深度思考，这边为什么使用count = newValue</span></span><br><span class=\"line\">        <span class=\"comment\">// 因为\"count = newValue\"会插入storeLoad屏障</span></span><br><span class=\"line\">        <span class=\"comment\">// 而putOrderedInt插入的是storeStore屏障</span></span><br><span class=\"line\">        unsafe.putOrderedInt(<span class=\"keyword\">this</span>, valueOffset, newValue);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">getAndAdd</span><span class=\"params\">(<span class=\"keyword\">int</span> delta)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> unsafe.getAndAddInt(<span class=\"keyword\">this</span>, valueOffset, delta);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">incrementAndGet</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> unsafe.getAndAddInt(<span class=\"keyword\">this</span>, valueOffset, <span class=\"number\">1</span>) + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">decrementAndGet</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> unsafe.getAndAddInt(<span class=\"keyword\">this</span>, valueOffset, -<span class=\"number\">1</span>) - <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">addAndGet</span><span class=\"params\">(<span class=\"keyword\">int</span> delta)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> unsafe.getAndAddInt(<span class=\"keyword\">this</span>, valueOffset, delta) + delta;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"AtomicFloat\"><a href=\"#AtomicFloat\" class=\"headerlink\" title=\"AtomicFloat\"></a>AtomicFloat</h1><p>实现可以使用<code>Float.floatToIntBits()</code>函数。</p>"},{"title":"AQS分析","date":"2018-06-24T12:24:52.000Z","toc":true,"_content":"\n# CLH队列\n## 原理\n<img src=\"/images/CLH.jpg\" height=\"80%\" width=\"60%\">\n<!-- more -->\n## 示例\n```java\npublic class CLHLock {\n    @Data\n    class Node {\n        private volatile boolean locking;\n        private volatile int lockedCount;\n\n        Node() {\n            lockedCount = 1;\n        }\n    }\n\n    private AtomicReference<Node> tail;\n    private ThreadLocal<Node> myself = ThreadLocal.withInitial(() -> new Node());\n\n    public CLHLock() {\n        tail = new AtomicReference<>();\n    }\n\n    public void lock() {\n        Node current = myself.get();\n\n        if (current.locking) {\n            ++current.lockedCount;\n            return;\n        } else {\n            current.locking = true;\n        }\n\n        Node previous = tail.getAndSet(current);\n        while (previous != null && previous.locking) {\n            Thread.yield();\n        }\n    }\n\n    public void unlock() {\n        Node current = myself.get();\n\n        if (--current.lockedCount == 0) {\n            current.locking = false;\n            myself.remove();\n        }\n    }\n\n    static volatile int count = 0;\n\n    public static void main(String[] args) {\n        ExecutorService executorService = Executors.newFixedThreadPool(1);\n        int max = 1000000;\n        CLHLock clhLock = new CLHLock();\n\n        Stopwatch stopwatch = Stopwatch.createStarted();\n        for (int i = 0; i < max; i++) {\n            executorService.submit(() -> {\n                clhLock.lock();\n                clhLock.lock();\n\n                if (count % 100 == 0) {\n                    System.out.println(count);\n                }\n                ++count;\n\n                clhLock.unlock();\n                clhLock.unlock();\n            });\n        }\n\n        while (count != max) ;\n        executorService.shutdownNow();\n        System.out.println(\"lock is right, count: \" + count);\n        System.out.println(\"used time: \" + stopwatch.elapsed());\n    }\n}\n```\n\n# AQS\n## 原理\n1. 数据结构等待链表，使用的是尾插法\n2. Lock等方法，都是不会主动抛出`InterruptedException`的，除非调用可中断版本\n\n![AQS原理](/images/AQS.jpg)\n## 静态属性\n1. `long spinForTimeoutThreshold = 1000L`，超过此时间将会采用LockSupport.parkNanos()，而不是自旋\n\n## 成员属性\n1. `volatile Node head`，链表的头结点，傀儡节点（prev，\bthread属性都为空）\n2. `volatile Node tail`，链表的尾结点，\n3. `volatile int state`，状态变量，用于控制获取的\n\n## 主要方法\n### 可中断等待\n1. `LockSupport.park()`会从`Thread.interrupt()`中被唤醒\n2. 添加`Thread.interrupted()`检测\n\n下面的代码展示了如何实现中断的。\n```java\nprivate void doAcquireInterruptibly(int arg)\n    throws InterruptedException {\n    final Node node = addWaiter(Node.EXCLUSIVE);\n    boolean failed = true;\n    try {\n        for (;;) {\n            final Node p = node.predecessor();\n            if (p == head && tryAcquire(arg)) {\n                setHead(node);\n                p.next = null; // help GC\n                failed = false;\n                return;\n            }\n            if (shouldParkAfterFailedAcquire(p, node) && parkAndCheckInterrupt())\n                throw new InterruptedException();\n        }\n    } finally {\n        if (failed)\n            cancelAcquire(node);\n    }\n}\n```\n### Node\n1. `int waitStatus`，当前节点的等待状态\n    - SIGNAL，代表当前节点需要被\u001b唤醒\n    - CANCELLED，\b代表当前节点已经被取消\n    - CONDITION，\u001b\u001b代表当前节点在等待一个条件\n    - PROPAGATE，代表当前节点正在被多个线程同时操作，并且是shared\u001b方式获取，需要向后传播\n    - 0，代表当前节点正常，没有任何操作进行\n2. `Node prev`，前一个节点\n3. `Node next`，后一个节点\n4. `Thread thread`，等待的线程\n5. `Node nextWaiter`，\u001b下一个Condition\b链表中的节点，或者表示\b当前是否在独占模式等待\n\n### hasQueuedPredecessors\n**\b这个方法重中之重，用于判断公平性**\n```java\n// 用于判断等待链中的第一个等待线程是不是自己\npublic final boolean hasQueuedPredecessors() {\n    Node t = tail; \n    Node h = head;\n    Node s;\n    return h != t \n        && ((s = h.next) == null \n             || s.thread != Thread.currentThread());\n}\n```\n### \b\u001btryAcquire, acquire\n```java\n// 摘自于ReentrantLock的FairSync\nprotected final boolean tryAcquire(int acquires) {\n    final Thread current = Thread.currentThread();\n    int c = getState();\n\n    // 如果锁没有被加锁\n    if (c == 0) {\n        // 不存在前驱节点，并且\b成功获取了许可\n        if (!hasQueuedPredecessors() &&\n            compareAndSetState(0, acquires)) {\n            // 将当前\u001b线程设置为拥有者\n            setExclusiveOwnerThread(current);\n            return true;\n        }\n    }\n    // 如果当前线程是拥有者\n    else if (current == getExclusiveOwnerThread()) {\n        // 尝试更新拥有许可计数\n        int nextc = c + acquires;\n        if (nextc < 0)\n            throw new Error(\"Maximum lock count exceeded\");\n        setState(nextc);\n        return true;\n    }\n    return false;\n}\n\n// 检查\nprivate static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {\n    // 查看上一个节点状态\n    int ws = pred.waitStatus;\n    // 上一个节点是SIGNAL\n    if (ws == Node.SIGNAL)\n        return true;\n    // 寻找到上个\b在等待的节点，或者是已经获取锁的节点\n    if (ws > 0) {\n        do {\n            node.prev = pred = pred.prev;\n        } while (pred.waitStatus > 0);\n        pred.next = node;\n    } else {\n        // 更改上个节点状态\u001b，便于后续的判断\n        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);\n    }\n    return false;\n}\n\n// 进入阻塞，等待被唤醒\nprivate final boolean parkAndCheckInterrupt() {\n    LockSupport.park(this);\n    return Thread.interrupted();\n}\n\n// \u001b获取许可\nfinal boolean acquireQueued(final Node node, int arg) {\n    boolean failed = true;\n    try {\n        boolean interrupted = false;\n        for (;;) {\n            final Node p = node.predecessor();\n            // 当前线程是第一个等待线程，\u001b并且获取成功\n            if (p == head && tryAcquire(arg)) {\n                // 重新设置头结点\n                setHead(node);\n                p.next = null; // help GC\n                failed = false;\n                // 返回是否被中断\n                return interrupted;\n            }\n            // 需要等待（上个\u001b有效节点不是头结点)\n            // 并且尝试等待\n            if (shouldParkAfterFailedAcquire(p, node) \n                    && parkAndCheckInterrupt())\n                interrupted = true;\n        }\n    } finally {\n        // 如果异常终止，则取消当前获取\n        if (failed)\n            cancelAcquire(node);\n    }\n}\n\npublic final void acquire(int arg) {\n    // 尝试获取，不成功则进入阻塞获取阶段\n    if (!tryAcquire(arg)\n            && acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n        selfInterrupt();\n    }\n}\n\n// 唤醒链表中最前面的等待线程\nprivate void unparkSuccessor(Node node) {\n    int ws = node.waitStatus;\n    if (ws < 0)\n        compareAndSetWaitStatus(node, ws, 0);\n\n    Node s = node.next;\n    if (s == null || s.waitStatus > 0) {\n        s = null;\n        for (Node t = tail; t != null && t != node; t = t.prev)\n            if (t.waitStatus <= 0)\n                s = t;\n    }\n    if (s != null)\n        LockSupport.unpark(s.thread);\n}\n\n// 取消获取，并且设置状态\nprivate void cancelAcquire(Node node) {\n    if (node == null)\n        return;\n\n    node.thread = null;\n\n    // 跳过被取消的节点\n    Node pred = node.prev;\n    while (pred.waitStatus > 0)\n        node.prev = pred = pred.prev;\n\n    Node predNext = pred.next;\n    // 当前节点状态被设置为取消\n    node.waitStatus = Node.CANCELLED;\n\n    // 如果当前节点是尾结点\n    if (node == tail && compareAndSetTail(node, pred)) {\n        compareAndSetNext(pred, predNext, null);\n    } else {\n        int ws;\n        // 如果前面的节点不是\u001b头节点\n        // 并且在等待唤醒（SIGNAL，PROPAGATE，CONDITION），线程不为空\n        if (pred != head &&\n            ((ws = pred.waitStatus) == Node.SIGNAL \n                || (ws <= 0 && compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) \n                && pred.thread != null) {\n            Node next = node.next;\n            // 从链表中删除当前节点\n            if (next != null && next.waitStatus <= 0)\n                compareAndSetNext(pred, predNext, next);\n        } else {\n            // 直接唤醒待取消\u001b节点的下一个节点\n            unparkSuccessor(node);\n        }\n        // \u001b将当前节点脱链\n        node.next = node;\n    }\n}\n```\n### tryRelease, release\n```java\n// ReentrantLock的释放\nprotected final boolean tryRelease(int releases) {\n    int c = getState() - releases;\n    if (Thread.currentThread() != getExclusiveOwnerThread())\n        throw new IllegalMonitorStateException();\n    boolean free = false;\n    // 可重入锁的计数，计数为0，代表，已经释放所有许可\n    if (c == 0) {\n        free = true;\n        setExclusiveOwnerThread(null);\n    }\n    setState(c);\n    return free;\n}\npublic final boolean release(int arg) {\n    \u001b// 释放成功\n    if (tryRelease(arg)) {\n        Node h = head;\n        if (h != null && h.waitStatus != 0)\n            // 唤醒下一个等待线程\n            unparkSuccessor(h);\n        return true;\n    }\n    return false;\n}\n```\n### \b\u001btryAcquireShared, acquireShared\n```java\n// Semaphore的获取\nprotected int tryAcquireShared(int arg) {\n    for (; ; ) {\n        int available = getState();\n        int left = available - arg;\n\n        // \b\u001b许可不足，或者\b\b获取成功\n        if (left < 0 || compareAndSetState(available, left)) {\n            return left;\n        }\n    }\n}\n// 共享方式获取许可\npublic final void acquireShared(int arg) {\n    if (tryAcquireShared(arg) < 0)\n        // 尝试阻塞获取\n        doAcquireShared(arg);\n}\n\nprivate void setHeadAndPropagate(Node node, int propagate) {\n    Node h = head; // Record old head for check below\n    setHead(node);\n\n    // 保证传播性，如果下个节点也在等待\n    if (propagate > 0 || h == null || h.waitStatus < 0 \n            || (h = head) == null || h.waitStatus < 0) {\n        Node s = node.next;\n        // 下个节点是共享节点，唤醒下一个节点去获取许可\n        if (s == null || s.isShared())\n            doReleaseShared();\n    }\n}\n\n// 要点是获取许可成功之后，还会唤醒下一个等待线程去尝试获取\nprivate void doAcquireShared(int arg) {\n    // 把当前线程添加到等待链当中\n    final Node node = addWaiter(Node.SHARED);\n    boolean failed = true;\n    try {\n        boolean interrupted = false;\n        for (;;) {\n            final Node p = node.predecessor();\n            // 前面没有任何线程等待s\n            if (p == head) {\n                // 尝试再次获取\n                int r = tryAcquireShared(arg);\n                // 获取成功\n                if (r >= 0) {\n                    // 更新头结点，并且尝试唤醒下一个节点\n                    setHeadAndPropagate(node, r);\n                    p.next = null; // help GC\n                    if (interrupted)\n                        selfInterrupt();\n                    failed = false;\n                    return;\n                }\n            }\n            // 阻塞自己\n            if (shouldParkAfterFailedAcquire(p, node) && parkAndCheckInterrupt())\n                interrupted = true;\n        }\n    } finally {\n        if (failed)\n            cancelAcquire(node);\n    }\n}\n```\n### tryReleaseShared, releaseShared\n```java\n@Override\n// Semaphore的尝试释放\nprotected boolean tryReleaseShared(int arg) {\n    // 释放，死循环，知道陈宫\n    for (; ; ) {\n        int available = getState();\n        int left = available + arg;\n\n        if (left < 0) {\n            throw new Error(\"maximum limits get\");\n        } else if (compareAndSetState(available, left)) {\n            return true;\n        }\n    }\n}\n// \npublic final boolean releaseShared(int arg) {\n    // 尝试释放\n    if (tryReleaseShared(arg)) {\n        doReleaseShared();\n        return true;\n    }\n    return false;\n}\n\n// 唤醒下一个等待线程\nprivate void doReleaseShared() {\n    for (;;) {\n        Node h = head;\n        if (h != null && h != tail) {\n            // 头结点\n            int ws = h.waitStatus;\n            if (ws == Node.SIGNAL) {\n                // 更新头结点状态为0\n                // 这个自旋是为了保证释放的节点是需要被唤醒的节点\n                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))\n                    continue;\n                // 唤醒下一个节点，也是为了保证传播性\n                unparkSuccessor(h);\n            }\n            // 多个线程同时进行释放许可操作，继续\n            else if (ws == 0 && !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))\n                continue;\n        }\n        // 如果释放成功一个节点，\n        if (h == head) \n            break;\n    }\n}\n```\n### Condition\n如上面的图表示的，Condition内部含有一个链表下面是await和signal的简介。\n```java\npublic final void await() throws InterruptedException {\n    if (Thread.interrupted())\n        throw new InterruptedException();\n    // 加入Condition等待链表\n    Node node = addConditionWaiter();\n    int savedState = fullyRelease(node);\n    int interruptMode = 0;\n    // 当前在等待Condition\n    while (!isOnSyncQueue(node)) {\n        // 当前线程被调用signal唤醒\n        LockSupport.park(this);\n        // 当前线程被中断\n        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)\n            break;\n    }\n    // 当前线程没被中断的话，尝试以独占模式获取许可 \n    if (acquireQueued(node, savedState) && interruptMode != THROW_IE)\n        interruptMode = REINTERRUPT;\n    // 尝试删除被取消的节点\n    if (node.nextWaiter != null) // clean up if cancelled\n        unlinkCancelledWaiters();\n    // 抛出异常\n    if (interruptMode != 0)\n        reportInterruptAfterWait(interruptMode);\n}\n\n public final void signal() {\n     // 检测是否独占模式获取\n    if (!isHeldExclusively())\n        throw new IllegalMonitorStateException();\n    Node first = firstWaiter;\n    // 唤醒链表中的第一个节点（如果存在的话）\n    if (first != null)\n        doSignal(first);\n}\n\nprivate void doSignal(Node first) {\n    do {\n        if ( (firstWaiter = first.nextWaiter) == null)\n            lastWaiter = null;\n        first.nextWaiter = null;\n    } while (!transferForSignal(first) &&\n                (first = firstWaiter) != null);\n}\n\n// 将当前节点从Condition中脱链，加入到AQS的链表中（复用了一个节点）\nfinal boolean transferForSignal(Node node) {\n    // 节点已经被取消\n    if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))\n        return false;\n\n    // 将当前节点从Condition的等待队列转移到AQS的等待队列\n    Node p = enq(node);\n    int ws = p.waitStatus;\n    // 将节点状态，改成SIGNAL\n    if (ws > 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))\n        // 唤醒节点的等待线程\n        LockSupport.unpark(node.thread);\n    return true;\n}\n```\n## 调用关系\nacquire先调用tryAcquire，**不成功**，调用doAcquire()阻塞等待\nrelease先调用tryRelease，**成功了**，调用doRelease()释放下一个等待线程\n\n***\n# ReentrantLock\n内部一个Sync类，继承了AQS用于实现独占锁的功能，\u001b主要是实现了tryAcquire和tryRelease功能\n## 公平性\n由`hasQueuedPredecessors()`来保证的，如果存在前置节点，则返回尝试加锁失败\n## Sync\n```java\nprivate static final long serialVersionUID = -5179523762034025860L;\n    abstract void lock();\n\n    final boolean nonfairTryAcquire(int acquires) {\n        final Thread current = Thread.currentThread();\n        int c = getState();\n        // 还未加锁\n        if (c == 0) {\n            if (compareAndSetState(0, acquires)) {\n                setExclusiveOwnerThread(current);\n                return true;\n            }\n        }\n        // 当前线程是拥有者线程，此次是\b重入加锁\n        else if (current == getExclusiveOwnerThread()) {\n            // 多次加锁\n            int nextc = c + acquires;\n            if (nextc < 0)\n                throw new Error(\"Maximum lock count exceeded\");\n            setState(nextc);\n            return true;\n        }\n        return false;\n    }\n\n    protected final boolean tryRelease(int releases) {\n        int c = getState() - releases;\n        if (Thread.currentThread() != getExclusiveOwnerThread())\n            throw new IllegalMonitorStateException();\n        boolean free = false;\n        // 用于保证多次释放\n        if (c == 0) {\n            free = true;\n            setExclusiveOwnerThread(null);\n        }\n        setState(c);\n        return free;\n    }\n\n    final ConditionObject newCondition() {\n        return new ConditionObject();\n    }\n}\n\nstatic final class NonfairSync extends Sync {\n    final void lock() {\n        // 非公评锁，直接\b加锁（\b被唤醒的线程还未得到时间片运行，等运行时会进行再次书面）\n        if (compareAndSetState(0, 1))\n            setExclusiveOwnerThread(Thread.currentThread());\n        else\n            acquire(1);\n    }\n\n    protected final boolean tryAcquire(int acquires) {\n        return nonfairTryAcquire(acquires);\n    }\n}\n\nstatic final class FairSync extends Sync {\n    private static final long serialVersionUID = -3000897897090466540L;\n\n    final void lock() {\n        acquire(1);\n    }\n\n    protected final boolean tryAcquire(int acquires) {\n        final Thread current = Thread.currentThread();\n        int c = getState();\n        if (c == 0) {\n            // 公平性重点!!!!!!!!\n            if (!hasQueuedPredecessors() &&\n                compareAndSetState(0, acquires)) {\n                setExclusiveOwnerThread(current);\n                return true;\n            }\n        }\n        // 重复加锁\n        else if (current == getExclusiveOwnerThread()) {\n            int nextc = c + acquires;\n            if (nextc < 0)\n                throw new Error(\"Maximum lock count exceeded\");\n            setState(nextc);\n            return true;\n        }\n        return false;\n    }\n}\n```\n\n***\n# Semaphore\n基本和\bReentrantLock一样，主要实现了tryAcquiredShared()和tryReleaseShared()。\n## 公平性\n由`hasQueueProdecessors()`来决定的，如果存在前置节点就失败\n## 缺陷\n由于队列是FIFO的结构，导致了如果首元结点获取失败，则不会向后传播，下面是例子\n```java\n// 第一个线程启动后，尝试获取11个许可，但是由于获取失败，一直会阻塞。\n// 第二个启动后，由于公平性原因，获取直接失败，导致直接入队，此时如果队列头部一直获取失败的话，队列是不能有任何元素出队的。\nSemaphore semaphore = new Semaphore(10, true);\nnew Thread(() -> { semaphore.acquire(11); semaphore.release(11); }).start();\nnew Thread(() -> { semaphore.acquire(1), semaphore.release(1); }).start();\n```\n## Sync\n```java\nabstract static class Sync extends AbstractQueuedSynchronizer {\n    final int nonfairTryAcquireShared(int acquires) {\n        // 尝试去获取，不处理有线程等待的情况\n        for (;;) {\n            int available = getState();\n            int remaining = available - acquires;\n            if (remaining < 0 \n                    || compareAndSetState(available, remaining))\n                return remaining;\n        }\n    }\n\n    protected final boolean tryReleaseShared(int releases) {\n        // 利用死循环去释放，知道释放成功\n        for (;;) {\n            int current = getState();\n            int next = current + releases;\n            if (next < current) // overflow\n                throw new Error(\"Maximum permit count exceeded\");\n            if (compareAndSetState(current, next))\n                return true;\n        }\n    }\n}\n\nstatic final class NonfairSync extends Sync {\n    protected int tryAcquireShared(int acquires) {\n        return nonfairTryAcquireShared(acquires);\n    }\n}\n\nstatic final class FairSync extends Sync {\n    protected int tryAcquireShared(int acquires) {\n        for (;;) {\n            // 公平性重点\n            // \u001b已经有线程在等待，直接失败\n            if (hasQueuedPredecessors())\n                return -1;\n            int available = getState();\n            int remaining = available - acquires;\n            if (remaining < 0 ||\n                    compareAndSetState(available, remaining))\n                return remaining;\n        }\n    }\n}\n```\n\n***\n# CountDownLatch\n不可以**被重置**，并不代表技术上做不到，只是CountDownLatch就是用来用于一次性任务的，支持重置的话，可能会导致多组获取紊乱。\n## Sync\n内部使用state作为初始计数，每次获取则计数减一，到获取完后直接是释放所有线程\n```java\nprivate static final class Sync extends AbstractQueuedSynchronizer {\n    protected int tryAcquireShared(int acquires) {\n        // 这招太损了\n        // \n        return (getState() == 0) ? 1 : -1;\n    }\n\n    protected boolean tryReleaseShared(int releases) {\n        // Decrement count; signal when transition to zero\n        for (;;) {\n            int c = getState();\n            if (c == 0)\n                return false;\n            int nextc = c-1;\n            if (compareAndSetState(c, nextc))\n                return nextc == 0;\n        }\n    }\n}\n```\n\n***\n# CyclicBarrier\n## 思考：为什么不基于AQS实现\n没有办法单纯的只基于AQS就实现，**需要添加控制变量**。\n\n## 成员属性\n1. `final ReentrantLock lock = new ReentrantLock();`，用于保护await操作\n2. `final Condition trip = lock.newCondition();`用于等待被唤醒\n3. `final int parties;`最多支持的线程数量\n4. `final Runnable barrierCommand;`barrier被打破时执行的命令\n5. `Generation generation = new Generation();`代表当前barrier的状态\n6. `int count;`**没有volatile**，为什么不用volatile，count只在doAwait\b()方法内部访问，而doAwait是全程加锁的，也就是代表count的访问永远\b都是单线程的访问。\n\n## 主要方法\n### doAwait\n```java\n// 处理几种异常\n// 1. 超时\n// 2. 被中断\n// 3. 执行command时异常\nprivate int dowait(boolean timed, long nanos) throws InterruptedException, BrokenBarrierException, TimeoutException {\n    final ReentrantLock lock = this.lock;\n    lock.lock();\n    try {\n        final Generation g = generation;\n        // 如果屏障已经解除，这个照理来说不可能发生的\n        // 除非某个线程被中断了，并且唤醒了所有等待线程\n        if (g.broken)\n            throw new BrokenBarrierException();\n        if (Thread.interrupted()) {\n            breakBarrier();\n            throw new InterruptedException();\n        }\n        int index = --count;\n        // index为0，代表需要解除屏障\n        if (index == 0) {  // tripped\n            boolean ranAction = false;\n            try {\n                // 运行命令\n                final Runnable command = barrierCommand;\n                if (command != null)\n                    command.run();\n                ranAction = true;\n                // 将所有线程唤醒，并且更新generation，但是不更新count\n                nextGeneration();\n                return 0;\n            } finally {\n                // 运行command过程出错\n                if (!ranAction)\n                    breakBarrier();\n            }\n        }\n        for (;;) {\n            // 超时等待，并且处理被中断的情况\n            try {\n                if (!timed)\n                    trip.await();\n                else if (nanos > 0L)\n                    nanos = trip.awaitNanos(nanos);\n            } catch (InterruptedException ie) {\n                if (g == generation && ! g.broken) {\n                    breakBarrier();\n                    throw ie;\n                } else {\n                    Thread.currentThread().interrupt();\n                }\n            }\n\n            if (g.broken)\n                throw new BrokenBarrierException();\n\n            if (g != generation)\n                // 返回当前线程的等待序号\n                return index;\n\n            if (timed && nanos <= 0L) {\n                breakBarrier();\n                throw new TimeoutException();\n            }\n        }\n    } finally {\n        lock.unlock();\n    }\n}\n```\n\n### reset\n```java\n// 构建新的屏障\nprivate void nextGeneration() {\n    trip.signalAll();\n    count = parties;\n    generation = new Generation();\n}\n\n// 清除当前屏障\nprivate void breakBarrier() {\n    generation.broken = true;\n    count = parties;\n    trip.signalAll();\n}\n\npublic void reset() {\n    final ReentrantLock lock = this.lock;\n    lock.lock();\n    try {\n        breakBarrier();\n        nextGeneration();\n    } finally {\n        lock.unlock();\n    }\n}\n```\n\n\n# ReadWriteLock\n内部原理是state状态变量的低16位代表写锁数量，高16位代表读锁数量。\n`ReadLock.lock()`调用`tryAcquireShared`\n`WriteLock.lock()`调用`tryAcquire`\n## 写锁降级\n原理是先获取读锁（直接获取会成功），释放写锁（同时虽然会唤醒头等待线程，但是没有用，获取不到）\n## 读锁升级\n直接加写锁呗","source":"_posts/AQS分析.md","raw":"---\ntitle: AQS分析\ndate: 2018-06-24 20:24:52\ntags:\n- java\n- 并发\n- 源码\ncategories:\n- java\n- 并发\ntoc: true\n---\n\n# CLH队列\n## 原理\n<img src=\"/images/CLH.jpg\" height=\"80%\" width=\"60%\">\n<!-- more -->\n## 示例\n```java\npublic class CLHLock {\n    @Data\n    class Node {\n        private volatile boolean locking;\n        private volatile int lockedCount;\n\n        Node() {\n            lockedCount = 1;\n        }\n    }\n\n    private AtomicReference<Node> tail;\n    private ThreadLocal<Node> myself = ThreadLocal.withInitial(() -> new Node());\n\n    public CLHLock() {\n        tail = new AtomicReference<>();\n    }\n\n    public void lock() {\n        Node current = myself.get();\n\n        if (current.locking) {\n            ++current.lockedCount;\n            return;\n        } else {\n            current.locking = true;\n        }\n\n        Node previous = tail.getAndSet(current);\n        while (previous != null && previous.locking) {\n            Thread.yield();\n        }\n    }\n\n    public void unlock() {\n        Node current = myself.get();\n\n        if (--current.lockedCount == 0) {\n            current.locking = false;\n            myself.remove();\n        }\n    }\n\n    static volatile int count = 0;\n\n    public static void main(String[] args) {\n        ExecutorService executorService = Executors.newFixedThreadPool(1);\n        int max = 1000000;\n        CLHLock clhLock = new CLHLock();\n\n        Stopwatch stopwatch = Stopwatch.createStarted();\n        for (int i = 0; i < max; i++) {\n            executorService.submit(() -> {\n                clhLock.lock();\n                clhLock.lock();\n\n                if (count % 100 == 0) {\n                    System.out.println(count);\n                }\n                ++count;\n\n                clhLock.unlock();\n                clhLock.unlock();\n            });\n        }\n\n        while (count != max) ;\n        executorService.shutdownNow();\n        System.out.println(\"lock is right, count: \" + count);\n        System.out.println(\"used time: \" + stopwatch.elapsed());\n    }\n}\n```\n\n# AQS\n## 原理\n1. 数据结构等待链表，使用的是尾插法\n2. Lock等方法，都是不会主动抛出`InterruptedException`的，除非调用可中断版本\n\n![AQS原理](/images/AQS.jpg)\n## 静态属性\n1. `long spinForTimeoutThreshold = 1000L`，超过此时间将会采用LockSupport.parkNanos()，而不是自旋\n\n## 成员属性\n1. `volatile Node head`，链表的头结点，傀儡节点（prev，\bthread属性都为空）\n2. `volatile Node tail`，链表的尾结点，\n3. `volatile int state`，状态变量，用于控制获取的\n\n## 主要方法\n### 可中断等待\n1. `LockSupport.park()`会从`Thread.interrupt()`中被唤醒\n2. 添加`Thread.interrupted()`检测\n\n下面的代码展示了如何实现中断的。\n```java\nprivate void doAcquireInterruptibly(int arg)\n    throws InterruptedException {\n    final Node node = addWaiter(Node.EXCLUSIVE);\n    boolean failed = true;\n    try {\n        for (;;) {\n            final Node p = node.predecessor();\n            if (p == head && tryAcquire(arg)) {\n                setHead(node);\n                p.next = null; // help GC\n                failed = false;\n                return;\n            }\n            if (shouldParkAfterFailedAcquire(p, node) && parkAndCheckInterrupt())\n                throw new InterruptedException();\n        }\n    } finally {\n        if (failed)\n            cancelAcquire(node);\n    }\n}\n```\n### Node\n1. `int waitStatus`，当前节点的等待状态\n    - SIGNAL，代表当前节点需要被\u001b唤醒\n    - CANCELLED，\b代表当前节点已经被取消\n    - CONDITION，\u001b\u001b代表当前节点在等待一个条件\n    - PROPAGATE，代表当前节点正在被多个线程同时操作，并且是shared\u001b方式获取，需要向后传播\n    - 0，代表当前节点正常，没有任何操作进行\n2. `Node prev`，前一个节点\n3. `Node next`，后一个节点\n4. `Thread thread`，等待的线程\n5. `Node nextWaiter`，\u001b下一个Condition\b链表中的节点，或者表示\b当前是否在独占模式等待\n\n### hasQueuedPredecessors\n**\b这个方法重中之重，用于判断公平性**\n```java\n// 用于判断等待链中的第一个等待线程是不是自己\npublic final boolean hasQueuedPredecessors() {\n    Node t = tail; \n    Node h = head;\n    Node s;\n    return h != t \n        && ((s = h.next) == null \n             || s.thread != Thread.currentThread());\n}\n```\n### \b\u001btryAcquire, acquire\n```java\n// 摘自于ReentrantLock的FairSync\nprotected final boolean tryAcquire(int acquires) {\n    final Thread current = Thread.currentThread();\n    int c = getState();\n\n    // 如果锁没有被加锁\n    if (c == 0) {\n        // 不存在前驱节点，并且\b成功获取了许可\n        if (!hasQueuedPredecessors() &&\n            compareAndSetState(0, acquires)) {\n            // 将当前\u001b线程设置为拥有者\n            setExclusiveOwnerThread(current);\n            return true;\n        }\n    }\n    // 如果当前线程是拥有者\n    else if (current == getExclusiveOwnerThread()) {\n        // 尝试更新拥有许可计数\n        int nextc = c + acquires;\n        if (nextc < 0)\n            throw new Error(\"Maximum lock count exceeded\");\n        setState(nextc);\n        return true;\n    }\n    return false;\n}\n\n// 检查\nprivate static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {\n    // 查看上一个节点状态\n    int ws = pred.waitStatus;\n    // 上一个节点是SIGNAL\n    if (ws == Node.SIGNAL)\n        return true;\n    // 寻找到上个\b在等待的节点，或者是已经获取锁的节点\n    if (ws > 0) {\n        do {\n            node.prev = pred = pred.prev;\n        } while (pred.waitStatus > 0);\n        pred.next = node;\n    } else {\n        // 更改上个节点状态\u001b，便于后续的判断\n        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);\n    }\n    return false;\n}\n\n// 进入阻塞，等待被唤醒\nprivate final boolean parkAndCheckInterrupt() {\n    LockSupport.park(this);\n    return Thread.interrupted();\n}\n\n// \u001b获取许可\nfinal boolean acquireQueued(final Node node, int arg) {\n    boolean failed = true;\n    try {\n        boolean interrupted = false;\n        for (;;) {\n            final Node p = node.predecessor();\n            // 当前线程是第一个等待线程，\u001b并且获取成功\n            if (p == head && tryAcquire(arg)) {\n                // 重新设置头结点\n                setHead(node);\n                p.next = null; // help GC\n                failed = false;\n                // 返回是否被中断\n                return interrupted;\n            }\n            // 需要等待（上个\u001b有效节点不是头结点)\n            // 并且尝试等待\n            if (shouldParkAfterFailedAcquire(p, node) \n                    && parkAndCheckInterrupt())\n                interrupted = true;\n        }\n    } finally {\n        // 如果异常终止，则取消当前获取\n        if (failed)\n            cancelAcquire(node);\n    }\n}\n\npublic final void acquire(int arg) {\n    // 尝试获取，不成功则进入阻塞获取阶段\n    if (!tryAcquire(arg)\n            && acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n        selfInterrupt();\n    }\n}\n\n// 唤醒链表中最前面的等待线程\nprivate void unparkSuccessor(Node node) {\n    int ws = node.waitStatus;\n    if (ws < 0)\n        compareAndSetWaitStatus(node, ws, 0);\n\n    Node s = node.next;\n    if (s == null || s.waitStatus > 0) {\n        s = null;\n        for (Node t = tail; t != null && t != node; t = t.prev)\n            if (t.waitStatus <= 0)\n                s = t;\n    }\n    if (s != null)\n        LockSupport.unpark(s.thread);\n}\n\n// 取消获取，并且设置状态\nprivate void cancelAcquire(Node node) {\n    if (node == null)\n        return;\n\n    node.thread = null;\n\n    // 跳过被取消的节点\n    Node pred = node.prev;\n    while (pred.waitStatus > 0)\n        node.prev = pred = pred.prev;\n\n    Node predNext = pred.next;\n    // 当前节点状态被设置为取消\n    node.waitStatus = Node.CANCELLED;\n\n    // 如果当前节点是尾结点\n    if (node == tail && compareAndSetTail(node, pred)) {\n        compareAndSetNext(pred, predNext, null);\n    } else {\n        int ws;\n        // 如果前面的节点不是\u001b头节点\n        // 并且在等待唤醒（SIGNAL，PROPAGATE，CONDITION），线程不为空\n        if (pred != head &&\n            ((ws = pred.waitStatus) == Node.SIGNAL \n                || (ws <= 0 && compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) \n                && pred.thread != null) {\n            Node next = node.next;\n            // 从链表中删除当前节点\n            if (next != null && next.waitStatus <= 0)\n                compareAndSetNext(pred, predNext, next);\n        } else {\n            // 直接唤醒待取消\u001b节点的下一个节点\n            unparkSuccessor(node);\n        }\n        // \u001b将当前节点脱链\n        node.next = node;\n    }\n}\n```\n### tryRelease, release\n```java\n// ReentrantLock的释放\nprotected final boolean tryRelease(int releases) {\n    int c = getState() - releases;\n    if (Thread.currentThread() != getExclusiveOwnerThread())\n        throw new IllegalMonitorStateException();\n    boolean free = false;\n    // 可重入锁的计数，计数为0，代表，已经释放所有许可\n    if (c == 0) {\n        free = true;\n        setExclusiveOwnerThread(null);\n    }\n    setState(c);\n    return free;\n}\npublic final boolean release(int arg) {\n    \u001b// 释放成功\n    if (tryRelease(arg)) {\n        Node h = head;\n        if (h != null && h.waitStatus != 0)\n            // 唤醒下一个等待线程\n            unparkSuccessor(h);\n        return true;\n    }\n    return false;\n}\n```\n### \b\u001btryAcquireShared, acquireShared\n```java\n// Semaphore的获取\nprotected int tryAcquireShared(int arg) {\n    for (; ; ) {\n        int available = getState();\n        int left = available - arg;\n\n        // \b\u001b许可不足，或者\b\b获取成功\n        if (left < 0 || compareAndSetState(available, left)) {\n            return left;\n        }\n    }\n}\n// 共享方式获取许可\npublic final void acquireShared(int arg) {\n    if (tryAcquireShared(arg) < 0)\n        // 尝试阻塞获取\n        doAcquireShared(arg);\n}\n\nprivate void setHeadAndPropagate(Node node, int propagate) {\n    Node h = head; // Record old head for check below\n    setHead(node);\n\n    // 保证传播性，如果下个节点也在等待\n    if (propagate > 0 || h == null || h.waitStatus < 0 \n            || (h = head) == null || h.waitStatus < 0) {\n        Node s = node.next;\n        // 下个节点是共享节点，唤醒下一个节点去获取许可\n        if (s == null || s.isShared())\n            doReleaseShared();\n    }\n}\n\n// 要点是获取许可成功之后，还会唤醒下一个等待线程去尝试获取\nprivate void doAcquireShared(int arg) {\n    // 把当前线程添加到等待链当中\n    final Node node = addWaiter(Node.SHARED);\n    boolean failed = true;\n    try {\n        boolean interrupted = false;\n        for (;;) {\n            final Node p = node.predecessor();\n            // 前面没有任何线程等待s\n            if (p == head) {\n                // 尝试再次获取\n                int r = tryAcquireShared(arg);\n                // 获取成功\n                if (r >= 0) {\n                    // 更新头结点，并且尝试唤醒下一个节点\n                    setHeadAndPropagate(node, r);\n                    p.next = null; // help GC\n                    if (interrupted)\n                        selfInterrupt();\n                    failed = false;\n                    return;\n                }\n            }\n            // 阻塞自己\n            if (shouldParkAfterFailedAcquire(p, node) && parkAndCheckInterrupt())\n                interrupted = true;\n        }\n    } finally {\n        if (failed)\n            cancelAcquire(node);\n    }\n}\n```\n### tryReleaseShared, releaseShared\n```java\n@Override\n// Semaphore的尝试释放\nprotected boolean tryReleaseShared(int arg) {\n    // 释放，死循环，知道陈宫\n    for (; ; ) {\n        int available = getState();\n        int left = available + arg;\n\n        if (left < 0) {\n            throw new Error(\"maximum limits get\");\n        } else if (compareAndSetState(available, left)) {\n            return true;\n        }\n    }\n}\n// \npublic final boolean releaseShared(int arg) {\n    // 尝试释放\n    if (tryReleaseShared(arg)) {\n        doReleaseShared();\n        return true;\n    }\n    return false;\n}\n\n// 唤醒下一个等待线程\nprivate void doReleaseShared() {\n    for (;;) {\n        Node h = head;\n        if (h != null && h != tail) {\n            // 头结点\n            int ws = h.waitStatus;\n            if (ws == Node.SIGNAL) {\n                // 更新头结点状态为0\n                // 这个自旋是为了保证释放的节点是需要被唤醒的节点\n                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))\n                    continue;\n                // 唤醒下一个节点，也是为了保证传播性\n                unparkSuccessor(h);\n            }\n            // 多个线程同时进行释放许可操作，继续\n            else if (ws == 0 && !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))\n                continue;\n        }\n        // 如果释放成功一个节点，\n        if (h == head) \n            break;\n    }\n}\n```\n### Condition\n如上面的图表示的，Condition内部含有一个链表下面是await和signal的简介。\n```java\npublic final void await() throws InterruptedException {\n    if (Thread.interrupted())\n        throw new InterruptedException();\n    // 加入Condition等待链表\n    Node node = addConditionWaiter();\n    int savedState = fullyRelease(node);\n    int interruptMode = 0;\n    // 当前在等待Condition\n    while (!isOnSyncQueue(node)) {\n        // 当前线程被调用signal唤醒\n        LockSupport.park(this);\n        // 当前线程被中断\n        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)\n            break;\n    }\n    // 当前线程没被中断的话，尝试以独占模式获取许可 \n    if (acquireQueued(node, savedState) && interruptMode != THROW_IE)\n        interruptMode = REINTERRUPT;\n    // 尝试删除被取消的节点\n    if (node.nextWaiter != null) // clean up if cancelled\n        unlinkCancelledWaiters();\n    // 抛出异常\n    if (interruptMode != 0)\n        reportInterruptAfterWait(interruptMode);\n}\n\n public final void signal() {\n     // 检测是否独占模式获取\n    if (!isHeldExclusively())\n        throw new IllegalMonitorStateException();\n    Node first = firstWaiter;\n    // 唤醒链表中的第一个节点（如果存在的话）\n    if (first != null)\n        doSignal(first);\n}\n\nprivate void doSignal(Node first) {\n    do {\n        if ( (firstWaiter = first.nextWaiter) == null)\n            lastWaiter = null;\n        first.nextWaiter = null;\n    } while (!transferForSignal(first) &&\n                (first = firstWaiter) != null);\n}\n\n// 将当前节点从Condition中脱链，加入到AQS的链表中（复用了一个节点）\nfinal boolean transferForSignal(Node node) {\n    // 节点已经被取消\n    if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))\n        return false;\n\n    // 将当前节点从Condition的等待队列转移到AQS的等待队列\n    Node p = enq(node);\n    int ws = p.waitStatus;\n    // 将节点状态，改成SIGNAL\n    if (ws > 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))\n        // 唤醒节点的等待线程\n        LockSupport.unpark(node.thread);\n    return true;\n}\n```\n## 调用关系\nacquire先调用tryAcquire，**不成功**，调用doAcquire()阻塞等待\nrelease先调用tryRelease，**成功了**，调用doRelease()释放下一个等待线程\n\n***\n# ReentrantLock\n内部一个Sync类，继承了AQS用于实现独占锁的功能，\u001b主要是实现了tryAcquire和tryRelease功能\n## 公平性\n由`hasQueuedPredecessors()`来保证的，如果存在前置节点，则返回尝试加锁失败\n## Sync\n```java\nprivate static final long serialVersionUID = -5179523762034025860L;\n    abstract void lock();\n\n    final boolean nonfairTryAcquire(int acquires) {\n        final Thread current = Thread.currentThread();\n        int c = getState();\n        // 还未加锁\n        if (c == 0) {\n            if (compareAndSetState(0, acquires)) {\n                setExclusiveOwnerThread(current);\n                return true;\n            }\n        }\n        // 当前线程是拥有者线程，此次是\b重入加锁\n        else if (current == getExclusiveOwnerThread()) {\n            // 多次加锁\n            int nextc = c + acquires;\n            if (nextc < 0)\n                throw new Error(\"Maximum lock count exceeded\");\n            setState(nextc);\n            return true;\n        }\n        return false;\n    }\n\n    protected final boolean tryRelease(int releases) {\n        int c = getState() - releases;\n        if (Thread.currentThread() != getExclusiveOwnerThread())\n            throw new IllegalMonitorStateException();\n        boolean free = false;\n        // 用于保证多次释放\n        if (c == 0) {\n            free = true;\n            setExclusiveOwnerThread(null);\n        }\n        setState(c);\n        return free;\n    }\n\n    final ConditionObject newCondition() {\n        return new ConditionObject();\n    }\n}\n\nstatic final class NonfairSync extends Sync {\n    final void lock() {\n        // 非公评锁，直接\b加锁（\b被唤醒的线程还未得到时间片运行，等运行时会进行再次书面）\n        if (compareAndSetState(0, 1))\n            setExclusiveOwnerThread(Thread.currentThread());\n        else\n            acquire(1);\n    }\n\n    protected final boolean tryAcquire(int acquires) {\n        return nonfairTryAcquire(acquires);\n    }\n}\n\nstatic final class FairSync extends Sync {\n    private static final long serialVersionUID = -3000897897090466540L;\n\n    final void lock() {\n        acquire(1);\n    }\n\n    protected final boolean tryAcquire(int acquires) {\n        final Thread current = Thread.currentThread();\n        int c = getState();\n        if (c == 0) {\n            // 公平性重点!!!!!!!!\n            if (!hasQueuedPredecessors() &&\n                compareAndSetState(0, acquires)) {\n                setExclusiveOwnerThread(current);\n                return true;\n            }\n        }\n        // 重复加锁\n        else if (current == getExclusiveOwnerThread()) {\n            int nextc = c + acquires;\n            if (nextc < 0)\n                throw new Error(\"Maximum lock count exceeded\");\n            setState(nextc);\n            return true;\n        }\n        return false;\n    }\n}\n```\n\n***\n# Semaphore\n基本和\bReentrantLock一样，主要实现了tryAcquiredShared()和tryReleaseShared()。\n## 公平性\n由`hasQueueProdecessors()`来决定的，如果存在前置节点就失败\n## 缺陷\n由于队列是FIFO的结构，导致了如果首元结点获取失败，则不会向后传播，下面是例子\n```java\n// 第一个线程启动后，尝试获取11个许可，但是由于获取失败，一直会阻塞。\n// 第二个启动后，由于公平性原因，获取直接失败，导致直接入队，此时如果队列头部一直获取失败的话，队列是不能有任何元素出队的。\nSemaphore semaphore = new Semaphore(10, true);\nnew Thread(() -> { semaphore.acquire(11); semaphore.release(11); }).start();\nnew Thread(() -> { semaphore.acquire(1), semaphore.release(1); }).start();\n```\n## Sync\n```java\nabstract static class Sync extends AbstractQueuedSynchronizer {\n    final int nonfairTryAcquireShared(int acquires) {\n        // 尝试去获取，不处理有线程等待的情况\n        for (;;) {\n            int available = getState();\n            int remaining = available - acquires;\n            if (remaining < 0 \n                    || compareAndSetState(available, remaining))\n                return remaining;\n        }\n    }\n\n    protected final boolean tryReleaseShared(int releases) {\n        // 利用死循环去释放，知道释放成功\n        for (;;) {\n            int current = getState();\n            int next = current + releases;\n            if (next < current) // overflow\n                throw new Error(\"Maximum permit count exceeded\");\n            if (compareAndSetState(current, next))\n                return true;\n        }\n    }\n}\n\nstatic final class NonfairSync extends Sync {\n    protected int tryAcquireShared(int acquires) {\n        return nonfairTryAcquireShared(acquires);\n    }\n}\n\nstatic final class FairSync extends Sync {\n    protected int tryAcquireShared(int acquires) {\n        for (;;) {\n            // 公平性重点\n            // \u001b已经有线程在等待，直接失败\n            if (hasQueuedPredecessors())\n                return -1;\n            int available = getState();\n            int remaining = available - acquires;\n            if (remaining < 0 ||\n                    compareAndSetState(available, remaining))\n                return remaining;\n        }\n    }\n}\n```\n\n***\n# CountDownLatch\n不可以**被重置**，并不代表技术上做不到，只是CountDownLatch就是用来用于一次性任务的，支持重置的话，可能会导致多组获取紊乱。\n## Sync\n内部使用state作为初始计数，每次获取则计数减一，到获取完后直接是释放所有线程\n```java\nprivate static final class Sync extends AbstractQueuedSynchronizer {\n    protected int tryAcquireShared(int acquires) {\n        // 这招太损了\n        // \n        return (getState() == 0) ? 1 : -1;\n    }\n\n    protected boolean tryReleaseShared(int releases) {\n        // Decrement count; signal when transition to zero\n        for (;;) {\n            int c = getState();\n            if (c == 0)\n                return false;\n            int nextc = c-1;\n            if (compareAndSetState(c, nextc))\n                return nextc == 0;\n        }\n    }\n}\n```\n\n***\n# CyclicBarrier\n## 思考：为什么不基于AQS实现\n没有办法单纯的只基于AQS就实现，**需要添加控制变量**。\n\n## 成员属性\n1. `final ReentrantLock lock = new ReentrantLock();`，用于保护await操作\n2. `final Condition trip = lock.newCondition();`用于等待被唤醒\n3. `final int parties;`最多支持的线程数量\n4. `final Runnable barrierCommand;`barrier被打破时执行的命令\n5. `Generation generation = new Generation();`代表当前barrier的状态\n6. `int count;`**没有volatile**，为什么不用volatile，count只在doAwait\b()方法内部访问，而doAwait是全程加锁的，也就是代表count的访问永远\b都是单线程的访问。\n\n## 主要方法\n### doAwait\n```java\n// 处理几种异常\n// 1. 超时\n// 2. 被中断\n// 3. 执行command时异常\nprivate int dowait(boolean timed, long nanos) throws InterruptedException, BrokenBarrierException, TimeoutException {\n    final ReentrantLock lock = this.lock;\n    lock.lock();\n    try {\n        final Generation g = generation;\n        // 如果屏障已经解除，这个照理来说不可能发生的\n        // 除非某个线程被中断了，并且唤醒了所有等待线程\n        if (g.broken)\n            throw new BrokenBarrierException();\n        if (Thread.interrupted()) {\n            breakBarrier();\n            throw new InterruptedException();\n        }\n        int index = --count;\n        // index为0，代表需要解除屏障\n        if (index == 0) {  // tripped\n            boolean ranAction = false;\n            try {\n                // 运行命令\n                final Runnable command = barrierCommand;\n                if (command != null)\n                    command.run();\n                ranAction = true;\n                // 将所有线程唤醒，并且更新generation，但是不更新count\n                nextGeneration();\n                return 0;\n            } finally {\n                // 运行command过程出错\n                if (!ranAction)\n                    breakBarrier();\n            }\n        }\n        for (;;) {\n            // 超时等待，并且处理被中断的情况\n            try {\n                if (!timed)\n                    trip.await();\n                else if (nanos > 0L)\n                    nanos = trip.awaitNanos(nanos);\n            } catch (InterruptedException ie) {\n                if (g == generation && ! g.broken) {\n                    breakBarrier();\n                    throw ie;\n                } else {\n                    Thread.currentThread().interrupt();\n                }\n            }\n\n            if (g.broken)\n                throw new BrokenBarrierException();\n\n            if (g != generation)\n                // 返回当前线程的等待序号\n                return index;\n\n            if (timed && nanos <= 0L) {\n                breakBarrier();\n                throw new TimeoutException();\n            }\n        }\n    } finally {\n        lock.unlock();\n    }\n}\n```\n\n### reset\n```java\n// 构建新的屏障\nprivate void nextGeneration() {\n    trip.signalAll();\n    count = parties;\n    generation = new Generation();\n}\n\n// 清除当前屏障\nprivate void breakBarrier() {\n    generation.broken = true;\n    count = parties;\n    trip.signalAll();\n}\n\npublic void reset() {\n    final ReentrantLock lock = this.lock;\n    lock.lock();\n    try {\n        breakBarrier();\n        nextGeneration();\n    } finally {\n        lock.unlock();\n    }\n}\n```\n\n\n# ReadWriteLock\n内部原理是state状态变量的低16位代表写锁数量，高16位代表读锁数量。\n`ReadLock.lock()`调用`tryAcquireShared`\n`WriteLock.lock()`调用`tryAcquire`\n## 写锁降级\n原理是先获取读锁（直接获取会成功），释放写锁（同时虽然会唤醒头等待线程，但是没有用，获取不到）\n## 读锁升级\n直接加写锁呗","slug":"AQS分析","published":1,"updated":"2018-06-26T15:07:04.916Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5u1tui00011av8ntuhsfkz","content":"<h1 id=\"CLH队列\"><a href=\"#CLH队列\" class=\"headerlink\" title=\"CLH队列\"></a>CLH队列</h1><h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p><img src=\"/images/CLH.jpg\" height=\"80%\" width=\"60%\"><br><a id=\"more\"></a></p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CLHLock</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Data</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">boolean</span> locking;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> lockedCount;</span><br><span class=\"line\"></span><br><span class=\"line\">        Node() &#123;</span><br><span class=\"line\">            lockedCount = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> AtomicReference&lt;Node&gt; tail;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ThreadLocal&lt;Node&gt; myself = ThreadLocal.withInitial(() -&gt; <span class=\"keyword\">new</span> Node());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CLHLock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        tail = <span class=\"keyword\">new</span> AtomicReference&lt;&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Node current = myself.get();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (current.locking) &#123;</span><br><span class=\"line\">            ++current.lockedCount;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            current.locking = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Node previous = tail.getAndSet(current);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (previous != <span class=\"keyword\">null</span> &amp;&amp; previous.locking) &#123;</span><br><span class=\"line\">            Thread.yield();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">unlock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Node current = myself.get();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (--current.lockedCount == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            current.locking = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            myself.remove();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        ExecutorService executorService = Executors.newFixedThreadPool(<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> max = <span class=\"number\">1000000</span>;</span><br><span class=\"line\">        CLHLock clhLock = <span class=\"keyword\">new</span> CLHLock();</span><br><span class=\"line\"></span><br><span class=\"line\">        Stopwatch stopwatch = Stopwatch.createStarted();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; max; i++) &#123;</span><br><span class=\"line\">            executorService.submit(() -&gt; &#123;</span><br><span class=\"line\">                clhLock.lock();</span><br><span class=\"line\">                clhLock.lock();</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (count % <span class=\"number\">100</span> == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    System.out.println(count);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                ++count;</span><br><span class=\"line\"></span><br><span class=\"line\">                clhLock.unlock();</span><br><span class=\"line\">                clhLock.unlock();</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (count != max) ;</span><br><span class=\"line\">        executorService.shutdownNow();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"lock is right, count: \"</span> + count);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"used time: \"</span> + stopwatch.elapsed());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"AQS\"><a href=\"#AQS\" class=\"headerlink\" title=\"AQS\"></a>AQS</h1><h2 id=\"原理-1\"><a href=\"#原理-1\" class=\"headerlink\" title=\"原理\"></a>原理</h2><ol>\n<li>数据结构等待链表，使用的是尾插法</li>\n<li>Lock等方法，都是不会主动抛出<code>InterruptedException</code>的，除非调用可中断版本</li>\n</ol>\n<p><img src=\"/images/AQS.jpg\" alt=\"AQS原理\"></p>\n<h2 id=\"静态属性\"><a href=\"#静态属性\" class=\"headerlink\" title=\"静态属性\"></a>静态属性</h2><ol>\n<li><code>long spinForTimeoutThreshold = 1000L</code>，超过此时间将会采用LockSupport.parkNanos()，而不是自旋</li>\n</ol>\n<h2 id=\"成员属性\"><a href=\"#成员属性\" class=\"headerlink\" title=\"成员属性\"></a>成员属性</h2><ol>\n<li><code>volatile Node head</code>，链表的头结点，傀儡节点（prev，\bthread属性都为空）</li>\n<li><code>volatile Node tail</code>，链表的尾结点，</li>\n<li><code>volatile int state</code>，状态变量，用于控制获取的</li>\n</ol>\n<h2 id=\"主要方法\"><a href=\"#主要方法\" class=\"headerlink\" title=\"主要方法\"></a>主要方法</h2><h3 id=\"可中断等待\"><a href=\"#可中断等待\" class=\"headerlink\" title=\"可中断等待\"></a>可中断等待</h3><ol>\n<li><code>LockSupport.park()</code>会从<code>Thread.interrupt()</code>中被唤醒</li>\n<li>添加<code>Thread.interrupted()</code>检测</li>\n</ol>\n<p>下面的代码展示了如何实现中断的。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">doAcquireInterruptibly</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> failed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> Node p = node.predecessor();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class=\"line\">                setHead(node);</span><br><span class=\"line\">                p.next = <span class=\"keyword\">null</span>; <span class=\"comment\">// help GC</span></span><br><span class=\"line\">                failed = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InterruptedException();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (failed)</span><br><span class=\"line\">            cancelAcquire(node);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Node\"><a href=\"#Node\" class=\"headerlink\" title=\"Node\"></a>Node</h3><ol>\n<li><code>int waitStatus</code>，当前节点的等待状态<ul>\n<li>SIGNAL，代表当前节点需要被\u001b唤醒</li>\n<li>CANCELLED，\b代表当前节点已经被取消</li>\n<li>CONDITION，\u001b\u001b代表当前节点在等待一个条件</li>\n<li>PROPAGATE，代表当前节点正在被多个线程同时操作，并且是shared\u001b方式获取，需要向后传播</li>\n<li>0，代表当前节点正常，没有任何操作进行</li>\n</ul>\n</li>\n<li><code>Node prev</code>，前一个节点</li>\n<li><code>Node next</code>，后一个节点</li>\n<li><code>Thread thread</code>，等待的线程</li>\n<li><code>Node nextWaiter</code>，\u001b下一个Condition\b链表中的节点，或者表示\b当前是否在独占模式等待</li>\n</ol>\n<h3 id=\"hasQueuedPredecessors\"><a href=\"#hasQueuedPredecessors\" class=\"headerlink\" title=\"hasQueuedPredecessors\"></a>hasQueuedPredecessors</h3><p><strong>\b这个方法重中之重，用于判断公平性</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 用于判断等待链中的第一个等待线程是不是自己</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasQueuedPredecessors</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Node t = tail; </span><br><span class=\"line\">    Node h = head;</span><br><span class=\"line\">    Node s;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> h != t </span><br><span class=\"line\">        &amp;&amp; ((s = h.next) == <span class=\"keyword\">null</span> </span><br><span class=\"line\">             || s.thread != Thread.currentThread());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"tryAcquire-acquire\"><a href=\"#tryAcquire-acquire\" class=\"headerlink\" title=\"\b\u001btryAcquire, acquire\"></a>\b\u001btryAcquire, acquire</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 摘自于ReentrantLock的FairSync</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Thread current = Thread.currentThread();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = getState();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果锁没有被加锁</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 不存在前驱节点，并且\b成功获取了许可</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class=\"line\">            compareAndSetState(<span class=\"number\">0</span>, acquires)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 将当前\u001b线程设置为拥有者</span></span><br><span class=\"line\">            setExclusiveOwnerThread(current);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 如果当前线程是拥有者</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 尝试更新拥有许可计数</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> nextc = c + acquires;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextc &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(<span class=\"string\">\"Maximum lock count exceeded\"</span>);</span><br><span class=\"line\">        setState(nextc);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 检查</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">shouldParkAfterFailedAcquire</span><span class=\"params\">(Node pred, Node node)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 查看上一个节点状态</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> ws = pred.waitStatus;</span><br><span class=\"line\">    <span class=\"comment\">// 上一个节点是SIGNAL</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ws == Node.SIGNAL)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 寻找到上个\b在等待的节点，或者是已经获取锁的节点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ws &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">            node.prev = pred = pred.prev;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">while</span> (pred.waitStatus &gt; <span class=\"number\">0</span>);</span><br><span class=\"line\">        pred.next = node;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 更改上个节点状态\u001b，便于后续的判断</span></span><br><span class=\"line\">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 进入阻塞，等待被唤醒</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">parkAndCheckInterrupt</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    LockSupport.park(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Thread.interrupted();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// \u001b获取许可</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">acquireQueued</span><span class=\"params\">(<span class=\"keyword\">final</span> Node node, <span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> failed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> interrupted = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> Node p = node.predecessor();</span><br><span class=\"line\">            <span class=\"comment\">// 当前线程是第一个等待线程，\u001b并且获取成功</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 重新设置头结点</span></span><br><span class=\"line\">                setHead(node);</span><br><span class=\"line\">                p.next = <span class=\"keyword\">null</span>; <span class=\"comment\">// help GC</span></span><br><span class=\"line\">                failed = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                <span class=\"comment\">// 返回是否被中断</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> interrupted;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 需要等待（上个\u001b有效节点不是头结点)</span></span><br><span class=\"line\">            <span class=\"comment\">// 并且尝试等待</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (shouldParkAfterFailedAcquire(p, node) </span><br><span class=\"line\">                    &amp;&amp; parkAndCheckInterrupt())</span><br><span class=\"line\">                interrupted = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果异常终止，则取消当前获取</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (failed)</span><br><span class=\"line\">            cancelAcquire(node);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">acquire</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 尝试获取，不成功则进入阻塞获取阶段</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tryAcquire(arg)</span><br><span class=\"line\">            &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class=\"line\">        selfInterrupt();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 唤醒链表中最前面的等待线程</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">unparkSuccessor</span><span class=\"params\">(Node node)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ws = node.waitStatus;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ws &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        compareAndSetWaitStatus(node, ws, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    Node s = node.next;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s == <span class=\"keyword\">null</span> || s.waitStatus &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        s = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Node t = tail; t != <span class=\"keyword\">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (t.waitStatus &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">                s = t;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        LockSupport.unpark(s.thread);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 取消获取，并且设置状态</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">cancelAcquire</span><span class=\"params\">(Node node)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    node.thread = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 跳过被取消的节点</span></span><br><span class=\"line\">    Node pred = node.prev;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (pred.waitStatus &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        node.prev = pred = pred.prev;</span><br><span class=\"line\"></span><br><span class=\"line\">    Node predNext = pred.next;</span><br><span class=\"line\">    <span class=\"comment\">// 当前节点状态被设置为取消</span></span><br><span class=\"line\">    node.waitStatus = Node.CANCELLED;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果当前节点是尾结点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class=\"line\">        compareAndSetNext(pred, predNext, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ws;</span><br><span class=\"line\">        <span class=\"comment\">// 如果前面的节点不是\u001b头节点</span></span><br><span class=\"line\">        <span class=\"comment\">// 并且在等待唤醒（SIGNAL，PROPAGATE，CONDITION），线程不为空</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pred != head &amp;&amp;</span><br><span class=\"line\">            ((ws = pred.waitStatus) == Node.SIGNAL </span><br><span class=\"line\">                || (ws &lt;= <span class=\"number\">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) </span><br><span class=\"line\">                &amp;&amp; pred.thread != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            Node next = node.next;</span><br><span class=\"line\">            <span class=\"comment\">// 从链表中删除当前节点</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (next != <span class=\"keyword\">null</span> &amp;&amp; next.waitStatus &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">                compareAndSetNext(pred, predNext, next);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 直接唤醒待取消\u001b节点的下一个节点</span></span><br><span class=\"line\">            unparkSuccessor(node);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// \u001b将当前节点脱链</span></span><br><span class=\"line\">        node.next = node;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"tryRelease-release\"><a href=\"#tryRelease-release\" class=\"headerlink\" title=\"tryRelease, release\"></a>tryRelease, release</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ReentrantLock的释放</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryRelease</span><span class=\"params\">(<span class=\"keyword\">int</span> releases)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = getState() - releases;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalMonitorStateException();</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> free = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 可重入锁的计数，计数为0，代表，已经释放所有许可</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        free = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        setExclusiveOwnerThread(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    setState(c);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> free;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">release</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    \u001b<span class=\"comment\">// 释放成功</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tryRelease(arg)) &#123;</span><br><span class=\"line\">        Node h = head;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (h != <span class=\"keyword\">null</span> &amp;&amp; h.waitStatus != <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"comment\">// 唤醒下一个等待线程</span></span><br><span class=\"line\">            unparkSuccessor(h);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"tryAcquireShared-acquireShared\"><a href=\"#tryAcquireShared-acquireShared\" class=\"headerlink\" title=\"\b\u001btryAcquireShared, acquireShared\"></a>\b\u001btryAcquireShared, acquireShared</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Semaphore的获取</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> <span class=\"title\">tryAcquireShared</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (; ; ) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> available = getState();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = available - arg;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// \b\u001b许可不足，或者\b\b获取成功</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left &lt; <span class=\"number\">0</span> || compareAndSetState(available, left)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 共享方式获取许可</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">acquireShared</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tryAcquireShared(arg) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"comment\">// 尝试阻塞获取</span></span><br><span class=\"line\">        doAcquireShared(arg);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">setHeadAndPropagate</span><span class=\"params\">(Node node, <span class=\"keyword\">int</span> propagate)</span> </span>&#123;</span><br><span class=\"line\">    Node h = head; <span class=\"comment\">// Record old head for check below</span></span><br><span class=\"line\">    setHead(node);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 保证传播性，如果下个节点也在等待</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (propagate &gt; <span class=\"number\">0</span> || h == <span class=\"keyword\">null</span> || h.waitStatus &lt; <span class=\"number\">0</span> </span><br><span class=\"line\">            || (h = head) == <span class=\"keyword\">null</span> || h.waitStatus &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        Node s = node.next;</span><br><span class=\"line\">        <span class=\"comment\">// 下个节点是共享节点，唤醒下一个节点去获取许可</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s == <span class=\"keyword\">null</span> || s.isShared())</span><br><span class=\"line\">            doReleaseShared();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 要点是获取许可成功之后，还会唤醒下一个等待线程去尝试获取</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">doAcquireShared</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 把当前线程添加到等待链当中</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> failed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> interrupted = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> Node p = node.predecessor();</span><br><span class=\"line\">            <span class=\"comment\">// 前面没有任何线程等待s</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p == head) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 尝试再次获取</span></span><br><span class=\"line\">                <span class=\"keyword\">int</span> r = tryAcquireShared(arg);</span><br><span class=\"line\">                <span class=\"comment\">// 获取成功</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (r &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 更新头结点，并且尝试唤醒下一个节点</span></span><br><span class=\"line\">                    setHeadAndPropagate(node, r);</span><br><span class=\"line\">                    p.next = <span class=\"keyword\">null</span>; <span class=\"comment\">// help GC</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (interrupted)</span><br><span class=\"line\">                        selfInterrupt();</span><br><span class=\"line\">                    failed = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 阻塞自己</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class=\"line\">                interrupted = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (failed)</span><br><span class=\"line\">            cancelAcquire(node);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"tryReleaseShared-releaseShared\"><a href=\"#tryReleaseShared-releaseShared\" class=\"headerlink\" title=\"tryReleaseShared, releaseShared\"></a>tryReleaseShared, releaseShared</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"comment\">// Semaphore的尝试释放</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryReleaseShared</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 释放，死循环，知道陈宫</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (; ; ) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> available = getState();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = available + arg;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(<span class=\"string\">\"maximum limits get\"</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (compareAndSetState(available, left)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">releaseShared</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 尝试释放</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class=\"line\">        doReleaseShared();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 唤醒下一个等待线程</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">doReleaseShared</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        Node h = head;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (h != <span class=\"keyword\">null</span> &amp;&amp; h != tail) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 头结点</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> ws = h.waitStatus;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 更新头结点状态为0</span></span><br><span class=\"line\">                <span class=\"comment\">// 这个自旋是为了保证释放的节点是需要被唤醒的节点</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class=\"number\">0</span>))</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                <span class=\"comment\">// 唤醒下一个节点，也是为了保证传播性</span></span><br><span class=\"line\">                unparkSuccessor(h);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 多个线程同时进行释放许可操作，继续</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ws == <span class=\"number\">0</span> &amp;&amp; !compareAndSetWaitStatus(h, <span class=\"number\">0</span>, Node.PROPAGATE))</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 如果释放成功一个节点，</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (h == head) </span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Condition\"><a href=\"#Condition\" class=\"headerlink\" title=\"Condition\"></a>Condition</h3><p>如上面的图表示的，Condition内部含有一个链表下面是await和signal的简介。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">await</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Thread.interrupted())</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InterruptedException();</span><br><span class=\"line\">    <span class=\"comment\">// 加入Condition等待链表</span></span><br><span class=\"line\">    Node node = addConditionWaiter();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> savedState = fullyRelease(node);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> interruptMode = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 当前在等待Condition</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 当前线程被调用signal唤醒</span></span><br><span class=\"line\">        LockSupport.park(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 当前线程被中断</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 当前线程没被中断的话，尝试以独占模式获取许可 </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class=\"line\">        interruptMode = REINTERRUPT;</span><br><span class=\"line\">    <span class=\"comment\">// 尝试删除被取消的节点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.nextWaiter != <span class=\"keyword\">null</span>) <span class=\"comment\">// clean up if cancelled</span></span><br><span class=\"line\">        unlinkCancelledWaiters();</span><br><span class=\"line\">    <span class=\"comment\">// 抛出异常</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (interruptMode != <span class=\"number\">0</span>)</span><br><span class=\"line\">        reportInterruptAfterWait(interruptMode);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">signal</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"comment\">// 检测是否独占模式获取</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isHeldExclusively())</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalMonitorStateException();</span><br><span class=\"line\">    Node first = firstWaiter;</span><br><span class=\"line\">    <span class=\"comment\">// 唤醒链表中的第一个节点（如果存在的话）</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (first != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        doSignal(first);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">doSignal</span><span class=\"params\">(Node first)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( (firstWaiter = first.nextWaiter) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            lastWaiter = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        first.nextWaiter = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class=\"line\">                (first = firstWaiter) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将当前节点从Condition中脱链，加入到AQS的链表中（复用了一个节点）</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">transferForSignal</span><span class=\"params\">(Node node)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 节点已经被取消</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class=\"number\">0</span>))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将当前节点从Condition的等待队列转移到AQS的等待队列</span></span><br><span class=\"line\">    Node p = enq(node);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ws = p.waitStatus;</span><br><span class=\"line\">    <span class=\"comment\">// 将节点状态，改成SIGNAL</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ws &gt; <span class=\"number\">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class=\"line\">        <span class=\"comment\">// 唤醒节点的等待线程</span></span><br><span class=\"line\">        LockSupport.unpark(node.thread);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"调用关系\"><a href=\"#调用关系\" class=\"headerlink\" title=\"调用关系\"></a>调用关系</h2><p>acquire先调用tryAcquire，<strong>不成功</strong>，调用doAcquire()阻塞等待<br>release先调用tryRelease，<strong>成功了</strong>，调用doRelease()释放下一个等待线程</p>\n<hr>\n<h1 id=\"ReentrantLock\"><a href=\"#ReentrantLock\" class=\"headerlink\" title=\"ReentrantLock\"></a>ReentrantLock</h1><p>内部一个Sync类，继承了AQS用于实现独占锁的功能，\u001b主要是实现了tryAcquire和tryRelease功能</p>\n<h2 id=\"公平性\"><a href=\"#公平性\" class=\"headerlink\" title=\"公平性\"></a>公平性</h2><p>由<code>hasQueuedPredecessors()</code>来保证的，如果存在前置节点，则返回尝试加锁失败</p>\n<h2 id=\"Sync\"><a href=\"#Sync\" class=\"headerlink\" title=\"Sync\"></a>Sync</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = -<span class=\"number\">5179523762034025860L</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">nonfairTryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Thread current = Thread.currentThread();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> c = getState();</span><br><span class=\"line\">        <span class=\"comment\">// 还未加锁</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (compareAndSetState(<span class=\"number\">0</span>, acquires)) &#123;</span><br><span class=\"line\">                setExclusiveOwnerThread(current);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 当前线程是拥有者线程，此次是\b重入加锁</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 多次加锁</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> nextc = c + acquires;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nextc &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(<span class=\"string\">\"Maximum lock count exceeded\"</span>);</span><br><span class=\"line\">            setState(nextc);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryRelease</span><span class=\"params\">(<span class=\"keyword\">int</span> releases)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> c = getState() - releases;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalMonitorStateException();</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> free = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 用于保证多次释放</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            free = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            setExclusiveOwnerThread(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        setState(c);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> free;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> ConditionObject <span class=\"title\">newCondition</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ConditionObject();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NonfairSync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Sync</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 非公评锁，直接\b加锁（\b被唤醒的线程还未得到时间片运行，等运行时会进行再次书面）</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (compareAndSetState(<span class=\"number\">0</span>, <span class=\"number\">1</span>))</span><br><span class=\"line\">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            acquire(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nonfairTryAcquire(acquires);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FairSync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Sync</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = -<span class=\"number\">3000897897090466540L</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        acquire(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Thread current = Thread.currentThread();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> c = getState();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 公平性重点!!!!!!!!</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class=\"line\">                compareAndSetState(<span class=\"number\">0</span>, acquires)) &#123;</span><br><span class=\"line\">                setExclusiveOwnerThread(current);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 重复加锁</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> nextc = c + acquires;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nextc &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(<span class=\"string\">\"Maximum lock count exceeded\"</span>);</span><br><span class=\"line\">            setState(nextc);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"Semaphore\"><a href=\"#Semaphore\" class=\"headerlink\" title=\"Semaphore\"></a>Semaphore</h1><p>基本和\bReentrantLock一样，主要实现了tryAcquiredShared()和tryReleaseShared()。</p>\n<h2 id=\"公平性-1\"><a href=\"#公平性-1\" class=\"headerlink\" title=\"公平性\"></a>公平性</h2><p>由<code>hasQueueProdecessors()</code>来决定的，如果存在前置节点就失败</p>\n<h2 id=\"缺陷\"><a href=\"#缺陷\" class=\"headerlink\" title=\"缺陷\"></a>缺陷</h2><p>由于队列是FIFO的结构，导致了如果首元结点获取失败，则不会向后传播，下面是例子<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 第一个线程启动后，尝试获取11个许可，但是由于获取失败，一直会阻塞。</span></span><br><span class=\"line\"><span class=\"comment\">// 第二个启动后，由于公平性原因，获取直接失败，导致直接入队，此时如果队列头部一直获取失败的话，队列是不能有任何元素出队的。</span></span><br><span class=\"line\">Semaphore semaphore = <span class=\"keyword\">new</span> Semaphore(<span class=\"number\">10</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread(() -&gt; &#123; semaphore.acquire(<span class=\"number\">11</span>); semaphore.release(<span class=\"number\">11</span>); &#125;).start();</span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread(() -&gt; &#123; semaphore.acquire(<span class=\"number\">1</span>), semaphore.release(<span class=\"number\">1</span>); &#125;).start();</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Sync-1\"><a href=\"#Sync-1\" class=\"headerlink\" title=\"Sync\"></a>Sync</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">nonfairTryAcquireShared</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 尝试去获取，不处理有线程等待的情况</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> available = getState();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> remaining = available - acquires;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (remaining &lt; <span class=\"number\">0</span> </span><br><span class=\"line\">                    || compareAndSetState(available, remaining))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> remaining;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryReleaseShared</span><span class=\"params\">(<span class=\"keyword\">int</span> releases)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 利用死循环去释放，知道释放成功</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> current = getState();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> next = current + releases;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (next &lt; current) <span class=\"comment\">// overflow</span></span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(<span class=\"string\">\"Maximum permit count exceeded\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (compareAndSetState(current, next))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NonfairSync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Sync</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> <span class=\"title\">tryAcquireShared</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nonfairTryAcquireShared(acquires);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FairSync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Sync</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> <span class=\"title\">tryAcquireShared</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 公平性重点</span></span><br><span class=\"line\">            <span class=\"comment\">// \u001b已经有线程在等待，直接失败</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (hasQueuedPredecessors())</span><br><span class=\"line\">                <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> available = getState();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> remaining = available - acquires;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (remaining &lt; <span class=\"number\">0</span> ||</span><br><span class=\"line\">                    compareAndSetState(available, remaining))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> remaining;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"CountDownLatch\"><a href=\"#CountDownLatch\" class=\"headerlink\" title=\"CountDownLatch\"></a>CountDownLatch</h1><p>不可以<strong>被重置</strong>，并不代表技术上做不到，只是CountDownLatch就是用来用于一次性任务的，支持重置的话，可能会导致多组获取紊乱。</p>\n<h2 id=\"Sync-2\"><a href=\"#Sync-2\" class=\"headerlink\" title=\"Sync\"></a>Sync</h2><p>内部使用state作为初始计数，每次获取则计数减一，到获取完后直接是释放所有线程<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> <span class=\"title\">tryAcquireShared</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 这招太损了</span></span><br><span class=\"line\">        <span class=\"comment\">// </span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> (getState() == <span class=\"number\">0</span>) ? <span class=\"number\">1</span> : -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryReleaseShared</span><span class=\"params\">(<span class=\"keyword\">int</span> releases)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// Decrement count; signal when transition to zero</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> c = getState();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> nextc = c-<span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (compareAndSetState(c, nextc))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> nextc == <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h1 id=\"CyclicBarrier\"><a href=\"#CyclicBarrier\" class=\"headerlink\" title=\"CyclicBarrier\"></a>CyclicBarrier</h1><h2 id=\"思考：为什么不基于AQS实现\"><a href=\"#思考：为什么不基于AQS实现\" class=\"headerlink\" title=\"思考：为什么不基于AQS实现\"></a>思考：为什么不基于AQS实现</h2><p>没有办法单纯的只基于AQS就实现，<strong>需要添加控制变量</strong>。</p>\n<h2 id=\"成员属性-1\"><a href=\"#成员属性-1\" class=\"headerlink\" title=\"成员属性\"></a>成员属性</h2><ol>\n<li><code>final ReentrantLock lock = new ReentrantLock();</code>，用于保护await操作</li>\n<li><code>final Condition trip = lock.newCondition();</code>用于等待被唤醒</li>\n<li><code>final int parties;</code>最多支持的线程数量</li>\n<li><code>final Runnable barrierCommand;</code>barrier被打破时执行的命令</li>\n<li><code>Generation generation = new Generation();</code>代表当前barrier的状态</li>\n<li><code>int count;</code><strong>没有volatile</strong>，为什么不用volatile，count只在doAwait\b()方法内部访问，而doAwait是全程加锁的，也就是代表count的访问永远\b都是单线程的访问。</li>\n</ol>\n<h2 id=\"主要方法-1\"><a href=\"#主要方法-1\" class=\"headerlink\" title=\"主要方法\"></a>主要方法</h2><h3 id=\"doAwait\"><a href=\"#doAwait\" class=\"headerlink\" title=\"doAwait\"></a>doAwait</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 处理几种异常</span></span><br><span class=\"line\"><span class=\"comment\">// 1. 超时</span></span><br><span class=\"line\"><span class=\"comment\">// 2. 被中断</span></span><br><span class=\"line\"><span class=\"comment\">// 3. 执行command时异常</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">dowait</span><span class=\"params\">(<span class=\"keyword\">boolean</span> timed, <span class=\"keyword\">long</span> nanos)</span> <span class=\"keyword\">throws</span> InterruptedException, BrokenBarrierException, TimeoutException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ReentrantLock lock = <span class=\"keyword\">this</span>.lock;</span><br><span class=\"line\">    lock.lock();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Generation g = generation;</span><br><span class=\"line\">        <span class=\"comment\">// 如果屏障已经解除，这个照理来说不可能发生的</span></span><br><span class=\"line\">        <span class=\"comment\">// 除非某个线程被中断了，并且唤醒了所有等待线程</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (g.broken)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> BrokenBarrierException();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Thread.interrupted()) &#123;</span><br><span class=\"line\">            breakBarrier();</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InterruptedException();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = --count;</span><br><span class=\"line\">        <span class=\"comment\">// index为0，代表需要解除屏障</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index == <span class=\"number\">0</span>) &#123;  <span class=\"comment\">// tripped</span></span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> ranAction = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 运行命令</span></span><br><span class=\"line\">                <span class=\"keyword\">final</span> Runnable command = barrierCommand;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (command != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    command.run();</span><br><span class=\"line\">                ranAction = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                <span class=\"comment\">// 将所有线程唤醒，并且更新generation，但是不更新count</span></span><br><span class=\"line\">                nextGeneration();</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 运行command过程出错</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!ranAction)</span><br><span class=\"line\">                    breakBarrier();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 超时等待，并且处理被中断的情况</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!timed)</span><br><span class=\"line\">                    trip.await();</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nanos &gt; <span class=\"number\">0L</span>)</span><br><span class=\"line\">                    nanos = trip.awaitNanos(nanos);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException ie) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class=\"line\">                    breakBarrier();</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> ie;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    Thread.currentThread().interrupt();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (g.broken)</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> BrokenBarrierException();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (g != generation)</span><br><span class=\"line\">                <span class=\"comment\">// 返回当前线程的等待序号</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> index;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (timed &amp;&amp; nanos &lt;= <span class=\"number\">0L</span>) &#123;</span><br><span class=\"line\">                breakBarrier();</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> TimeoutException();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"reset\"><a href=\"#reset\" class=\"headerlink\" title=\"reset\"></a>reset</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 构建新的屏障</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">nextGeneration</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    trip.signalAll();</span><br><span class=\"line\">    count = parties;</span><br><span class=\"line\">    generation = <span class=\"keyword\">new</span> Generation();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 清除当前屏障</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">breakBarrier</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    generation.broken = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    count = parties;</span><br><span class=\"line\">    trip.signalAll();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">reset</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ReentrantLock lock = <span class=\"keyword\">this</span>.lock;</span><br><span class=\"line\">    lock.lock();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        breakBarrier();</span><br><span class=\"line\">        nextGeneration();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"ReadWriteLock\"><a href=\"#ReadWriteLock\" class=\"headerlink\" title=\"ReadWriteLock\"></a>ReadWriteLock</h1><p>内部原理是state状态变量的低16位代表写锁数量，高16位代表读锁数量。<br><code>ReadLock.lock()</code>调用<code>tryAcquireShared</code><br><code>WriteLock.lock()</code>调用<code>tryAcquire</code></p>\n<h2 id=\"写锁降级\"><a href=\"#写锁降级\" class=\"headerlink\" title=\"写锁降级\"></a>写锁降级</h2><p>原理是先获取读锁（直接获取会成功），释放写锁（同时虽然会唤醒头等待线程，但是没有用，获取不到）</p>\n<h2 id=\"读锁升级\"><a href=\"#读锁升级\" class=\"headerlink\" title=\"读锁升级\"></a>读锁升级</h2><p>直接加写锁呗</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"CLH队列\"><a href=\"#CLH队列\" class=\"headerlink\" title=\"CLH队列\"></a>CLH队列</h1><h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p><img src=\"/images/CLH.jpg\" height=\"80%\" width=\"60%\"><br>","more":"</p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CLHLock</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Data</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">boolean</span> locking;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> lockedCount;</span><br><span class=\"line\"></span><br><span class=\"line\">        Node() &#123;</span><br><span class=\"line\">            lockedCount = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> AtomicReference&lt;Node&gt; tail;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ThreadLocal&lt;Node&gt; myself = ThreadLocal.withInitial(() -&gt; <span class=\"keyword\">new</span> Node());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CLHLock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        tail = <span class=\"keyword\">new</span> AtomicReference&lt;&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Node current = myself.get();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (current.locking) &#123;</span><br><span class=\"line\">            ++current.lockedCount;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            current.locking = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Node previous = tail.getAndSet(current);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (previous != <span class=\"keyword\">null</span> &amp;&amp; previous.locking) &#123;</span><br><span class=\"line\">            Thread.yield();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">unlock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Node current = myself.get();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (--current.lockedCount == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            current.locking = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            myself.remove();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        ExecutorService executorService = Executors.newFixedThreadPool(<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> max = <span class=\"number\">1000000</span>;</span><br><span class=\"line\">        CLHLock clhLock = <span class=\"keyword\">new</span> CLHLock();</span><br><span class=\"line\"></span><br><span class=\"line\">        Stopwatch stopwatch = Stopwatch.createStarted();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; max; i++) &#123;</span><br><span class=\"line\">            executorService.submit(() -&gt; &#123;</span><br><span class=\"line\">                clhLock.lock();</span><br><span class=\"line\">                clhLock.lock();</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (count % <span class=\"number\">100</span> == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    System.out.println(count);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                ++count;</span><br><span class=\"line\"></span><br><span class=\"line\">                clhLock.unlock();</span><br><span class=\"line\">                clhLock.unlock();</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (count != max) ;</span><br><span class=\"line\">        executorService.shutdownNow();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"lock is right, count: \"</span> + count);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"used time: \"</span> + stopwatch.elapsed());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"AQS\"><a href=\"#AQS\" class=\"headerlink\" title=\"AQS\"></a>AQS</h1><h2 id=\"原理-1\"><a href=\"#原理-1\" class=\"headerlink\" title=\"原理\"></a>原理</h2><ol>\n<li>数据结构等待链表，使用的是尾插法</li>\n<li>Lock等方法，都是不会主动抛出<code>InterruptedException</code>的，除非调用可中断版本</li>\n</ol>\n<p><img src=\"/images/AQS.jpg\" alt=\"AQS原理\"></p>\n<h2 id=\"静态属性\"><a href=\"#静态属性\" class=\"headerlink\" title=\"静态属性\"></a>静态属性</h2><ol>\n<li><code>long spinForTimeoutThreshold = 1000L</code>，超过此时间将会采用LockSupport.parkNanos()，而不是自旋</li>\n</ol>\n<h2 id=\"成员属性\"><a href=\"#成员属性\" class=\"headerlink\" title=\"成员属性\"></a>成员属性</h2><ol>\n<li><code>volatile Node head</code>，链表的头结点，傀儡节点（prev，\bthread属性都为空）</li>\n<li><code>volatile Node tail</code>，链表的尾结点，</li>\n<li><code>volatile int state</code>，状态变量，用于控制获取的</li>\n</ol>\n<h2 id=\"主要方法\"><a href=\"#主要方法\" class=\"headerlink\" title=\"主要方法\"></a>主要方法</h2><h3 id=\"可中断等待\"><a href=\"#可中断等待\" class=\"headerlink\" title=\"可中断等待\"></a>可中断等待</h3><ol>\n<li><code>LockSupport.park()</code>会从<code>Thread.interrupt()</code>中被唤醒</li>\n<li>添加<code>Thread.interrupted()</code>检测</li>\n</ol>\n<p>下面的代码展示了如何实现中断的。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">doAcquireInterruptibly</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> failed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> Node p = node.predecessor();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class=\"line\">                setHead(node);</span><br><span class=\"line\">                p.next = <span class=\"keyword\">null</span>; <span class=\"comment\">// help GC</span></span><br><span class=\"line\">                failed = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InterruptedException();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (failed)</span><br><span class=\"line\">            cancelAcquire(node);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Node\"><a href=\"#Node\" class=\"headerlink\" title=\"Node\"></a>Node</h3><ol>\n<li><code>int waitStatus</code>，当前节点的等待状态<ul>\n<li>SIGNAL，代表当前节点需要被\u001b唤醒</li>\n<li>CANCELLED，\b代表当前节点已经被取消</li>\n<li>CONDITION，\u001b\u001b代表当前节点在等待一个条件</li>\n<li>PROPAGATE，代表当前节点正在被多个线程同时操作，并且是shared\u001b方式获取，需要向后传播</li>\n<li>0，代表当前节点正常，没有任何操作进行</li>\n</ul>\n</li>\n<li><code>Node prev</code>，前一个节点</li>\n<li><code>Node next</code>，后一个节点</li>\n<li><code>Thread thread</code>，等待的线程</li>\n<li><code>Node nextWaiter</code>，\u001b下一个Condition\b链表中的节点，或者表示\b当前是否在独占模式等待</li>\n</ol>\n<h3 id=\"hasQueuedPredecessors\"><a href=\"#hasQueuedPredecessors\" class=\"headerlink\" title=\"hasQueuedPredecessors\"></a>hasQueuedPredecessors</h3><p><strong>\b这个方法重中之重，用于判断公平性</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 用于判断等待链中的第一个等待线程是不是自己</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasQueuedPredecessors</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Node t = tail; </span><br><span class=\"line\">    Node h = head;</span><br><span class=\"line\">    Node s;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> h != t </span><br><span class=\"line\">        &amp;&amp; ((s = h.next) == <span class=\"keyword\">null</span> </span><br><span class=\"line\">             || s.thread != Thread.currentThread());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"tryAcquire-acquire\"><a href=\"#tryAcquire-acquire\" class=\"headerlink\" title=\"\b\u001btryAcquire, acquire\"></a>\b\u001btryAcquire, acquire</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 摘自于ReentrantLock的FairSync</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Thread current = Thread.currentThread();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = getState();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果锁没有被加锁</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 不存在前驱节点，并且\b成功获取了许可</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class=\"line\">            compareAndSetState(<span class=\"number\">0</span>, acquires)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 将当前\u001b线程设置为拥有者</span></span><br><span class=\"line\">            setExclusiveOwnerThread(current);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 如果当前线程是拥有者</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 尝试更新拥有许可计数</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> nextc = c + acquires;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextc &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(<span class=\"string\">\"Maximum lock count exceeded\"</span>);</span><br><span class=\"line\">        setState(nextc);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 检查</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">shouldParkAfterFailedAcquire</span><span class=\"params\">(Node pred, Node node)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 查看上一个节点状态</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> ws = pred.waitStatus;</span><br><span class=\"line\">    <span class=\"comment\">// 上一个节点是SIGNAL</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ws == Node.SIGNAL)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 寻找到上个\b在等待的节点，或者是已经获取锁的节点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ws &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">            node.prev = pred = pred.prev;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">while</span> (pred.waitStatus &gt; <span class=\"number\">0</span>);</span><br><span class=\"line\">        pred.next = node;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 更改上个节点状态\u001b，便于后续的判断</span></span><br><span class=\"line\">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 进入阻塞，等待被唤醒</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">parkAndCheckInterrupt</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    LockSupport.park(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Thread.interrupted();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// \u001b获取许可</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">acquireQueued</span><span class=\"params\">(<span class=\"keyword\">final</span> Node node, <span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> failed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> interrupted = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> Node p = node.predecessor();</span><br><span class=\"line\">            <span class=\"comment\">// 当前线程是第一个等待线程，\u001b并且获取成功</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 重新设置头结点</span></span><br><span class=\"line\">                setHead(node);</span><br><span class=\"line\">                p.next = <span class=\"keyword\">null</span>; <span class=\"comment\">// help GC</span></span><br><span class=\"line\">                failed = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                <span class=\"comment\">// 返回是否被中断</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> interrupted;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 需要等待（上个\u001b有效节点不是头结点)</span></span><br><span class=\"line\">            <span class=\"comment\">// 并且尝试等待</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (shouldParkAfterFailedAcquire(p, node) </span><br><span class=\"line\">                    &amp;&amp; parkAndCheckInterrupt())</span><br><span class=\"line\">                interrupted = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果异常终止，则取消当前获取</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (failed)</span><br><span class=\"line\">            cancelAcquire(node);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">acquire</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 尝试获取，不成功则进入阻塞获取阶段</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tryAcquire(arg)</span><br><span class=\"line\">            &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class=\"line\">        selfInterrupt();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 唤醒链表中最前面的等待线程</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">unparkSuccessor</span><span class=\"params\">(Node node)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ws = node.waitStatus;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ws &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        compareAndSetWaitStatus(node, ws, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    Node s = node.next;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s == <span class=\"keyword\">null</span> || s.waitStatus &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        s = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Node t = tail; t != <span class=\"keyword\">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (t.waitStatus &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">                s = t;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        LockSupport.unpark(s.thread);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 取消获取，并且设置状态</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">cancelAcquire</span><span class=\"params\">(Node node)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    node.thread = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 跳过被取消的节点</span></span><br><span class=\"line\">    Node pred = node.prev;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (pred.waitStatus &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        node.prev = pred = pred.prev;</span><br><span class=\"line\"></span><br><span class=\"line\">    Node predNext = pred.next;</span><br><span class=\"line\">    <span class=\"comment\">// 当前节点状态被设置为取消</span></span><br><span class=\"line\">    node.waitStatus = Node.CANCELLED;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果当前节点是尾结点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class=\"line\">        compareAndSetNext(pred, predNext, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ws;</span><br><span class=\"line\">        <span class=\"comment\">// 如果前面的节点不是\u001b头节点</span></span><br><span class=\"line\">        <span class=\"comment\">// 并且在等待唤醒（SIGNAL，PROPAGATE，CONDITION），线程不为空</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pred != head &amp;&amp;</span><br><span class=\"line\">            ((ws = pred.waitStatus) == Node.SIGNAL </span><br><span class=\"line\">                || (ws &lt;= <span class=\"number\">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) </span><br><span class=\"line\">                &amp;&amp; pred.thread != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            Node next = node.next;</span><br><span class=\"line\">            <span class=\"comment\">// 从链表中删除当前节点</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (next != <span class=\"keyword\">null</span> &amp;&amp; next.waitStatus &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">                compareAndSetNext(pred, predNext, next);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 直接唤醒待取消\u001b节点的下一个节点</span></span><br><span class=\"line\">            unparkSuccessor(node);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// \u001b将当前节点脱链</span></span><br><span class=\"line\">        node.next = node;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"tryRelease-release\"><a href=\"#tryRelease-release\" class=\"headerlink\" title=\"tryRelease, release\"></a>tryRelease, release</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ReentrantLock的释放</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryRelease</span><span class=\"params\">(<span class=\"keyword\">int</span> releases)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = getState() - releases;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalMonitorStateException();</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> free = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 可重入锁的计数，计数为0，代表，已经释放所有许可</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        free = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        setExclusiveOwnerThread(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    setState(c);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> free;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">release</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    \u001b<span class=\"comment\">// 释放成功</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tryRelease(arg)) &#123;</span><br><span class=\"line\">        Node h = head;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (h != <span class=\"keyword\">null</span> &amp;&amp; h.waitStatus != <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"comment\">// 唤醒下一个等待线程</span></span><br><span class=\"line\">            unparkSuccessor(h);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"tryAcquireShared-acquireShared\"><a href=\"#tryAcquireShared-acquireShared\" class=\"headerlink\" title=\"\b\u001btryAcquireShared, acquireShared\"></a>\b\u001btryAcquireShared, acquireShared</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Semaphore的获取</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> <span class=\"title\">tryAcquireShared</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (; ; ) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> available = getState();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = available - arg;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// \b\u001b许可不足，或者\b\b获取成功</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left &lt; <span class=\"number\">0</span> || compareAndSetState(available, left)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 共享方式获取许可</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">acquireShared</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tryAcquireShared(arg) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"comment\">// 尝试阻塞获取</span></span><br><span class=\"line\">        doAcquireShared(arg);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">setHeadAndPropagate</span><span class=\"params\">(Node node, <span class=\"keyword\">int</span> propagate)</span> </span>&#123;</span><br><span class=\"line\">    Node h = head; <span class=\"comment\">// Record old head for check below</span></span><br><span class=\"line\">    setHead(node);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 保证传播性，如果下个节点也在等待</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (propagate &gt; <span class=\"number\">0</span> || h == <span class=\"keyword\">null</span> || h.waitStatus &lt; <span class=\"number\">0</span> </span><br><span class=\"line\">            || (h = head) == <span class=\"keyword\">null</span> || h.waitStatus &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        Node s = node.next;</span><br><span class=\"line\">        <span class=\"comment\">// 下个节点是共享节点，唤醒下一个节点去获取许可</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s == <span class=\"keyword\">null</span> || s.isShared())</span><br><span class=\"line\">            doReleaseShared();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 要点是获取许可成功之后，还会唤醒下一个等待线程去尝试获取</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">doAcquireShared</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 把当前线程添加到等待链当中</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> failed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> interrupted = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> Node p = node.predecessor();</span><br><span class=\"line\">            <span class=\"comment\">// 前面没有任何线程等待s</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p == head) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 尝试再次获取</span></span><br><span class=\"line\">                <span class=\"keyword\">int</span> r = tryAcquireShared(arg);</span><br><span class=\"line\">                <span class=\"comment\">// 获取成功</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (r &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 更新头结点，并且尝试唤醒下一个节点</span></span><br><span class=\"line\">                    setHeadAndPropagate(node, r);</span><br><span class=\"line\">                    p.next = <span class=\"keyword\">null</span>; <span class=\"comment\">// help GC</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (interrupted)</span><br><span class=\"line\">                        selfInterrupt();</span><br><span class=\"line\">                    failed = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 阻塞自己</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class=\"line\">                interrupted = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (failed)</span><br><span class=\"line\">            cancelAcquire(node);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"tryReleaseShared-releaseShared\"><a href=\"#tryReleaseShared-releaseShared\" class=\"headerlink\" title=\"tryReleaseShared, releaseShared\"></a>tryReleaseShared, releaseShared</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"comment\">// Semaphore的尝试释放</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryReleaseShared</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 释放，死循环，知道陈宫</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (; ; ) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> available = getState();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = available + arg;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(<span class=\"string\">\"maximum limits get\"</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (compareAndSetState(available, left)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">releaseShared</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 尝试释放</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class=\"line\">        doReleaseShared();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 唤醒下一个等待线程</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">doReleaseShared</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        Node h = head;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (h != <span class=\"keyword\">null</span> &amp;&amp; h != tail) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 头结点</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> ws = h.waitStatus;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 更新头结点状态为0</span></span><br><span class=\"line\">                <span class=\"comment\">// 这个自旋是为了保证释放的节点是需要被唤醒的节点</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class=\"number\">0</span>))</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                <span class=\"comment\">// 唤醒下一个节点，也是为了保证传播性</span></span><br><span class=\"line\">                unparkSuccessor(h);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 多个线程同时进行释放许可操作，继续</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ws == <span class=\"number\">0</span> &amp;&amp; !compareAndSetWaitStatus(h, <span class=\"number\">0</span>, Node.PROPAGATE))</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 如果释放成功一个节点，</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (h == head) </span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Condition\"><a href=\"#Condition\" class=\"headerlink\" title=\"Condition\"></a>Condition</h3><p>如上面的图表示的，Condition内部含有一个链表下面是await和signal的简介。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">await</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Thread.interrupted())</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InterruptedException();</span><br><span class=\"line\">    <span class=\"comment\">// 加入Condition等待链表</span></span><br><span class=\"line\">    Node node = addConditionWaiter();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> savedState = fullyRelease(node);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> interruptMode = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 当前在等待Condition</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 当前线程被调用signal唤醒</span></span><br><span class=\"line\">        LockSupport.park(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 当前线程被中断</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 当前线程没被中断的话，尝试以独占模式获取许可 </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class=\"line\">        interruptMode = REINTERRUPT;</span><br><span class=\"line\">    <span class=\"comment\">// 尝试删除被取消的节点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.nextWaiter != <span class=\"keyword\">null</span>) <span class=\"comment\">// clean up if cancelled</span></span><br><span class=\"line\">        unlinkCancelledWaiters();</span><br><span class=\"line\">    <span class=\"comment\">// 抛出异常</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (interruptMode != <span class=\"number\">0</span>)</span><br><span class=\"line\">        reportInterruptAfterWait(interruptMode);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">signal</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"comment\">// 检测是否独占模式获取</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isHeldExclusively())</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalMonitorStateException();</span><br><span class=\"line\">    Node first = firstWaiter;</span><br><span class=\"line\">    <span class=\"comment\">// 唤醒链表中的第一个节点（如果存在的话）</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (first != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        doSignal(first);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">doSignal</span><span class=\"params\">(Node first)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( (firstWaiter = first.nextWaiter) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            lastWaiter = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        first.nextWaiter = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class=\"line\">                (first = firstWaiter) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将当前节点从Condition中脱链，加入到AQS的链表中（复用了一个节点）</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">transferForSignal</span><span class=\"params\">(Node node)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 节点已经被取消</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class=\"number\">0</span>))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将当前节点从Condition的等待队列转移到AQS的等待队列</span></span><br><span class=\"line\">    Node p = enq(node);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ws = p.waitStatus;</span><br><span class=\"line\">    <span class=\"comment\">// 将节点状态，改成SIGNAL</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ws &gt; <span class=\"number\">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class=\"line\">        <span class=\"comment\">// 唤醒节点的等待线程</span></span><br><span class=\"line\">        LockSupport.unpark(node.thread);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"调用关系\"><a href=\"#调用关系\" class=\"headerlink\" title=\"调用关系\"></a>调用关系</h2><p>acquire先调用tryAcquire，<strong>不成功</strong>，调用doAcquire()阻塞等待<br>release先调用tryRelease，<strong>成功了</strong>，调用doRelease()释放下一个等待线程</p>\n<hr>\n<h1 id=\"ReentrantLock\"><a href=\"#ReentrantLock\" class=\"headerlink\" title=\"ReentrantLock\"></a>ReentrantLock</h1><p>内部一个Sync类，继承了AQS用于实现独占锁的功能，\u001b主要是实现了tryAcquire和tryRelease功能</p>\n<h2 id=\"公平性\"><a href=\"#公平性\" class=\"headerlink\" title=\"公平性\"></a>公平性</h2><p>由<code>hasQueuedPredecessors()</code>来保证的，如果存在前置节点，则返回尝试加锁失败</p>\n<h2 id=\"Sync\"><a href=\"#Sync\" class=\"headerlink\" title=\"Sync\"></a>Sync</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = -<span class=\"number\">5179523762034025860L</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">nonfairTryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Thread current = Thread.currentThread();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> c = getState();</span><br><span class=\"line\">        <span class=\"comment\">// 还未加锁</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (compareAndSetState(<span class=\"number\">0</span>, acquires)) &#123;</span><br><span class=\"line\">                setExclusiveOwnerThread(current);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 当前线程是拥有者线程，此次是\b重入加锁</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 多次加锁</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> nextc = c + acquires;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nextc &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(<span class=\"string\">\"Maximum lock count exceeded\"</span>);</span><br><span class=\"line\">            setState(nextc);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryRelease</span><span class=\"params\">(<span class=\"keyword\">int</span> releases)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> c = getState() - releases;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalMonitorStateException();</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> free = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 用于保证多次释放</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            free = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            setExclusiveOwnerThread(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        setState(c);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> free;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> ConditionObject <span class=\"title\">newCondition</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ConditionObject();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NonfairSync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Sync</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 非公评锁，直接\b加锁（\b被唤醒的线程还未得到时间片运行，等运行时会进行再次书面）</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (compareAndSetState(<span class=\"number\">0</span>, <span class=\"number\">1</span>))</span><br><span class=\"line\">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            acquire(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nonfairTryAcquire(acquires);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FairSync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Sync</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = -<span class=\"number\">3000897897090466540L</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        acquire(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Thread current = Thread.currentThread();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> c = getState();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 公平性重点!!!!!!!!</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class=\"line\">                compareAndSetState(<span class=\"number\">0</span>, acquires)) &#123;</span><br><span class=\"line\">                setExclusiveOwnerThread(current);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 重复加锁</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> nextc = c + acquires;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nextc &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(<span class=\"string\">\"Maximum lock count exceeded\"</span>);</span><br><span class=\"line\">            setState(nextc);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"Semaphore\"><a href=\"#Semaphore\" class=\"headerlink\" title=\"Semaphore\"></a>Semaphore</h1><p>基本和\bReentrantLock一样，主要实现了tryAcquiredShared()和tryReleaseShared()。</p>\n<h2 id=\"公平性-1\"><a href=\"#公平性-1\" class=\"headerlink\" title=\"公平性\"></a>公平性</h2><p>由<code>hasQueueProdecessors()</code>来决定的，如果存在前置节点就失败</p>\n<h2 id=\"缺陷\"><a href=\"#缺陷\" class=\"headerlink\" title=\"缺陷\"></a>缺陷</h2><p>由于队列是FIFO的结构，导致了如果首元结点获取失败，则不会向后传播，下面是例子<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 第一个线程启动后，尝试获取11个许可，但是由于获取失败，一直会阻塞。</span></span><br><span class=\"line\"><span class=\"comment\">// 第二个启动后，由于公平性原因，获取直接失败，导致直接入队，此时如果队列头部一直获取失败的话，队列是不能有任何元素出队的。</span></span><br><span class=\"line\">Semaphore semaphore = <span class=\"keyword\">new</span> Semaphore(<span class=\"number\">10</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread(() -&gt; &#123; semaphore.acquire(<span class=\"number\">11</span>); semaphore.release(<span class=\"number\">11</span>); &#125;).start();</span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread(() -&gt; &#123; semaphore.acquire(<span class=\"number\">1</span>), semaphore.release(<span class=\"number\">1</span>); &#125;).start();</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Sync-1\"><a href=\"#Sync-1\" class=\"headerlink\" title=\"Sync\"></a>Sync</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">nonfairTryAcquireShared</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 尝试去获取，不处理有线程等待的情况</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> available = getState();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> remaining = available - acquires;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (remaining &lt; <span class=\"number\">0</span> </span><br><span class=\"line\">                    || compareAndSetState(available, remaining))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> remaining;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryReleaseShared</span><span class=\"params\">(<span class=\"keyword\">int</span> releases)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 利用死循环去释放，知道释放成功</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> current = getState();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> next = current + releases;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (next &lt; current) <span class=\"comment\">// overflow</span></span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(<span class=\"string\">\"Maximum permit count exceeded\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (compareAndSetState(current, next))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NonfairSync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Sync</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> <span class=\"title\">tryAcquireShared</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nonfairTryAcquireShared(acquires);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FairSync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Sync</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> <span class=\"title\">tryAcquireShared</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 公平性重点</span></span><br><span class=\"line\">            <span class=\"comment\">// \u001b已经有线程在等待，直接失败</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (hasQueuedPredecessors())</span><br><span class=\"line\">                <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> available = getState();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> remaining = available - acquires;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (remaining &lt; <span class=\"number\">0</span> ||</span><br><span class=\"line\">                    compareAndSetState(available, remaining))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> remaining;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"CountDownLatch\"><a href=\"#CountDownLatch\" class=\"headerlink\" title=\"CountDownLatch\"></a>CountDownLatch</h1><p>不可以<strong>被重置</strong>，并不代表技术上做不到，只是CountDownLatch就是用来用于一次性任务的，支持重置的话，可能会导致多组获取紊乱。</p>\n<h2 id=\"Sync-2\"><a href=\"#Sync-2\" class=\"headerlink\" title=\"Sync\"></a>Sync</h2><p>内部使用state作为初始计数，每次获取则计数减一，到获取完后直接是释放所有线程<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> <span class=\"title\">tryAcquireShared</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 这招太损了</span></span><br><span class=\"line\">        <span class=\"comment\">// </span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> (getState() == <span class=\"number\">0</span>) ? <span class=\"number\">1</span> : -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryReleaseShared</span><span class=\"params\">(<span class=\"keyword\">int</span> releases)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// Decrement count; signal when transition to zero</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> c = getState();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> nextc = c-<span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (compareAndSetState(c, nextc))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> nextc == <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h1 id=\"CyclicBarrier\"><a href=\"#CyclicBarrier\" class=\"headerlink\" title=\"CyclicBarrier\"></a>CyclicBarrier</h1><h2 id=\"思考：为什么不基于AQS实现\"><a href=\"#思考：为什么不基于AQS实现\" class=\"headerlink\" title=\"思考：为什么不基于AQS实现\"></a>思考：为什么不基于AQS实现</h2><p>没有办法单纯的只基于AQS就实现，<strong>需要添加控制变量</strong>。</p>\n<h2 id=\"成员属性-1\"><a href=\"#成员属性-1\" class=\"headerlink\" title=\"成员属性\"></a>成员属性</h2><ol>\n<li><code>final ReentrantLock lock = new ReentrantLock();</code>，用于保护await操作</li>\n<li><code>final Condition trip = lock.newCondition();</code>用于等待被唤醒</li>\n<li><code>final int parties;</code>最多支持的线程数量</li>\n<li><code>final Runnable barrierCommand;</code>barrier被打破时执行的命令</li>\n<li><code>Generation generation = new Generation();</code>代表当前barrier的状态</li>\n<li><code>int count;</code><strong>没有volatile</strong>，为什么不用volatile，count只在doAwait\b()方法内部访问，而doAwait是全程加锁的，也就是代表count的访问永远\b都是单线程的访问。</li>\n</ol>\n<h2 id=\"主要方法-1\"><a href=\"#主要方法-1\" class=\"headerlink\" title=\"主要方法\"></a>主要方法</h2><h3 id=\"doAwait\"><a href=\"#doAwait\" class=\"headerlink\" title=\"doAwait\"></a>doAwait</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 处理几种异常</span></span><br><span class=\"line\"><span class=\"comment\">// 1. 超时</span></span><br><span class=\"line\"><span class=\"comment\">// 2. 被中断</span></span><br><span class=\"line\"><span class=\"comment\">// 3. 执行command时异常</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">dowait</span><span class=\"params\">(<span class=\"keyword\">boolean</span> timed, <span class=\"keyword\">long</span> nanos)</span> <span class=\"keyword\">throws</span> InterruptedException, BrokenBarrierException, TimeoutException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ReentrantLock lock = <span class=\"keyword\">this</span>.lock;</span><br><span class=\"line\">    lock.lock();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Generation g = generation;</span><br><span class=\"line\">        <span class=\"comment\">// 如果屏障已经解除，这个照理来说不可能发生的</span></span><br><span class=\"line\">        <span class=\"comment\">// 除非某个线程被中断了，并且唤醒了所有等待线程</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (g.broken)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> BrokenBarrierException();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Thread.interrupted()) &#123;</span><br><span class=\"line\">            breakBarrier();</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InterruptedException();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = --count;</span><br><span class=\"line\">        <span class=\"comment\">// index为0，代表需要解除屏障</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index == <span class=\"number\">0</span>) &#123;  <span class=\"comment\">// tripped</span></span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> ranAction = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 运行命令</span></span><br><span class=\"line\">                <span class=\"keyword\">final</span> Runnable command = barrierCommand;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (command != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    command.run();</span><br><span class=\"line\">                ranAction = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                <span class=\"comment\">// 将所有线程唤醒，并且更新generation，但是不更新count</span></span><br><span class=\"line\">                nextGeneration();</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 运行command过程出错</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!ranAction)</span><br><span class=\"line\">                    breakBarrier();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 超时等待，并且处理被中断的情况</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!timed)</span><br><span class=\"line\">                    trip.await();</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nanos &gt; <span class=\"number\">0L</span>)</span><br><span class=\"line\">                    nanos = trip.awaitNanos(nanos);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException ie) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class=\"line\">                    breakBarrier();</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> ie;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    Thread.currentThread().interrupt();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (g.broken)</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> BrokenBarrierException();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (g != generation)</span><br><span class=\"line\">                <span class=\"comment\">// 返回当前线程的等待序号</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> index;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (timed &amp;&amp; nanos &lt;= <span class=\"number\">0L</span>) &#123;</span><br><span class=\"line\">                breakBarrier();</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> TimeoutException();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"reset\"><a href=\"#reset\" class=\"headerlink\" title=\"reset\"></a>reset</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 构建新的屏障</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">nextGeneration</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    trip.signalAll();</span><br><span class=\"line\">    count = parties;</span><br><span class=\"line\">    generation = <span class=\"keyword\">new</span> Generation();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 清除当前屏障</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">breakBarrier</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    generation.broken = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    count = parties;</span><br><span class=\"line\">    trip.signalAll();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">reset</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ReentrantLock lock = <span class=\"keyword\">this</span>.lock;</span><br><span class=\"line\">    lock.lock();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        breakBarrier();</span><br><span class=\"line\">        nextGeneration();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"ReadWriteLock\"><a href=\"#ReadWriteLock\" class=\"headerlink\" title=\"ReadWriteLock\"></a>ReadWriteLock</h1><p>内部原理是state状态变量的低16位代表写锁数量，高16位代表读锁数量。<br><code>ReadLock.lock()</code>调用<code>tryAcquireShared</code><br><code>WriteLock.lock()</code>调用<code>tryAcquire</code></p>\n<h2 id=\"写锁降级\"><a href=\"#写锁降级\" class=\"headerlink\" title=\"写锁降级\"></a>写锁降级</h2><p>原理是先获取读锁（直接获取会成功），释放写锁（同时虽然会唤醒头等待线程，但是没有用，获取不到）</p>\n<h2 id=\"读锁升级\"><a href=\"#读锁升级\" class=\"headerlink\" title=\"读锁升级\"></a>读锁升级</h2><p>直接加写锁呗</p>"},{"title":"DTS功能构思","date":"2018-06-26T11:03:37.000Z","_content":"\n## 介绍\n是将要做的一个开源项目，全称是distributed task scheduler(分布式任务调度器)。\n原型是[xxl-job](https://github.com/xuxueli/xxl-job)。\n\n## 功能点\n以下是需要做的修改点。\n1. 高性能\n    - 合并对单个客户端的分发（较少网络IO消耗），考虑是否采用客户端pull的方式进行任务的消费\n    - 多机联合分发（充分利用多机，单个任务的分发能够支持由多个机器联合）\n    - 任务状态上报优化，减少上报次数\n    - jetty短连接优化（netty）\n2. 高可用\n    - BASE原理，任务状态\n    - 任务调度失败补偿\n    - 任务丢失补偿\n    - 子任务触发补偿\n    - 子任务状态上报\n3. 重构\n    - 调度层抽象（以后可能提供多种调度引擎，quartz）\n    - 通信层抽象（可能不使用netty，使用tomcat，或者netty）\n    - 包结构优化（分为server，client，core，starter，example）\n    - 代码内容优化，类结构更合理\n4. 数据库优化\n    - 分库分表sharding-jdbc，分布式关系型数据库tiDB\n    - 表结构优化，减少冗余数据\n5. 功能\n    - 失败处理策略，执行失败告警，执行失败重试\n    - 支持尝试停止任务（可以能通过自定义线程池以及`Thread.stop()`实现）\n    - 日志页面优化（JobLog和TaskLog查询）\n\n## 高可用\n1. quartz高可用\n    - requireRecovery\n    - misfireFireAndProceeding\n2. BASE\n    - 任务状态(未调度，调度成功，调度失败，执行中，等待中，完成)\n    - 状态上报\n    - 状态监测","source":"_posts/DTS功能构思.md","raw":"---\ntitle: DTS功能构思\ndate: 2018-06-26 19:03:37\ntags:\n- 中间件\n- 开源\ncategories:\n- 中间件\n---\n\n## 介绍\n是将要做的一个开源项目，全称是distributed task scheduler(分布式任务调度器)。\n原型是[xxl-job](https://github.com/xuxueli/xxl-job)。\n\n## 功能点\n以下是需要做的修改点。\n1. 高性能\n    - 合并对单个客户端的分发（较少网络IO消耗），考虑是否采用客户端pull的方式进行任务的消费\n    - 多机联合分发（充分利用多机，单个任务的分发能够支持由多个机器联合）\n    - 任务状态上报优化，减少上报次数\n    - jetty短连接优化（netty）\n2. 高可用\n    - BASE原理，任务状态\n    - 任务调度失败补偿\n    - 任务丢失补偿\n    - 子任务触发补偿\n    - 子任务状态上报\n3. 重构\n    - 调度层抽象（以后可能提供多种调度引擎，quartz）\n    - 通信层抽象（可能不使用netty，使用tomcat，或者netty）\n    - 包结构优化（分为server，client，core，starter，example）\n    - 代码内容优化，类结构更合理\n4. 数据库优化\n    - 分库分表sharding-jdbc，分布式关系型数据库tiDB\n    - 表结构优化，减少冗余数据\n5. 功能\n    - 失败处理策略，执行失败告警，执行失败重试\n    - 支持尝试停止任务（可以能通过自定义线程池以及`Thread.stop()`实现）\n    - 日志页面优化（JobLog和TaskLog查询）\n\n## 高可用\n1. quartz高可用\n    - requireRecovery\n    - misfireFireAndProceeding\n2. BASE\n    - 任务状态(未调度，调度成功，调度失败，执行中，等待中，完成)\n    - 状态上报\n    - 状态监测","slug":"DTS功能构思","published":1,"updated":"2018-07-01T07:37:30.017Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5u1tun00041av8wg3mkdgx","content":"<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>是将要做的一个开源项目，全称是distributed task scheduler(分布式任务调度器)。<br>原型是<a href=\"https://github.com/xuxueli/xxl-job\" target=\"_blank\" rel=\"noopener\">xxl-job</a>。</p>\n<h2 id=\"功能点\"><a href=\"#功能点\" class=\"headerlink\" title=\"功能点\"></a>功能点</h2><p>以下是需要做的修改点。</p>\n<ol>\n<li>高性能<ul>\n<li>合并对单个客户端的分发（较少网络IO消耗），考虑是否采用客户端pull的方式进行任务的消费</li>\n<li>多机联合分发（充分利用多机，单个任务的分发能够支持由多个机器联合）</li>\n<li>任务状态上报优化，减少上报次数</li>\n<li>jetty短连接优化（netty）</li>\n</ul>\n</li>\n<li>高可用<ul>\n<li>BASE原理，任务状态</li>\n<li>任务调度失败补偿</li>\n<li>任务丢失补偿</li>\n<li>子任务触发补偿</li>\n<li>子任务状态上报</li>\n</ul>\n</li>\n<li>重构<ul>\n<li>调度层抽象（以后可能提供多种调度引擎，quartz）</li>\n<li>通信层抽象（可能不使用netty，使用tomcat，或者netty）</li>\n<li>包结构优化（分为server，client，core，starter，example）</li>\n<li>代码内容优化，类结构更合理</li>\n</ul>\n</li>\n<li>数据库优化<ul>\n<li>分库分表sharding-jdbc，分布式关系型数据库tiDB</li>\n<li>表结构优化，减少冗余数据</li>\n</ul>\n</li>\n<li>功能<ul>\n<li>失败处理策略，执行失败告警，执行失败重试</li>\n<li>支持尝试停止任务（可以能通过自定义线程池以及<code>Thread.stop()</code>实现）</li>\n<li>日志页面优化（JobLog和TaskLog查询）</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"高可用\"><a href=\"#高可用\" class=\"headerlink\" title=\"高可用\"></a>高可用</h2><ol>\n<li>quartz高可用<ul>\n<li>requireRecovery</li>\n<li>misfireFireAndProceeding</li>\n</ul>\n</li>\n<li>BASE<ul>\n<li>任务状态(未调度，调度成功，调度失败，执行中，等待中，完成)</li>\n<li>状态上报</li>\n<li>状态监测</li>\n</ul>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>是将要做的一个开源项目，全称是distributed task scheduler(分布式任务调度器)。<br>原型是<a href=\"https://github.com/xuxueli/xxl-job\" target=\"_blank\" rel=\"noopener\">xxl-job</a>。</p>\n<h2 id=\"功能点\"><a href=\"#功能点\" class=\"headerlink\" title=\"功能点\"></a>功能点</h2><p>以下是需要做的修改点。</p>\n<ol>\n<li>高性能<ul>\n<li>合并对单个客户端的分发（较少网络IO消耗），考虑是否采用客户端pull的方式进行任务的消费</li>\n<li>多机联合分发（充分利用多机，单个任务的分发能够支持由多个机器联合）</li>\n<li>任务状态上报优化，减少上报次数</li>\n<li>jetty短连接优化（netty）</li>\n</ul>\n</li>\n<li>高可用<ul>\n<li>BASE原理，任务状态</li>\n<li>任务调度失败补偿</li>\n<li>任务丢失补偿</li>\n<li>子任务触发补偿</li>\n<li>子任务状态上报</li>\n</ul>\n</li>\n<li>重构<ul>\n<li>调度层抽象（以后可能提供多种调度引擎，quartz）</li>\n<li>通信层抽象（可能不使用netty，使用tomcat，或者netty）</li>\n<li>包结构优化（分为server，client，core，starter，example）</li>\n<li>代码内容优化，类结构更合理</li>\n</ul>\n</li>\n<li>数据库优化<ul>\n<li>分库分表sharding-jdbc，分布式关系型数据库tiDB</li>\n<li>表结构优化，减少冗余数据</li>\n</ul>\n</li>\n<li>功能<ul>\n<li>失败处理策略，执行失败告警，执行失败重试</li>\n<li>支持尝试停止任务（可以能通过自定义线程池以及<code>Thread.stop()</code>实现）</li>\n<li>日志页面优化（JobLog和TaskLog查询）</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"高可用\"><a href=\"#高可用\" class=\"headerlink\" title=\"高可用\"></a>高可用</h2><ol>\n<li>quartz高可用<ul>\n<li>requireRecovery</li>\n<li>misfireFireAndProceeding</li>\n</ul>\n</li>\n<li>BASE<ul>\n<li>任务状态(未调度，调度成功，调度失败，执行中，等待中，完成)</li>\n<li>状态上报</li>\n<li>状态监测</li>\n</ul>\n</li>\n</ol>\n"},{"title":"DTS技术调研前言","date":"2018-06-28T13:33:23.000Z","_content":"# quartz\n对现有方式做单机性能测试，下面是相关测试结果：\n- mysql，单秒100个任务（主要是数据库锁加锁过程比较慢）\n- redis，单秒150个任务（开源代码，实现不是很好，主要表现为，不稳定，连接池经常耗尽，并且可能会遭遇任务数据丢失场景）\n- ram，每秒1500个任务\n\n总结下来可能还是会继续使用mysql做quartz的持久化，但是会针对性的做一些性能优化。\n比如以下场景：\n1. 加锁方式上，可能不再采用数据库锁，采用redis或者zk来实现分布式锁\n2. 加锁粒度上，减小锁的粒度，从而减少锁的占用时间，提高吞吐量\n<!-- more -->\n\n# 数据库\n数据库优化打算采用以下两种方式：\n- tidb，分布式关系型数据库，成规模部署性能比较高，单机部署性能比较差。\n- mysql分库分表，两库共四表，用于减轻数据库锁的压力\n\n为什么最后采用分库分表？\n1. 没有好的分布式关系型数据库支撑，tidb开源版本体验不够好，资料不是很多，本地测试一堆问题。\n2. 架构层面分库分表更简单，对硬件没有什么特殊要求，只是要求多用几个库表。\n\n# 架构\n1. 引入分发层\n    1. 单机，默认分发方式，可用性更高（不依赖其他外部存储），单个任务的分发时间会更短\n    2. redis多机，通过配置redis自动生效，总体分发性能更高，\n    3. 自动模式，根据任务数量，自动选择分发模式\n2. 引入通信层\n    1. jetty，现有通信方式，通信损耗较高\n    2. netty，改进方式，使用长连接\n3. 引入调度层\n    1. 解耦quartz，减少对quartz的依赖\n    2. 方便后续对quartz以及去quartz改造\n4. 引入redis\n    1. 任务多机分发，将任务放入redis队列中，然后消费队列数据（需要处理redis宕机场景，走单机分发或者补偿逻辑）\n    2. 加快quartz的加锁机制，数据库加锁较慢","source":"_posts/DTS技术调研前言.md","raw":"---\ntitle: DTS技术调研前言\ndate: 2018-06-28 21:33:23\ntags:\n- 中间件\n- 开源\ncategories:\n- 开源\n---\n# quartz\n对现有方式做单机性能测试，下面是相关测试结果：\n- mysql，单秒100个任务（主要是数据库锁加锁过程比较慢）\n- redis，单秒150个任务（开源代码，实现不是很好，主要表现为，不稳定，连接池经常耗尽，并且可能会遭遇任务数据丢失场景）\n- ram，每秒1500个任务\n\n总结下来可能还是会继续使用mysql做quartz的持久化，但是会针对性的做一些性能优化。\n比如以下场景：\n1. 加锁方式上，可能不再采用数据库锁，采用redis或者zk来实现分布式锁\n2. 加锁粒度上，减小锁的粒度，从而减少锁的占用时间，提高吞吐量\n<!-- more -->\n\n# 数据库\n数据库优化打算采用以下两种方式：\n- tidb，分布式关系型数据库，成规模部署性能比较高，单机部署性能比较差。\n- mysql分库分表，两库共四表，用于减轻数据库锁的压力\n\n为什么最后采用分库分表？\n1. 没有好的分布式关系型数据库支撑，tidb开源版本体验不够好，资料不是很多，本地测试一堆问题。\n2. 架构层面分库分表更简单，对硬件没有什么特殊要求，只是要求多用几个库表。\n\n# 架构\n1. 引入分发层\n    1. 单机，默认分发方式，可用性更高（不依赖其他外部存储），单个任务的分发时间会更短\n    2. redis多机，通过配置redis自动生效，总体分发性能更高，\n    3. 自动模式，根据任务数量，自动选择分发模式\n2. 引入通信层\n    1. jetty，现有通信方式，通信损耗较高\n    2. netty，改进方式，使用长连接\n3. 引入调度层\n    1. 解耦quartz，减少对quartz的依赖\n    2. 方便后续对quartz以及去quartz改造\n4. 引入redis\n    1. 任务多机分发，将任务放入redis队列中，然后消费队列数据（需要处理redis宕机场景，走单机分发或者补偿逻辑）\n    2. 加快quartz的加锁机制，数据库加锁较慢","slug":"DTS技术调研前言","published":1,"updated":"2018-07-01T07:15:12.924Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5u1tup00051av8msiweghp","content":"<h1 id=\"quartz\"><a href=\"#quartz\" class=\"headerlink\" title=\"quartz\"></a>quartz</h1><p>对现有方式做单机性能测试，下面是相关测试结果：</p>\n<ul>\n<li>mysql，单秒100个任务（主要是数据库锁加锁过程比较慢）</li>\n<li>redis，单秒150个任务（开源代码，实现不是很好，主要表现为，不稳定，连接池经常耗尽，并且可能会遭遇任务数据丢失场景）</li>\n<li>ram，每秒1500个任务</li>\n</ul>\n<p>总结下来可能还是会继续使用mysql做quartz的持久化，但是会针对性的做一些性能优化。<br>比如以下场景：</p>\n<ol>\n<li>加锁方式上，可能不再采用数据库锁，采用redis或者zk来实现分布式锁</li>\n<li>加锁粒度上，减小锁的粒度，从而减少锁的占用时间，提高吞吐量<a id=\"more\"></a>\n</li>\n</ol>\n<h1 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h1><p>数据库优化打算采用以下两种方式：</p>\n<ul>\n<li>tidb，分布式关系型数据库，成规模部署性能比较高，单机部署性能比较差。</li>\n<li>mysql分库分表，两库共四表，用于减轻数据库锁的压力</li>\n</ul>\n<p>为什么最后采用分库分表？</p>\n<ol>\n<li>没有好的分布式关系型数据库支撑，tidb开源版本体验不够好，资料不是很多，本地测试一堆问题。</li>\n<li>架构层面分库分表更简单，对硬件没有什么特殊要求，只是要求多用几个库表。</li>\n</ol>\n<h1 id=\"架构\"><a href=\"#架构\" class=\"headerlink\" title=\"架构\"></a>架构</h1><ol>\n<li>引入分发层<ol>\n<li>单机，默认分发方式，可用性更高（不依赖其他外部存储），单个任务的分发时间会更短</li>\n<li>redis多机，通过配置redis自动生效，总体分发性能更高，</li>\n<li>自动模式，根据任务数量，自动选择分发模式</li>\n</ol>\n</li>\n<li>引入通信层<ol>\n<li>jetty，现有通信方式，通信损耗较高</li>\n<li>netty，改进方式，使用长连接</li>\n</ol>\n</li>\n<li>引入调度层<ol>\n<li>解耦quartz，减少对quartz的依赖</li>\n<li>方便后续对quartz以及去quartz改造</li>\n</ol>\n</li>\n<li>引入redis<ol>\n<li>任务多机分发，将任务放入redis队列中，然后消费队列数据（需要处理redis宕机场景，走单机分发或者补偿逻辑）</li>\n<li>加快quartz的加锁机制，数据库加锁较慢</li>\n</ol>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h1 id=\"quartz\"><a href=\"#quartz\" class=\"headerlink\" title=\"quartz\"></a>quartz</h1><p>对现有方式做单机性能测试，下面是相关测试结果：</p>\n<ul>\n<li>mysql，单秒100个任务（主要是数据库锁加锁过程比较慢）</li>\n<li>redis，单秒150个任务（开源代码，实现不是很好，主要表现为，不稳定，连接池经常耗尽，并且可能会遭遇任务数据丢失场景）</li>\n<li>ram，每秒1500个任务</li>\n</ul>\n<p>总结下来可能还是会继续使用mysql做quartz的持久化，但是会针对性的做一些性能优化。<br>比如以下场景：</p>\n<ol>\n<li>加锁方式上，可能不再采用数据库锁，采用redis或者zk来实现分布式锁</li>\n<li>加锁粒度上，减小锁的粒度，从而减少锁的占用时间，提高吞吐量","more":"</li>\n</ol>\n<h1 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h1><p>数据库优化打算采用以下两种方式：</p>\n<ul>\n<li>tidb，分布式关系型数据库，成规模部署性能比较高，单机部署性能比较差。</li>\n<li>mysql分库分表，两库共四表，用于减轻数据库锁的压力</li>\n</ul>\n<p>为什么最后采用分库分表？</p>\n<ol>\n<li>没有好的分布式关系型数据库支撑，tidb开源版本体验不够好，资料不是很多，本地测试一堆问题。</li>\n<li>架构层面分库分表更简单，对硬件没有什么特殊要求，只是要求多用几个库表。</li>\n</ol>\n<h1 id=\"架构\"><a href=\"#架构\" class=\"headerlink\" title=\"架构\"></a>架构</h1><ol>\n<li>引入分发层<ol>\n<li>单机，默认分发方式，可用性更高（不依赖其他外部存储），单个任务的分发时间会更短</li>\n<li>redis多机，通过配置redis自动生效，总体分发性能更高，</li>\n<li>自动模式，根据任务数量，自动选择分发模式</li>\n</ol>\n</li>\n<li>引入通信层<ol>\n<li>jetty，现有通信方式，通信损耗较高</li>\n<li>netty，改进方式，使用长连接</li>\n</ol>\n</li>\n<li>引入调度层<ol>\n<li>解耦quartz，减少对quartz的依赖</li>\n<li>方便后续对quartz以及去quartz改造</li>\n</ol>\n</li>\n<li>引入redis<ol>\n<li>任务多机分发，将任务放入redis队列中，然后消费队列数据（需要处理redis宕机场景，走单机分发或者补偿逻辑）</li>\n<li>加快quartz的加锁机制，数据库加锁较慢</li>\n</ol>\n</li>\n</ol>"},{"title":"DTS排期","date":"2018-07-01T06:42:10.000Z","catrgories":["中间件"],"_content":"功能点|描述|工时/小时\n:--:|:--:|:--:\nspring boot改造|将现有spring技术体系替换成spring boot2.0|16\n分库分表|将现有一库一表替换成两库各两表|8\n调度层解耦|从quartz调度中解耦|16\n分发层解耦|改为支持单机分发和多机分发|16\n通信层解耦|jetty解耦|16\n剩余再说","source":"_posts/DTS排期.md","raw":"---\ntitle: DTS排期\ndate: 2018-07-01 14:42:10\ntags:\n- 中间件\n- 开源\ncatrgories:\n- 中间件\n---\n功能点|描述|工时/小时\n:--:|:--:|:--:\nspring boot改造|将现有spring技术体系替换成spring boot2.0|16\n分库分表|将现有一库一表替换成两库各两表|8\n调度层解耦|从quartz调度中解耦|16\n分发层解耦|改为支持单机分发和多机分发|16\n通信层解耦|jetty解耦|16\n剩余再说","slug":"DTS排期","published":1,"updated":"2018-07-01T07:08:41.562Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5u1tuq00061av8ag56afj9","content":"<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">功能点</th>\n<th style=\"text-align:center\">描述</th>\n<th style=\"text-align:center\">工时/小时</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">spring boot改造</td>\n<td style=\"text-align:center\">将现有spring技术体系替换成spring boot2.0</td>\n<td style=\"text-align:center\">16</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">分库分表</td>\n<td style=\"text-align:center\">将现有一库一表替换成两库各两表</td>\n<td style=\"text-align:center\">8</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">调度层解耦</td>\n<td style=\"text-align:center\">从quartz调度中解耦</td>\n<td style=\"text-align:center\">16</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">分发层解耦</td>\n<td style=\"text-align:center\">改为支持单机分发和多机分发</td>\n<td style=\"text-align:center\">16</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">通信层解耦</td>\n<td style=\"text-align:center\">jetty解耦</td>\n<td style=\"text-align:center\">16</td>\n</tr>\n</tbody>\n</table>\n<p>剩余再说</p>\n","site":{"data":{}},"excerpt":"","more":"<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">功能点</th>\n<th style=\"text-align:center\">描述</th>\n<th style=\"text-align:center\">工时/小时</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">spring boot改造</td>\n<td style=\"text-align:center\">将现有spring技术体系替换成spring boot2.0</td>\n<td style=\"text-align:center\">16</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">分库分表</td>\n<td style=\"text-align:center\">将现有一库一表替换成两库各两表</td>\n<td style=\"text-align:center\">8</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">调度层解耦</td>\n<td style=\"text-align:center\">从quartz调度中解耦</td>\n<td style=\"text-align:center\">16</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">分发层解耦</td>\n<td style=\"text-align:center\">改为支持单机分发和多机分发</td>\n<td style=\"text-align:center\">16</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">通信层解耦</td>\n<td style=\"text-align:center\">jetty解耦</td>\n<td style=\"text-align:center\">16</td>\n</tr>\n</tbody>\n</table>\n<p>剩余再说</p>\n"},{"title":"Map分析","date":"2018-06-25T12:01:36.000Z","toc":true,"_content":"# HashMap\n## 成员属性\n1. Node<K,V>[]table，存储数据的数组\n2. Set<Map.Entry<K,V>>entrySet，遍历时使用的entrySet\n3. size，当前大小\n4. modCount，被非幂等操作改变的次数，entrySet中的ConcurrentModificationException\n5. threshold，下次resize时候可能需要满足的大小\n6. loadFactor，负载因子，size > (threshold = capacity * loadFactor)的时候，可能会resize，存在的作用是用于开发人员手动控制resize时具体的数组元素的多少。\n<!-- more -->\n\n## 静态属性\n1. DEFAULT_INITIAL_CAPACITY，初始大小，16\n2. MAXIMUM_CAPACITY，最大大小，2的30次方\n3. DEFAULT_LOAD_FACTOR，初始负载因子，0.75\n4. TREEIFY_THRESHOLD，treeify时候bin的最小大小，8\n5. UNTREEIFY_THRESHOLD，untreeify时bin内元素的最小大小，6\n6. MIN_TREEIFY_CAPACITY，最小treeify的容量，64，大于64才会treeify\n\n## 主要方法\n### hash\n虽然HashMap的bucket数量最大为Integer.MAX_VALUE，但是绝大部分的Map的bucket数量都是较小的，hash码也只用到低n位。\n```java\nstatic final int hash(Object key) {\n    int h;\n    // 混合原始哈希码的高位和低位，以此来加大低位的随机性\n    // 主要还是为了避免用户的hashCode算法有问题，低位散列不均衡\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n```\n### get\n1. 根据key的hash，计算出bucket的位置\n2. 如果bucket为空，返回空\n3. 如果是链表，遍历链表，其中使用equals比较\n4. 如果是红黑树的话，遍历整颗树，其中使用hash比较或者使用Comparable的compareTo方法作比较\n\n### put\n使用尾插法，因为put的过程中需要遍历整个链表，查看是否存在相同的key\n1. 如果table为空，进行resize()\n2. 根据hash计算bucket的index\n3. 取得bucket后，如果是空，构建链表\n4. 如果是链表节点，（如果需要树化，树化，走5），插入至链表头部\n5. 如果是树节点，插入树节点，并且进行平衡\n6. 最后需要resize，进行resize()\n\n### resize\nresize之后大小扩大两倍\n什么时候会进行resize？进一步观察下来，两种情况下会进行resize。\n1. 某个bin内的元素数量 > TREEIFY_THRESHOLD（8）, 但是总体的Capacity小于MIN_TREEIFY_CAPACITY（64）\n2. put操作过后，size > (threshold = capacity * loadFactor) 的时候也会。\n\nresize代码分析：\n下面这段代码很精妙，巧妙地利用了一个点。\n假设元素e，oldCapacity，oldPos\n```java\n// bucket内链表拆分落在，oldPos以及oldPos + oldCapacity两个新的bucket内\ne.newPos = e.hash & oldCapacity == 1 ? oldPos + oldCapacity: oldPos;\n// 下面是jdk代码，将链表做了精妙的拆解，拆成两段\n// 两个好处\n// 1. 不会倒置旧链表\n// 2. 效率更高\ndo {\n    next = e.next;\n    if ((e.hash & oldCap) == 0) {\n        if (loTail == null)\n            loHead = e;\n        else\n            loTail.next = e;\n        loTail = e;\n    }\n    else {\n        if (hiTail == null)\n            hiHead = e;\n        else\n            hiTail.next = e;\n        hiTail = e;\n    }\n} while ((e = next) != null);\nif (loTail != null) {\n    loTail.next = null;\n    newTab[j] = loHead;\n}\nif (hiTail != null) {\n    hiTail.next = null;\n    newTab[j + oldCap] = hiHead;\n}\n```\n\n### entrySet, keySet\n#### 原理\n两个都是针对table属性进行foreach循环遍历，但是keySet只能取出key，entrySet能取出Entry。两者都使用了modCount用来保证fail-fast，ConcurrentModificationException。\n#### 用法\n只需要遍历key的话还是推荐使用keySet()，但是不推荐下面这种用法。\n\n# ConcurrentHashMap\n## jdk7\n1. 分段锁，内部实现为Segment，继承了ReentrantLock\n2. 默认16段，最大为65536，Segment内部有HashEntry数组，并且采取拉链法处理hash冲突\n3. 扩容的时候针对于Segment内部的HashEntry数组来扩容。\n4. 需要注意的是jdk中有concurrencyLevel（代表Segment数组的大小），在8中已经没什么用处了，只能决定初始容量大小\n\n## 静态属性\n1. MAXIMUM_CAPACITY，table的最大大小，1<<30\n2. DEFAULT_CAPACITY，table的大小，16\n3. MAX_ARRAY_SIZE，元素最大个数，Integer.MAX_VALUE-8\n4. DEFAULT_CONCURRENCY_LEVEL，向jdk7兼容，16\n5. LOAD_FACTOR，负载因子，0.75f\n6. TREEIFY_THRESHOLD，进行树化的元素数量，8\n7. UNTREEIFY_THRESHOLD，untreeify时bin内元素的最小大小，6\n8. MIN_TREEIFY_CAPACITY，进行treeify时需要的最要容量要求，64\n9.  MIN_TRANSFER_STRIDE，多线程扩容时候的步长\n10. RESIZE_STAMP_BITS，\n11. MAX_RESIZERS，帮助resize的最大线程数\n12. RESIZE_STAMP_SHIFT，\n13. MOVED（-1），TREEBIN（-2），RESERVED（-3），hash的常量值，分别代表当前node是ForwardingNode，TreeNode，ReservationNode的hash值。\n    - ForwardingNode代表当前bin已经被resize操作过，并且需要当前线程一起帮助resize\n    - TreeNode代表当前\n    - Node就是普通的链表节点\n    - ReservationNode代表当前节点已经被占据（占位符的作用一样），用于后续的mappingFunction操作结束之后再把值塞入进去。\n\n## 成员属性\n1. table，存储元素的数组\n2. nextTable，也是存储元素的数组，只不过该数组在resizing的时候才会被用到。\n3. baseCount，容器中存储元素的数量值（基本值）\n4. sizeCtl，代表当前容器中正在进行的关于容量的操作，-1，代表正在被初始化，≤-1，代表正在被（-sizeCtl-1)个线程扩容，≥0代表0.75*capacity\n5. transferIndex，代表已经或者正在被扩容处理的节点，未被处理的bin的范围为0~transferIndex - 1\n6. cellsBusy，代表当前正在初始化某个CounterCell，用于控制多个线程不能同时初始化一个CounterCell\n7. counterCells，计数器，ConcurrentHashMap的真正size是baseCount+CounterCell数组中的计数。具体看LongAdder分析\n8. keySet，此三个属性为迭代器视图\n9. values\n10. entrySet\n\n## 主要方法\n### resize\n1. 需要判断是否是第一个线程，如果是第一个线程还需要进行新建数组操作\n2. 假设当前容量为64，需要扩容到128，一共三个线程扩容\n3. 假设stride是16，capacity是64，两个线程正在参与扩容操作\n4. 第一个线程处理(48,64]这个范围的元素\n5. 第二个线程处理(32,48]\n6. 谁先处理完手里的元素，就将transferIndex减去stride(32-16),就会继续处理(16,32]这个范围一样\n7. 其他线程进来之后，也会减少transferIndex   \n8. 链表的拆分或者树的拆分都是新建了全新的链表或者是树。\n9. 链表会被倒置。树则不会，会再次平衡 \n\n### putVal\n1. 如果未初始化数组，cas操作sizeCtl为-1，初始化数组\n2. 如果未初始化bin（bucket），cas数组元素初始化\n3. 如果当前bin的首元素是ForwardingNode，帮助进行resize\n4. 在数组已经初始化，当前bin未被扩容的情况下，对当前bin的头结点，加锁，进行链表或者红黑树的插入\n5. 插入完成之后判断是否需要进行树化，或者进行resize\n\n<img src=\"/images/putVal1.png\" width=\"60%\" style=\"margin-left:0;\">\n<img src=\"/images/putVal2.png\" width=\"60%\" style=\"margin-left:0;\">\n\n### get\n<img src=\"/images/get1.png\" width=\"60%\" style=\"margin-left:0;\">\n<img src=\"/images/get2.png\" width=\"60%\" style=\"margin-left:0;\">\n\n# LinkedHashMap\n数据倾斜：由于hash算法设计不合理，或者原本输入传不合理，导致hash结果集中度太高\n## 成员属性\n1. `LinkedHashMap.Entry<K,V> head`，表示链表的头结点\n2. `LinkedHashMap.Entry<K,V> tail`，表示链表的尾节点\n3. `boolean accessOrder`，表示当前插入节点时候时候需要维护有序\n<!-- more -->\n\n## 主要方法\n```java\n// 将当前节点加入到链表的最后去\nprivate void linkNodeLast(LinkedHashMap.Entry<K,V> p) {\n    LinkedHashMap.Entry<K,V> last = tail;\n    tail = p;\n    if (last == null)\n        head = p;\n    else {\n        p.before = last;\n        last.after = p;\n    }\n}\n\n// 将某个节点替换成另外一个\nprivate void transferLinks(LinkedHashMap.Entry<K,V> src,\n                            LinkedHashMap.Entry<K,V> dst) {\n    LinkedHashMap.Entry<K,V> b = dst.before = src.before;\n    LinkedHashMap.Entry<K,V> a = dst.after = src.after;\n    if (b == null)\n        head = dst;\n    else\n        b.after = dst;\n    if (a == null)\n        tail = dst;\n    else\n        a.before = dst;\n}\n\n// 新建节点，可以看出使用的是LinkHashMap.Entry\nNode<K,V> newNode(int hash, K key, V value, Node<K,V> e) {\n    LinkedHashMap.Entry<K,V> p =\n        new LinkedHashMap.Entry<K,V>(hash, key, value, e);\n    linkNodeLast(p);\n    return p;\n}\n\n// 替换节点\nNode<K,V> replacementNode(Node<K,V> p, Node<K,V> next) {\n    LinkedHashMap.Entry<K,V> q = (LinkedHashMap.Entry<K,V>)p;\n    LinkedHashMap.Entry<K,V> t =\n        new LinkedHashMap.Entry<K,V>(q.hash, q.key, q.value, next);\n    transferLinks(q, t);\n    return t;\n}\n\nTreeNode<K,V> newTreeNode(int hash, K key, V value, Node<K,V> next) {\n    TreeNode<K,V> p = new TreeNode<K,V>(hash, key, value, next);\n    linkNodeLast(p);\n    return p;\n}\n\nTreeNode<K,V> replacementTreeNode(Node<K,V> p, Node<K,V> next) {\n    LinkedHashMap.Entry<K,V> q = (LinkedHashMap.Entry<K,V>)p;\n    TreeNode<K,V> t = new TreeNode<K,V>(q.hash, q.key, q.value, next);\n    transferLinks(q, t);\n    return t;\n}\n// 将节点从链表中删除\nvoid afterNodeRemoval(Node<K,V> e) { // unlink\n    LinkedHashMap.Entry<K,V> p =\n        (LinkedHashMap.Entry<K,V>)e, b = p.before, a = p.after;\n    p.before = p.after = null;\n    if (b == null)\n        head = a;\n    else\n        b.after = a;\n    if (a == null)\n        tail = b;\n    else\n        a.before = b;\n}\n\nvoid afterNodeInsertion(boolean evict) { // possibly remove eldest\n    LinkedHashMap.Entry<K,V> first;\n    if (evict && (first = head) != null && removeEldestEntry(first)) {\n        K key = first.key;\n        removeNode(hash(key), key, null, false, true);\n    }\n}\n\n// 在get方法之后会调用这个，作用是将头结点，放到尾部，第二个节点编程头结点\nvoid afterNodeAccess(Node<K,V> e) { // move node to last\n    LinkedHashMap.Entry<K,V> last;\n    if (accessOrder && (last = tail) != e) {\n        LinkedHashMap.Entry<K,V> p =\n            (LinkedHashMap.Entry<K,V>)e, b = p.before, a = p.after;\n        p.after = null;\n        if (b == null)\n            head = a;\n        else\n            b.after = a;\n        if (a != null)\n            a.before = b;\n        else\n            last = b;\n        if (last == null)\n            head = p;\n        else {\n            p.before = last;\n            last.after = p;\n        }\n        tail = p;\n        ++modCount;\n    }\n}\n```\n","source":"_posts/Map分析.md","raw":"---\ntitle: Map分析\ndate: 2018-06-25 20:01:36\ntags:\n- java\n- 集合\n- 源码\ncategories:\n- java\n- 集合\ntoc: true\n---\n# HashMap\n## 成员属性\n1. Node<K,V>[]table，存储数据的数组\n2. Set<Map.Entry<K,V>>entrySet，遍历时使用的entrySet\n3. size，当前大小\n4. modCount，被非幂等操作改变的次数，entrySet中的ConcurrentModificationException\n5. threshold，下次resize时候可能需要满足的大小\n6. loadFactor，负载因子，size > (threshold = capacity * loadFactor)的时候，可能会resize，存在的作用是用于开发人员手动控制resize时具体的数组元素的多少。\n<!-- more -->\n\n## 静态属性\n1. DEFAULT_INITIAL_CAPACITY，初始大小，16\n2. MAXIMUM_CAPACITY，最大大小，2的30次方\n3. DEFAULT_LOAD_FACTOR，初始负载因子，0.75\n4. TREEIFY_THRESHOLD，treeify时候bin的最小大小，8\n5. UNTREEIFY_THRESHOLD，untreeify时bin内元素的最小大小，6\n6. MIN_TREEIFY_CAPACITY，最小treeify的容量，64，大于64才会treeify\n\n## 主要方法\n### hash\n虽然HashMap的bucket数量最大为Integer.MAX_VALUE，但是绝大部分的Map的bucket数量都是较小的，hash码也只用到低n位。\n```java\nstatic final int hash(Object key) {\n    int h;\n    // 混合原始哈希码的高位和低位，以此来加大低位的随机性\n    // 主要还是为了避免用户的hashCode算法有问题，低位散列不均衡\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n```\n### get\n1. 根据key的hash，计算出bucket的位置\n2. 如果bucket为空，返回空\n3. 如果是链表，遍历链表，其中使用equals比较\n4. 如果是红黑树的话，遍历整颗树，其中使用hash比较或者使用Comparable的compareTo方法作比较\n\n### put\n使用尾插法，因为put的过程中需要遍历整个链表，查看是否存在相同的key\n1. 如果table为空，进行resize()\n2. 根据hash计算bucket的index\n3. 取得bucket后，如果是空，构建链表\n4. 如果是链表节点，（如果需要树化，树化，走5），插入至链表头部\n5. 如果是树节点，插入树节点，并且进行平衡\n6. 最后需要resize，进行resize()\n\n### resize\nresize之后大小扩大两倍\n什么时候会进行resize？进一步观察下来，两种情况下会进行resize。\n1. 某个bin内的元素数量 > TREEIFY_THRESHOLD（8）, 但是总体的Capacity小于MIN_TREEIFY_CAPACITY（64）\n2. put操作过后，size > (threshold = capacity * loadFactor) 的时候也会。\n\nresize代码分析：\n下面这段代码很精妙，巧妙地利用了一个点。\n假设元素e，oldCapacity，oldPos\n```java\n// bucket内链表拆分落在，oldPos以及oldPos + oldCapacity两个新的bucket内\ne.newPos = e.hash & oldCapacity == 1 ? oldPos + oldCapacity: oldPos;\n// 下面是jdk代码，将链表做了精妙的拆解，拆成两段\n// 两个好处\n// 1. 不会倒置旧链表\n// 2. 效率更高\ndo {\n    next = e.next;\n    if ((e.hash & oldCap) == 0) {\n        if (loTail == null)\n            loHead = e;\n        else\n            loTail.next = e;\n        loTail = e;\n    }\n    else {\n        if (hiTail == null)\n            hiHead = e;\n        else\n            hiTail.next = e;\n        hiTail = e;\n    }\n} while ((e = next) != null);\nif (loTail != null) {\n    loTail.next = null;\n    newTab[j] = loHead;\n}\nif (hiTail != null) {\n    hiTail.next = null;\n    newTab[j + oldCap] = hiHead;\n}\n```\n\n### entrySet, keySet\n#### 原理\n两个都是针对table属性进行foreach循环遍历，但是keySet只能取出key，entrySet能取出Entry。两者都使用了modCount用来保证fail-fast，ConcurrentModificationException。\n#### 用法\n只需要遍历key的话还是推荐使用keySet()，但是不推荐下面这种用法。\n\n# ConcurrentHashMap\n## jdk7\n1. 分段锁，内部实现为Segment，继承了ReentrantLock\n2. 默认16段，最大为65536，Segment内部有HashEntry数组，并且采取拉链法处理hash冲突\n3. 扩容的时候针对于Segment内部的HashEntry数组来扩容。\n4. 需要注意的是jdk中有concurrencyLevel（代表Segment数组的大小），在8中已经没什么用处了，只能决定初始容量大小\n\n## 静态属性\n1. MAXIMUM_CAPACITY，table的最大大小，1<<30\n2. DEFAULT_CAPACITY，table的大小，16\n3. MAX_ARRAY_SIZE，元素最大个数，Integer.MAX_VALUE-8\n4. DEFAULT_CONCURRENCY_LEVEL，向jdk7兼容，16\n5. LOAD_FACTOR，负载因子，0.75f\n6. TREEIFY_THRESHOLD，进行树化的元素数量，8\n7. UNTREEIFY_THRESHOLD，untreeify时bin内元素的最小大小，6\n8. MIN_TREEIFY_CAPACITY，进行treeify时需要的最要容量要求，64\n9.  MIN_TRANSFER_STRIDE，多线程扩容时候的步长\n10. RESIZE_STAMP_BITS，\n11. MAX_RESIZERS，帮助resize的最大线程数\n12. RESIZE_STAMP_SHIFT，\n13. MOVED（-1），TREEBIN（-2），RESERVED（-3），hash的常量值，分别代表当前node是ForwardingNode，TreeNode，ReservationNode的hash值。\n    - ForwardingNode代表当前bin已经被resize操作过，并且需要当前线程一起帮助resize\n    - TreeNode代表当前\n    - Node就是普通的链表节点\n    - ReservationNode代表当前节点已经被占据（占位符的作用一样），用于后续的mappingFunction操作结束之后再把值塞入进去。\n\n## 成员属性\n1. table，存储元素的数组\n2. nextTable，也是存储元素的数组，只不过该数组在resizing的时候才会被用到。\n3. baseCount，容器中存储元素的数量值（基本值）\n4. sizeCtl，代表当前容器中正在进行的关于容量的操作，-1，代表正在被初始化，≤-1，代表正在被（-sizeCtl-1)个线程扩容，≥0代表0.75*capacity\n5. transferIndex，代表已经或者正在被扩容处理的节点，未被处理的bin的范围为0~transferIndex - 1\n6. cellsBusy，代表当前正在初始化某个CounterCell，用于控制多个线程不能同时初始化一个CounterCell\n7. counterCells，计数器，ConcurrentHashMap的真正size是baseCount+CounterCell数组中的计数。具体看LongAdder分析\n8. keySet，此三个属性为迭代器视图\n9. values\n10. entrySet\n\n## 主要方法\n### resize\n1. 需要判断是否是第一个线程，如果是第一个线程还需要进行新建数组操作\n2. 假设当前容量为64，需要扩容到128，一共三个线程扩容\n3. 假设stride是16，capacity是64，两个线程正在参与扩容操作\n4. 第一个线程处理(48,64]这个范围的元素\n5. 第二个线程处理(32,48]\n6. 谁先处理完手里的元素，就将transferIndex减去stride(32-16),就会继续处理(16,32]这个范围一样\n7. 其他线程进来之后，也会减少transferIndex   \n8. 链表的拆分或者树的拆分都是新建了全新的链表或者是树。\n9. 链表会被倒置。树则不会，会再次平衡 \n\n### putVal\n1. 如果未初始化数组，cas操作sizeCtl为-1，初始化数组\n2. 如果未初始化bin（bucket），cas数组元素初始化\n3. 如果当前bin的首元素是ForwardingNode，帮助进行resize\n4. 在数组已经初始化，当前bin未被扩容的情况下，对当前bin的头结点，加锁，进行链表或者红黑树的插入\n5. 插入完成之后判断是否需要进行树化，或者进行resize\n\n<img src=\"/images/putVal1.png\" width=\"60%\" style=\"margin-left:0;\">\n<img src=\"/images/putVal2.png\" width=\"60%\" style=\"margin-left:0;\">\n\n### get\n<img src=\"/images/get1.png\" width=\"60%\" style=\"margin-left:0;\">\n<img src=\"/images/get2.png\" width=\"60%\" style=\"margin-left:0;\">\n\n# LinkedHashMap\n数据倾斜：由于hash算法设计不合理，或者原本输入传不合理，导致hash结果集中度太高\n## 成员属性\n1. `LinkedHashMap.Entry<K,V> head`，表示链表的头结点\n2. `LinkedHashMap.Entry<K,V> tail`，表示链表的尾节点\n3. `boolean accessOrder`，表示当前插入节点时候时候需要维护有序\n<!-- more -->\n\n## 主要方法\n```java\n// 将当前节点加入到链表的最后去\nprivate void linkNodeLast(LinkedHashMap.Entry<K,V> p) {\n    LinkedHashMap.Entry<K,V> last = tail;\n    tail = p;\n    if (last == null)\n        head = p;\n    else {\n        p.before = last;\n        last.after = p;\n    }\n}\n\n// 将某个节点替换成另外一个\nprivate void transferLinks(LinkedHashMap.Entry<K,V> src,\n                            LinkedHashMap.Entry<K,V> dst) {\n    LinkedHashMap.Entry<K,V> b = dst.before = src.before;\n    LinkedHashMap.Entry<K,V> a = dst.after = src.after;\n    if (b == null)\n        head = dst;\n    else\n        b.after = dst;\n    if (a == null)\n        tail = dst;\n    else\n        a.before = dst;\n}\n\n// 新建节点，可以看出使用的是LinkHashMap.Entry\nNode<K,V> newNode(int hash, K key, V value, Node<K,V> e) {\n    LinkedHashMap.Entry<K,V> p =\n        new LinkedHashMap.Entry<K,V>(hash, key, value, e);\n    linkNodeLast(p);\n    return p;\n}\n\n// 替换节点\nNode<K,V> replacementNode(Node<K,V> p, Node<K,V> next) {\n    LinkedHashMap.Entry<K,V> q = (LinkedHashMap.Entry<K,V>)p;\n    LinkedHashMap.Entry<K,V> t =\n        new LinkedHashMap.Entry<K,V>(q.hash, q.key, q.value, next);\n    transferLinks(q, t);\n    return t;\n}\n\nTreeNode<K,V> newTreeNode(int hash, K key, V value, Node<K,V> next) {\n    TreeNode<K,V> p = new TreeNode<K,V>(hash, key, value, next);\n    linkNodeLast(p);\n    return p;\n}\n\nTreeNode<K,V> replacementTreeNode(Node<K,V> p, Node<K,V> next) {\n    LinkedHashMap.Entry<K,V> q = (LinkedHashMap.Entry<K,V>)p;\n    TreeNode<K,V> t = new TreeNode<K,V>(q.hash, q.key, q.value, next);\n    transferLinks(q, t);\n    return t;\n}\n// 将节点从链表中删除\nvoid afterNodeRemoval(Node<K,V> e) { // unlink\n    LinkedHashMap.Entry<K,V> p =\n        (LinkedHashMap.Entry<K,V>)e, b = p.before, a = p.after;\n    p.before = p.after = null;\n    if (b == null)\n        head = a;\n    else\n        b.after = a;\n    if (a == null)\n        tail = b;\n    else\n        a.before = b;\n}\n\nvoid afterNodeInsertion(boolean evict) { // possibly remove eldest\n    LinkedHashMap.Entry<K,V> first;\n    if (evict && (first = head) != null && removeEldestEntry(first)) {\n        K key = first.key;\n        removeNode(hash(key), key, null, false, true);\n    }\n}\n\n// 在get方法之后会调用这个，作用是将头结点，放到尾部，第二个节点编程头结点\nvoid afterNodeAccess(Node<K,V> e) { // move node to last\n    LinkedHashMap.Entry<K,V> last;\n    if (accessOrder && (last = tail) != e) {\n        LinkedHashMap.Entry<K,V> p =\n            (LinkedHashMap.Entry<K,V>)e, b = p.before, a = p.after;\n        p.after = null;\n        if (b == null)\n            head = a;\n        else\n            b.after = a;\n        if (a != null)\n            a.before = b;\n        else\n            last = b;\n        if (last == null)\n            head = p;\n        else {\n            p.before = last;\n            last.after = p;\n        }\n        tail = p;\n        ++modCount;\n    }\n}\n```\n","slug":"Map分析","published":1,"updated":"2018-06-25T12:48:44.952Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5u1tut00091av8bxi52m3g","content":"<h1 id=\"HashMap\"><a href=\"#HashMap\" class=\"headerlink\" title=\"HashMap\"></a>HashMap</h1><h2 id=\"成员属性\"><a href=\"#成员属性\" class=\"headerlink\" title=\"成员属性\"></a>成员属性</h2><ol>\n<li>Node&lt;K,V&gt;[]table，存储数据的数组</li>\n<li>Set&lt;Map.Entry&lt;K,V&gt;&gt;entrySet，遍历时使用的entrySet</li>\n<li>size，当前大小</li>\n<li>modCount，被非幂等操作改变的次数，entrySet中的ConcurrentModificationException</li>\n<li>threshold，下次resize时候可能需要满足的大小</li>\n<li>loadFactor，负载因子，size &gt; (threshold = capacity * loadFactor)的时候，可能会resize，存在的作用是用于开发人员手动控制resize时具体的数组元素的多少。<a id=\"more\"></a>\n</li>\n</ol>\n<h2 id=\"静态属性\"><a href=\"#静态属性\" class=\"headerlink\" title=\"静态属性\"></a>静态属性</h2><ol>\n<li>DEFAULT_INITIAL_CAPACITY，初始大小，16</li>\n<li>MAXIMUM_CAPACITY，最大大小，2的30次方</li>\n<li>DEFAULT_LOAD_FACTOR，初始负载因子，0.75</li>\n<li>TREEIFY_THRESHOLD，treeify时候bin的最小大小，8</li>\n<li>UNTREEIFY_THRESHOLD，untreeify时bin内元素的最小大小，6</li>\n<li>MIN_TREEIFY_CAPACITY，最小treeify的容量，64，大于64才会treeify</li>\n</ol>\n<h2 id=\"主要方法\"><a href=\"#主要方法\" class=\"headerlink\" title=\"主要方法\"></a>主要方法</h2><h3 id=\"hash\"><a href=\"#hash\" class=\"headerlink\" title=\"hash\"></a>hash</h3><p>虽然HashMap的bucket数量最大为Integer.MAX_VALUE，但是绝大部分的Map的bucket数量都是较小的，hash码也只用到低n位。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> h;</span><br><span class=\"line\">    <span class=\"comment\">// 混合原始哈希码的高位和低位，以此来加大低位的随机性</span></span><br><span class=\"line\">    <span class=\"comment\">// 主要还是为了避免用户的hashCode算法有问题，低位散列不均衡</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"get\"><a href=\"#get\" class=\"headerlink\" title=\"get\"></a>get</h3><ol>\n<li>根据key的hash，计算出bucket的位置</li>\n<li>如果bucket为空，返回空</li>\n<li>如果是链表，遍历链表，其中使用equals比较</li>\n<li>如果是红黑树的话，遍历整颗树，其中使用hash比较或者使用Comparable的compareTo方法作比较</li>\n</ol>\n<h3 id=\"put\"><a href=\"#put\" class=\"headerlink\" title=\"put\"></a>put</h3><p>使用尾插法，因为put的过程中需要遍历整个链表，查看是否存在相同的key</p>\n<ol>\n<li>如果table为空，进行resize()</li>\n<li>根据hash计算bucket的index</li>\n<li>取得bucket后，如果是空，构建链表</li>\n<li>如果是链表节点，（如果需要树化，树化，走5），插入至链表头部</li>\n<li>如果是树节点，插入树节点，并且进行平衡</li>\n<li>最后需要resize，进行resize()</li>\n</ol>\n<h3 id=\"resize\"><a href=\"#resize\" class=\"headerlink\" title=\"resize\"></a>resize</h3><p>resize之后大小扩大两倍<br>什么时候会进行resize？进一步观察下来，两种情况下会进行resize。</p>\n<ol>\n<li>某个bin内的元素数量 &gt; TREEIFY_THRESHOLD（8）, 但是总体的Capacity小于MIN_TREEIFY_CAPACITY（64）</li>\n<li>put操作过后，size &gt; (threshold = capacity * loadFactor) 的时候也会。</li>\n</ol>\n<p>resize代码分析：<br>下面这段代码很精妙，巧妙地利用了一个点。<br>假设元素e，oldCapacity，oldPos<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// bucket内链表拆分落在，oldPos以及oldPos + oldCapacity两个新的bucket内</span></span><br><span class=\"line\">e.newPos = e.hash &amp; oldCapacity == <span class=\"number\">1</span> ? oldPos + oldCapacity: oldPos;</span><br><span class=\"line\"><span class=\"comment\">// 下面是jdk代码，将链表做了精妙的拆解，拆成两段</span></span><br><span class=\"line\"><span class=\"comment\">// 两个好处</span></span><br><span class=\"line\"><span class=\"comment\">// 1. 不会倒置旧链表</span></span><br><span class=\"line\"><span class=\"comment\">// 2. 效率更高</span></span><br><span class=\"line\"><span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">    next = e.next;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((e.hash &amp; oldCap) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (loTail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            loHead = e;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            loTail.next = e;</span><br><span class=\"line\">        loTail = e;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (hiTail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            hiHead = e;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            hiTail.next = e;</span><br><span class=\"line\">        hiTail = e;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">while</span> ((e = next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (loTail != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    loTail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    newTab[j] = loHead;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (hiTail != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    hiTail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    newTab[j + oldCap] = hiHead;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"entrySet-keySet\"><a href=\"#entrySet-keySet\" class=\"headerlink\" title=\"entrySet, keySet\"></a>entrySet, keySet</h3><h4 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h4><p>两个都是针对table属性进行foreach循环遍历，但是keySet只能取出key，entrySet能取出Entry。两者都使用了modCount用来保证fail-fast，ConcurrentModificationException。</p>\n<h4 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h4><p>只需要遍历key的话还是推荐使用keySet()，但是不推荐下面这种用法。</p>\n<h1 id=\"ConcurrentHashMap\"><a href=\"#ConcurrentHashMap\" class=\"headerlink\" title=\"ConcurrentHashMap\"></a>ConcurrentHashMap</h1><h2 id=\"jdk7\"><a href=\"#jdk7\" class=\"headerlink\" title=\"jdk7\"></a>jdk7</h2><ol>\n<li>分段锁，内部实现为Segment，继承了ReentrantLock</li>\n<li>默认16段，最大为65536，Segment内部有HashEntry数组，并且采取拉链法处理hash冲突</li>\n<li>扩容的时候针对于Segment内部的HashEntry数组来扩容。</li>\n<li>需要注意的是jdk中有concurrencyLevel（代表Segment数组的大小），在8中已经没什么用处了，只能决定初始容量大小</li>\n</ol>\n<h2 id=\"静态属性-1\"><a href=\"#静态属性-1\" class=\"headerlink\" title=\"静态属性\"></a>静态属性</h2><ol>\n<li>MAXIMUM_CAPACITY，table的最大大小，1&lt;&lt;30</li>\n<li>DEFAULT_CAPACITY，table的大小，16</li>\n<li>MAX_ARRAY_SIZE，元素最大个数，Integer.MAX_VALUE-8</li>\n<li>DEFAULT_CONCURRENCY_LEVEL，向jdk7兼容，16</li>\n<li>LOAD_FACTOR，负载因子，0.75f</li>\n<li>TREEIFY_THRESHOLD，进行树化的元素数量，8</li>\n<li>UNTREEIFY_THRESHOLD，untreeify时bin内元素的最小大小，6</li>\n<li>MIN_TREEIFY_CAPACITY，进行treeify时需要的最要容量要求，64</li>\n<li>MIN_TRANSFER_STRIDE，多线程扩容时候的步长</li>\n<li>RESIZE_STAMP_BITS，</li>\n<li>MAX_RESIZERS，帮助resize的最大线程数</li>\n<li>RESIZE_STAMP_SHIFT，</li>\n<li>MOVED（-1），TREEBIN（-2），RESERVED（-3），hash的常量值，分别代表当前node是ForwardingNode，TreeNode，ReservationNode的hash值。<ul>\n<li>ForwardingNode代表当前bin已经被resize操作过，并且需要当前线程一起帮助resize</li>\n<li>TreeNode代表当前</li>\n<li>Node就是普通的链表节点</li>\n<li>ReservationNode代表当前节点已经被占据（占位符的作用一样），用于后续的mappingFunction操作结束之后再把值塞入进去。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"成员属性-1\"><a href=\"#成员属性-1\" class=\"headerlink\" title=\"成员属性\"></a>成员属性</h2><ol>\n<li>table，存储元素的数组</li>\n<li>nextTable，也是存储元素的数组，只不过该数组在resizing的时候才会被用到。</li>\n<li>baseCount，容器中存储元素的数量值（基本值）</li>\n<li>sizeCtl，代表当前容器中正在进行的关于容量的操作，-1，代表正在被初始化，≤-1，代表正在被（-sizeCtl-1)个线程扩容，≥0代表0.75*capacity</li>\n<li>transferIndex，代表已经或者正在被扩容处理的节点，未被处理的bin的范围为0~transferIndex - 1</li>\n<li>cellsBusy，代表当前正在初始化某个CounterCell，用于控制多个线程不能同时初始化一个CounterCell</li>\n<li>counterCells，计数器，ConcurrentHashMap的真正size是baseCount+CounterCell数组中的计数。具体看LongAdder分析</li>\n<li>keySet，此三个属性为迭代器视图</li>\n<li>values</li>\n<li>entrySet</li>\n</ol>\n<h2 id=\"主要方法-1\"><a href=\"#主要方法-1\" class=\"headerlink\" title=\"主要方法\"></a>主要方法</h2><h3 id=\"resize-1\"><a href=\"#resize-1\" class=\"headerlink\" title=\"resize\"></a>resize</h3><ol>\n<li>需要判断是否是第一个线程，如果是第一个线程还需要进行新建数组操作</li>\n<li>假设当前容量为64，需要扩容到128，一共三个线程扩容</li>\n<li>假设stride是16，capacity是64，两个线程正在参与扩容操作</li>\n<li>第一个线程处理(48,64]这个范围的元素</li>\n<li>第二个线程处理(32,48]</li>\n<li>谁先处理完手里的元素，就将transferIndex减去stride(32-16),就会继续处理(16,32]这个范围一样</li>\n<li>其他线程进来之后，也会减少transferIndex   </li>\n<li>链表的拆分或者树的拆分都是新建了全新的链表或者是树。</li>\n<li>链表会被倒置。树则不会，会再次平衡 </li>\n</ol>\n<h3 id=\"putVal\"><a href=\"#putVal\" class=\"headerlink\" title=\"putVal\"></a>putVal</h3><ol>\n<li>如果未初始化数组，cas操作sizeCtl为-1，初始化数组</li>\n<li>如果未初始化bin（bucket），cas数组元素初始化</li>\n<li>如果当前bin的首元素是ForwardingNode，帮助进行resize</li>\n<li>在数组已经初始化，当前bin未被扩容的情况下，对当前bin的头结点，加锁，进行链表或者红黑树的插入</li>\n<li>插入完成之后判断是否需要进行树化，或者进行resize</li>\n</ol>\n<p><img src=\"/images/putVal1.png\" width=\"60%\" style=\"margin-left:0;\"><br><img src=\"/images/putVal2.png\" width=\"60%\" style=\"margin-left:0;\"></p>\n<h3 id=\"get-1\"><a href=\"#get-1\" class=\"headerlink\" title=\"get\"></a>get</h3><p><img src=\"/images/get1.png\" width=\"60%\" style=\"margin-left:0;\"><br><img src=\"/images/get2.png\" width=\"60%\" style=\"margin-left:0;\"></p>\n<h1 id=\"LinkedHashMap\"><a href=\"#LinkedHashMap\" class=\"headerlink\" title=\"LinkedHashMap\"></a>LinkedHashMap</h1><p>数据倾斜：由于hash算法设计不合理，或者原本输入传不合理，导致hash结果集中度太高</p>\n<h2 id=\"成员属性-2\"><a href=\"#成员属性-2\" class=\"headerlink\" title=\"成员属性\"></a>成员属性</h2><ol>\n<li><code>LinkedHashMap.Entry&lt;K,V&gt; head</code>，表示链表的头结点</li>\n<li><code>LinkedHashMap.Entry&lt;K,V&gt; tail</code>，表示链表的尾节点</li>\n<li><code>boolean accessOrder</code>，表示当前插入节点时候时候需要维护有序<!-- more -->\n</li>\n</ol>\n<h2 id=\"主要方法-2\"><a href=\"#主要方法-2\" class=\"headerlink\" title=\"主要方法\"></a>主要方法</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 将当前节点加入到链表的最后去</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">linkNodeLast</span><span class=\"params\">(LinkedHashMap.Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class=\"line\">    LinkedHashMap.Entry&lt;K,V&gt; last = tail;</span><br><span class=\"line\">    tail = p;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (last == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        head = p;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        p.before = last;</span><br><span class=\"line\">        last.after = p;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将某个节点替换成另外一个</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">transferLinks</span><span class=\"params\">(LinkedHashMap.Entry&lt;K,V&gt; src,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                            LinkedHashMap.Entry&lt;K,V&gt; dst)</span> </span>&#123;</span><br><span class=\"line\">    LinkedHashMap.Entry&lt;K,V&gt; b = dst.before = src.before;</span><br><span class=\"line\">    LinkedHashMap.Entry&lt;K,V&gt; a = dst.after = src.after;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (b == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        head = dst;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        b.after = dst;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (a == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        tail = dst;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        a.before = dst;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 新建节点，可以看出使用的是LinkHashMap.Entry</span></span><br><span class=\"line\"><span class=\"function\">Node&lt;K,V&gt; <span class=\"title\">newNode</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, K key, V value, Node&lt;K,V&gt; e)</span> </span>&#123;</span><br><span class=\"line\">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class=\"line\">        <span class=\"keyword\">new</span> LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class=\"line\">    linkNodeLast(p);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 替换节点</span></span><br><span class=\"line\"><span class=\"function\">Node&lt;K,V&gt; <span class=\"title\">replacementNode</span><span class=\"params\">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class=\"line\">    LinkedHashMap.Entry&lt;K,V&gt; q = (LinkedHashMap.Entry&lt;K,V&gt;)p;</span><br><span class=\"line\">    LinkedHashMap.Entry&lt;K,V&gt; t =</span><br><span class=\"line\">        <span class=\"keyword\">new</span> LinkedHashMap.Entry&lt;K,V&gt;(q.hash, q.key, q.value, next);</span><br><span class=\"line\">    transferLinks(q, t);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> t;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">TreeNode&lt;K,V&gt; <span class=\"title\">newTreeNode</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class=\"line\">    TreeNode&lt;K,V&gt; p = <span class=\"keyword\">new</span> TreeNode&lt;K,V&gt;(hash, key, value, next);</span><br><span class=\"line\">    linkNodeLast(p);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">TreeNode&lt;K,V&gt; <span class=\"title\">replacementTreeNode</span><span class=\"params\">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class=\"line\">    LinkedHashMap.Entry&lt;K,V&gt; q = (LinkedHashMap.Entry&lt;K,V&gt;)p;</span><br><span class=\"line\">    TreeNode&lt;K,V&gt; t = <span class=\"keyword\">new</span> TreeNode&lt;K,V&gt;(q.hash, q.key, q.value, next);</span><br><span class=\"line\">    transferLinks(q, t);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> t;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 将节点从链表中删除</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">afterNodeRemoval</span><span class=\"params\">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class=\"comment\">// unlink</span></span><br><span class=\"line\">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class=\"line\">        (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class=\"line\">    p.before = p.after = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (b == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        head = a;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        b.after = a;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (a == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        tail = b;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        a.before = b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">afterNodeInsertion</span><span class=\"params\">(<span class=\"keyword\">boolean</span> evict)</span> </span>&#123; <span class=\"comment\">// possibly remove eldest</span></span><br><span class=\"line\">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (evict &amp;&amp; (first = head) != <span class=\"keyword\">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class=\"line\">        K key = first.key;</span><br><span class=\"line\">        removeNode(hash(key), key, <span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在get方法之后会调用这个，作用是将头结点，放到尾部，第二个节点编程头结点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">afterNodeAccess</span><span class=\"params\">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class=\"comment\">// move node to last</span></span><br><span class=\"line\">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class=\"line\">        LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class=\"line\">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class=\"line\">        p.after = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (b == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            head = a;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            b.after = a;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            a.before = b;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            last = b;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (last == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            head = p;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            p.before = last;</span><br><span class=\"line\">            last.after = p;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        tail = p;</span><br><span class=\"line\">        ++modCount;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h1 id=\"HashMap\"><a href=\"#HashMap\" class=\"headerlink\" title=\"HashMap\"></a>HashMap</h1><h2 id=\"成员属性\"><a href=\"#成员属性\" class=\"headerlink\" title=\"成员属性\"></a>成员属性</h2><ol>\n<li>Node&lt;K,V&gt;[]table，存储数据的数组</li>\n<li>Set&lt;Map.Entry&lt;K,V&gt;&gt;entrySet，遍历时使用的entrySet</li>\n<li>size，当前大小</li>\n<li>modCount，被非幂等操作改变的次数，entrySet中的ConcurrentModificationException</li>\n<li>threshold，下次resize时候可能需要满足的大小</li>\n<li>loadFactor，负载因子，size &gt; (threshold = capacity * loadFactor)的时候，可能会resize，存在的作用是用于开发人员手动控制resize时具体的数组元素的多少。","more":"</li>\n</ol>\n<h2 id=\"静态属性\"><a href=\"#静态属性\" class=\"headerlink\" title=\"静态属性\"></a>静态属性</h2><ol>\n<li>DEFAULT_INITIAL_CAPACITY，初始大小，16</li>\n<li>MAXIMUM_CAPACITY，最大大小，2的30次方</li>\n<li>DEFAULT_LOAD_FACTOR，初始负载因子，0.75</li>\n<li>TREEIFY_THRESHOLD，treeify时候bin的最小大小，8</li>\n<li>UNTREEIFY_THRESHOLD，untreeify时bin内元素的最小大小，6</li>\n<li>MIN_TREEIFY_CAPACITY，最小treeify的容量，64，大于64才会treeify</li>\n</ol>\n<h2 id=\"主要方法\"><a href=\"#主要方法\" class=\"headerlink\" title=\"主要方法\"></a>主要方法</h2><h3 id=\"hash\"><a href=\"#hash\" class=\"headerlink\" title=\"hash\"></a>hash</h3><p>虽然HashMap的bucket数量最大为Integer.MAX_VALUE，但是绝大部分的Map的bucket数量都是较小的，hash码也只用到低n位。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> h;</span><br><span class=\"line\">    <span class=\"comment\">// 混合原始哈希码的高位和低位，以此来加大低位的随机性</span></span><br><span class=\"line\">    <span class=\"comment\">// 主要还是为了避免用户的hashCode算法有问题，低位散列不均衡</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"get\"><a href=\"#get\" class=\"headerlink\" title=\"get\"></a>get</h3><ol>\n<li>根据key的hash，计算出bucket的位置</li>\n<li>如果bucket为空，返回空</li>\n<li>如果是链表，遍历链表，其中使用equals比较</li>\n<li>如果是红黑树的话，遍历整颗树，其中使用hash比较或者使用Comparable的compareTo方法作比较</li>\n</ol>\n<h3 id=\"put\"><a href=\"#put\" class=\"headerlink\" title=\"put\"></a>put</h3><p>使用尾插法，因为put的过程中需要遍历整个链表，查看是否存在相同的key</p>\n<ol>\n<li>如果table为空，进行resize()</li>\n<li>根据hash计算bucket的index</li>\n<li>取得bucket后，如果是空，构建链表</li>\n<li>如果是链表节点，（如果需要树化，树化，走5），插入至链表头部</li>\n<li>如果是树节点，插入树节点，并且进行平衡</li>\n<li>最后需要resize，进行resize()</li>\n</ol>\n<h3 id=\"resize\"><a href=\"#resize\" class=\"headerlink\" title=\"resize\"></a>resize</h3><p>resize之后大小扩大两倍<br>什么时候会进行resize？进一步观察下来，两种情况下会进行resize。</p>\n<ol>\n<li>某个bin内的元素数量 &gt; TREEIFY_THRESHOLD（8）, 但是总体的Capacity小于MIN_TREEIFY_CAPACITY（64）</li>\n<li>put操作过后，size &gt; (threshold = capacity * loadFactor) 的时候也会。</li>\n</ol>\n<p>resize代码分析：<br>下面这段代码很精妙，巧妙地利用了一个点。<br>假设元素e，oldCapacity，oldPos<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// bucket内链表拆分落在，oldPos以及oldPos + oldCapacity两个新的bucket内</span></span><br><span class=\"line\">e.newPos = e.hash &amp; oldCapacity == <span class=\"number\">1</span> ? oldPos + oldCapacity: oldPos;</span><br><span class=\"line\"><span class=\"comment\">// 下面是jdk代码，将链表做了精妙的拆解，拆成两段</span></span><br><span class=\"line\"><span class=\"comment\">// 两个好处</span></span><br><span class=\"line\"><span class=\"comment\">// 1. 不会倒置旧链表</span></span><br><span class=\"line\"><span class=\"comment\">// 2. 效率更高</span></span><br><span class=\"line\"><span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">    next = e.next;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((e.hash &amp; oldCap) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (loTail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            loHead = e;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            loTail.next = e;</span><br><span class=\"line\">        loTail = e;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (hiTail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            hiHead = e;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            hiTail.next = e;</span><br><span class=\"line\">        hiTail = e;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">while</span> ((e = next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (loTail != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    loTail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    newTab[j] = loHead;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (hiTail != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    hiTail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    newTab[j + oldCap] = hiHead;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"entrySet-keySet\"><a href=\"#entrySet-keySet\" class=\"headerlink\" title=\"entrySet, keySet\"></a>entrySet, keySet</h3><h4 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h4><p>两个都是针对table属性进行foreach循环遍历，但是keySet只能取出key，entrySet能取出Entry。两者都使用了modCount用来保证fail-fast，ConcurrentModificationException。</p>\n<h4 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h4><p>只需要遍历key的话还是推荐使用keySet()，但是不推荐下面这种用法。</p>\n<h1 id=\"ConcurrentHashMap\"><a href=\"#ConcurrentHashMap\" class=\"headerlink\" title=\"ConcurrentHashMap\"></a>ConcurrentHashMap</h1><h2 id=\"jdk7\"><a href=\"#jdk7\" class=\"headerlink\" title=\"jdk7\"></a>jdk7</h2><ol>\n<li>分段锁，内部实现为Segment，继承了ReentrantLock</li>\n<li>默认16段，最大为65536，Segment内部有HashEntry数组，并且采取拉链法处理hash冲突</li>\n<li>扩容的时候针对于Segment内部的HashEntry数组来扩容。</li>\n<li>需要注意的是jdk中有concurrencyLevel（代表Segment数组的大小），在8中已经没什么用处了，只能决定初始容量大小</li>\n</ol>\n<h2 id=\"静态属性-1\"><a href=\"#静态属性-1\" class=\"headerlink\" title=\"静态属性\"></a>静态属性</h2><ol>\n<li>MAXIMUM_CAPACITY，table的最大大小，1&lt;&lt;30</li>\n<li>DEFAULT_CAPACITY，table的大小，16</li>\n<li>MAX_ARRAY_SIZE，元素最大个数，Integer.MAX_VALUE-8</li>\n<li>DEFAULT_CONCURRENCY_LEVEL，向jdk7兼容，16</li>\n<li>LOAD_FACTOR，负载因子，0.75f</li>\n<li>TREEIFY_THRESHOLD，进行树化的元素数量，8</li>\n<li>UNTREEIFY_THRESHOLD，untreeify时bin内元素的最小大小，6</li>\n<li>MIN_TREEIFY_CAPACITY，进行treeify时需要的最要容量要求，64</li>\n<li>MIN_TRANSFER_STRIDE，多线程扩容时候的步长</li>\n<li>RESIZE_STAMP_BITS，</li>\n<li>MAX_RESIZERS，帮助resize的最大线程数</li>\n<li>RESIZE_STAMP_SHIFT，</li>\n<li>MOVED（-1），TREEBIN（-2），RESERVED（-3），hash的常量值，分别代表当前node是ForwardingNode，TreeNode，ReservationNode的hash值。<ul>\n<li>ForwardingNode代表当前bin已经被resize操作过，并且需要当前线程一起帮助resize</li>\n<li>TreeNode代表当前</li>\n<li>Node就是普通的链表节点</li>\n<li>ReservationNode代表当前节点已经被占据（占位符的作用一样），用于后续的mappingFunction操作结束之后再把值塞入进去。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"成员属性-1\"><a href=\"#成员属性-1\" class=\"headerlink\" title=\"成员属性\"></a>成员属性</h2><ol>\n<li>table，存储元素的数组</li>\n<li>nextTable，也是存储元素的数组，只不过该数组在resizing的时候才会被用到。</li>\n<li>baseCount，容器中存储元素的数量值（基本值）</li>\n<li>sizeCtl，代表当前容器中正在进行的关于容量的操作，-1，代表正在被初始化，≤-1，代表正在被（-sizeCtl-1)个线程扩容，≥0代表0.75*capacity</li>\n<li>transferIndex，代表已经或者正在被扩容处理的节点，未被处理的bin的范围为0~transferIndex - 1</li>\n<li>cellsBusy，代表当前正在初始化某个CounterCell，用于控制多个线程不能同时初始化一个CounterCell</li>\n<li>counterCells，计数器，ConcurrentHashMap的真正size是baseCount+CounterCell数组中的计数。具体看LongAdder分析</li>\n<li>keySet，此三个属性为迭代器视图</li>\n<li>values</li>\n<li>entrySet</li>\n</ol>\n<h2 id=\"主要方法-1\"><a href=\"#主要方法-1\" class=\"headerlink\" title=\"主要方法\"></a>主要方法</h2><h3 id=\"resize-1\"><a href=\"#resize-1\" class=\"headerlink\" title=\"resize\"></a>resize</h3><ol>\n<li>需要判断是否是第一个线程，如果是第一个线程还需要进行新建数组操作</li>\n<li>假设当前容量为64，需要扩容到128，一共三个线程扩容</li>\n<li>假设stride是16，capacity是64，两个线程正在参与扩容操作</li>\n<li>第一个线程处理(48,64]这个范围的元素</li>\n<li>第二个线程处理(32,48]</li>\n<li>谁先处理完手里的元素，就将transferIndex减去stride(32-16),就会继续处理(16,32]这个范围一样</li>\n<li>其他线程进来之后，也会减少transferIndex   </li>\n<li>链表的拆分或者树的拆分都是新建了全新的链表或者是树。</li>\n<li>链表会被倒置。树则不会，会再次平衡 </li>\n</ol>\n<h3 id=\"putVal\"><a href=\"#putVal\" class=\"headerlink\" title=\"putVal\"></a>putVal</h3><ol>\n<li>如果未初始化数组，cas操作sizeCtl为-1，初始化数组</li>\n<li>如果未初始化bin（bucket），cas数组元素初始化</li>\n<li>如果当前bin的首元素是ForwardingNode，帮助进行resize</li>\n<li>在数组已经初始化，当前bin未被扩容的情况下，对当前bin的头结点，加锁，进行链表或者红黑树的插入</li>\n<li>插入完成之后判断是否需要进行树化，或者进行resize</li>\n</ol>\n<p><img src=\"/images/putVal1.png\" width=\"60%\" style=\"margin-left:0;\"><br><img src=\"/images/putVal2.png\" width=\"60%\" style=\"margin-left:0;\"></p>\n<h3 id=\"get-1\"><a href=\"#get-1\" class=\"headerlink\" title=\"get\"></a>get</h3><p><img src=\"/images/get1.png\" width=\"60%\" style=\"margin-left:0;\"><br><img src=\"/images/get2.png\" width=\"60%\" style=\"margin-left:0;\"></p>\n<h1 id=\"LinkedHashMap\"><a href=\"#LinkedHashMap\" class=\"headerlink\" title=\"LinkedHashMap\"></a>LinkedHashMap</h1><p>数据倾斜：由于hash算法设计不合理，或者原本输入传不合理，导致hash结果集中度太高</p>\n<h2 id=\"成员属性-2\"><a href=\"#成员属性-2\" class=\"headerlink\" title=\"成员属性\"></a>成员属性</h2><ol>\n<li><code>LinkedHashMap.Entry&lt;K,V&gt; head</code>，表示链表的头结点</li>\n<li><code>LinkedHashMap.Entry&lt;K,V&gt; tail</code>，表示链表的尾节点</li>\n<li><code>boolean accessOrder</code>，表示当前插入节点时候时候需要维护有序<!-- more -->\n</li>\n</ol>\n<h2 id=\"主要方法-2\"><a href=\"#主要方法-2\" class=\"headerlink\" title=\"主要方法\"></a>主要方法</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 将当前节点加入到链表的最后去</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">linkNodeLast</span><span class=\"params\">(LinkedHashMap.Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class=\"line\">    LinkedHashMap.Entry&lt;K,V&gt; last = tail;</span><br><span class=\"line\">    tail = p;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (last == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        head = p;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        p.before = last;</span><br><span class=\"line\">        last.after = p;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将某个节点替换成另外一个</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">transferLinks</span><span class=\"params\">(LinkedHashMap.Entry&lt;K,V&gt; src,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                            LinkedHashMap.Entry&lt;K,V&gt; dst)</span> </span>&#123;</span><br><span class=\"line\">    LinkedHashMap.Entry&lt;K,V&gt; b = dst.before = src.before;</span><br><span class=\"line\">    LinkedHashMap.Entry&lt;K,V&gt; a = dst.after = src.after;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (b == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        head = dst;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        b.after = dst;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (a == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        tail = dst;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        a.before = dst;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 新建节点，可以看出使用的是LinkHashMap.Entry</span></span><br><span class=\"line\"><span class=\"function\">Node&lt;K,V&gt; <span class=\"title\">newNode</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, K key, V value, Node&lt;K,V&gt; e)</span> </span>&#123;</span><br><span class=\"line\">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class=\"line\">        <span class=\"keyword\">new</span> LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class=\"line\">    linkNodeLast(p);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 替换节点</span></span><br><span class=\"line\"><span class=\"function\">Node&lt;K,V&gt; <span class=\"title\">replacementNode</span><span class=\"params\">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class=\"line\">    LinkedHashMap.Entry&lt;K,V&gt; q = (LinkedHashMap.Entry&lt;K,V&gt;)p;</span><br><span class=\"line\">    LinkedHashMap.Entry&lt;K,V&gt; t =</span><br><span class=\"line\">        <span class=\"keyword\">new</span> LinkedHashMap.Entry&lt;K,V&gt;(q.hash, q.key, q.value, next);</span><br><span class=\"line\">    transferLinks(q, t);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> t;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">TreeNode&lt;K,V&gt; <span class=\"title\">newTreeNode</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class=\"line\">    TreeNode&lt;K,V&gt; p = <span class=\"keyword\">new</span> TreeNode&lt;K,V&gt;(hash, key, value, next);</span><br><span class=\"line\">    linkNodeLast(p);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">TreeNode&lt;K,V&gt; <span class=\"title\">replacementTreeNode</span><span class=\"params\">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class=\"line\">    LinkedHashMap.Entry&lt;K,V&gt; q = (LinkedHashMap.Entry&lt;K,V&gt;)p;</span><br><span class=\"line\">    TreeNode&lt;K,V&gt; t = <span class=\"keyword\">new</span> TreeNode&lt;K,V&gt;(q.hash, q.key, q.value, next);</span><br><span class=\"line\">    transferLinks(q, t);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> t;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 将节点从链表中删除</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">afterNodeRemoval</span><span class=\"params\">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class=\"comment\">// unlink</span></span><br><span class=\"line\">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class=\"line\">        (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class=\"line\">    p.before = p.after = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (b == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        head = a;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        b.after = a;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (a == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        tail = b;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        a.before = b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">afterNodeInsertion</span><span class=\"params\">(<span class=\"keyword\">boolean</span> evict)</span> </span>&#123; <span class=\"comment\">// possibly remove eldest</span></span><br><span class=\"line\">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (evict &amp;&amp; (first = head) != <span class=\"keyword\">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class=\"line\">        K key = first.key;</span><br><span class=\"line\">        removeNode(hash(key), key, <span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在get方法之后会调用这个，作用是将头结点，放到尾部，第二个节点编程头结点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">afterNodeAccess</span><span class=\"params\">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class=\"comment\">// move node to last</span></span><br><span class=\"line\">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class=\"line\">        LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class=\"line\">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class=\"line\">        p.after = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (b == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            head = a;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            b.after = a;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            a.before = b;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            last = b;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (last == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            head = p;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            p.before = last;</span><br><span class=\"line\">            last.after = p;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        tail = p;</span><br><span class=\"line\">        ++modCount;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"FutureTask分析","date":"2018-06-23T09:15:27.000Z","toc":true,"_content":"主要用于获取向线程池内提交的任务的执行状态以及执行结果，并且还可以操作任务的执行状态。\n**[`awaitDone`](#get)的设计比较精妙，具体看[get](#get)**\n\n# 成员属性\n1. `Callable<V> callable`，需要执行的任务对象\n2. `Object outcome`，任务的运行结果\n3. `Thread runner`，运行任务的线程\n4. `WaitNode waiters`，表示当前参与等待执行结果的队列（链表），无锁数据结构\n5. `int state`，表示任务的状态\n    - NEW，刚创建，但是还没开始执行\n    - COMPLETING，正在执行过程当中\n    - NORMAL，执行结束，没有异常\n    - EXCEPTIONAL，执行结束，发生异常\n    - CANCELLED，被取消\n    - INTERRUPTING，任务正在被中断\n    - INTERRUPTED，任务中断完成  \n    **可能的状态转换：**\n    1. NEW --> COMPLETETING --> NORMAL\n    2. NEW --> COMPLETEING --> EXCEPTIONAL\n    3. NEW --> CANCEL\n    4. NEW --> INTERRUPTING --> INTERRUPTED\n***\n<!-- more -->\n\n# 主要方法\n## RunnableAdapter\n主要用于将Runnable转换成Callable，比较重要\n```java\nclass RunnableAdapter<T> implements Callable<T> {\n    final Runnable task;\n    final T result;\n\n    RunnableAdapter(Runnable task, T result) {\n        this.task = task;\n        this.result = result;\n    }\n\n    public T call() {\n        task.run();\n        return result;\n    }\n}\n```\n## run && runAndReset\n两个方法的区别在于，一个用于普通线程池（只期望执行一次），一个用于定时任务线程池（会执行多次）。\n代码层面上面唯一的区别**只有对于`set()`的调用**。\n```java\n// 设置异常状态\nprotected void setException(Throwable t) {\n    if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) {\n        outcome = t;\n        UNSAFE.putOrderedInt(this, stateOffset, EXCEPTIONAL); // final state\n        finishCompletion();\n    }\n}\n// 设置正常状态\nprotected void set(V v) {\n    if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) {\n        outcome = v;\n        UNSAFE.putOrderedInt(this, stateOffset, NORMAL); // final state\n        finishCompletion();\n    }\n}\n\n// 正在被中断的话，等待中断过程结束再返回\nprivate void handlePossibleCancellationInterrupt(int s) {\n    if (s == INTERRUPTING) {\n        while (state == INTERRUPTING)\n            Thread.yield(); \n}\n\n// 运行任务\npublic void run() {\n    // 查看状态，防止任务同时被启动两次\n    if (state != NEW ||\n        !UNSAFE.compareAndSwapObject(this, runnerOffset,\n                                        null, Thread.currentThread()))\n        return;\n    try {\n        Callable<V> c = callable;\n        if (c != null && state == NEW) {\n            // 运行结果\n            V result;\n            // 是否成功运行\n            boolean ran;\n            try {\n                result = c.call();\n                ran = true;\n            } catch (Throwable ex) {\n                result = null;\n                ran = false;\n                setException(ex);\n            }\n            // 设置结果\n            if (ran)\n                set(result);\n        }\n    } finally {\n        runner = null;\n        int s = state;\n        if (s >= INTERRUPTING)\n            // 已经结束\n            handlePossibleCancellationInterrupt(s);\n    }\n}\n\n// 运行任务，并且清空所有属性值\nprotected boolean runAndReset() {\n    // 这个就比较奇葩一些，不会更改任何相关状态\n    if (state != NEW ||\n        !UNSAFE.compareAndSwapObject(this, runnerOffset,\n                                        null, Thread.currentThread()))\n        return false;\n    boolean ran = false;\n    int s = state;\n    try {\n        Callable<V> c = callable;\n        if (c != null && s == NEW) {\n            try {\n                c.call(); // don't set result\n                ran = true;\n            } catch (Throwable ex) {\n                setException(ex);\n            }\n        }\n    } finally {\n        runner = null;\n        s = state;\n        if (s >= INTERRUPTING)\n            handlePossibleCancellationInterrupt(s);\n    }\n    return ran && s == NEW;\n}\n```\n## get\n等待任务执行完成，主要是分为以下两种状态\n1. 任务未完成，加入等待链表，执行\n2. 任务已完成（包含异常，以及正常），直接返回结果\n\n```java\n// 任务完成之后会调用这个函数，将所有线程从等待队列放出来\nprivate void finishCompletion() {\n    for (WaitNode q; (q = waiters) != null;) {\n        if (UNSAFE.compareAndSwapObject(this, waitersOffset, q, null)) {\n            for (;;) {\n                Thread t = q.thread;\n                if (t != null) {\n                    q.thread = null;\n                    LockSupport.unpark(t);\n                }\n                WaitNode next = q.next;\n                if (next == null)\n                    break;\n                q.next = null; // unlink to help gc\n                q = next;\n            }\n            break;\n        }\n    }\n    done();\n    callable = null;        // to reduce footprint\n}\n\npublic V get() throws InterruptedException, ExecutionException {\n    int s = state;\n    if (s <= COMPLETING)\n        s = awaitDone(false, 0L);\n    return report(s);\n}\n\npublic V get(long timeout, TimeUnit unit)\n    throws InterruptedException, ExecutionException, TimeoutException {\n    if (unit == null)\n        throw new NullPointerException();\n    int s = state;\n    if (s <= COMPLETING &&\n        (s = awaitDone(true, unit.toNanos(timeout))) <= COMPLETING)\n        throw new TimeoutException();\n    return report(s);\n}\n```\n\n一个比较精妙的地方是在于那么多else，一共三个步骤：\n1. 新建等待队列节点\n2. 加入到等待队列\n3. 进行等待\n这三个步骤之前都加入了是否已经完成的判断，最后才会等待，一共**自旋三次**，进行三次检测。\n```java\nprivate int awaitDone(boolean timed, long nanos)\n    throws InterruptedException {\n    final long deadline = timed ? System.nanoTime() + nanos : 0L;\n    WaitNode q = null;\n    // 表示当前线程是否已经被加入到等待队列当中\n    boolean queued = false;\n    for (;;) {\n        if (Thread.interrupted()) {\n            removeWaiter(q);\n            throw new InterruptedException();\n        }\n\n        int s = state;\n        // 如果不在运行\n        if (s > COMPLETING) {\n            if (q != null)\n                q.thread = null;\n            return s;\n        }\n        // 如果正在运行，自旋\n        else if (s == COMPLETING) // cannot time out yet\n            Thread.yield();\n        // 如果是第一次尽力，添加到等待链表\n        else if (q == null)\n            q = new WaitNode();\n        // 加入到等待队列中\n        else if (!queued)\n            queued = UNSAFE.compareAndSwapObject(this, waitersOffset,\n                                                    q.next = waiters, q);\n        // 下面是等待操作\n        else if (timed) {\n            nanos = deadline - System.nanoTime();\n            if (nanos <= 0L) {\n                removeWaiter(q);\n                return state;\n            }\n            LockSupport.parkNanos(this, nanos);\n        }\n        else\n            LockSupport.park(this);\n    }\n}\n```\n\n## cancel\n```java\npublic boolean cancel(boolean mayInterruptIfRunning) {\n    // 如果是new状态，则更改为Interrrupted或者Cancel状态\n    if (!(state == NEW &&\n            UNSAFE.compareAndSwapInt(this, stateOffset, NEW,\n                mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))\n        return false;\n    try {    \n        // 进行中断当前线程\n        if (mayInterruptIfRunning) {\n            try {\n                Thread t = runner;\n                if (t != null)\n                    t.interrupt();\n            } finally { // final state\n                UNSAFE.putOrderedInt(this, stateOffset, INTERRUPTED);\n            }\n        }\n    } finally {\n        finishCompletion();\n    }\n    return true;\n}\n```","source":"_posts/FutureTask分析.md","raw":"---\ntitle: FutureTask分析\ndate: 2018-06-23 17:15:27\ntags:\n- java\n- 多线程\n- 源码\ncategories:\n- java\n- 多线程\ntoc: true\n---\n主要用于获取向线程池内提交的任务的执行状态以及执行结果，并且还可以操作任务的执行状态。\n**[`awaitDone`](#get)的设计比较精妙，具体看[get](#get)**\n\n# 成员属性\n1. `Callable<V> callable`，需要执行的任务对象\n2. `Object outcome`，任务的运行结果\n3. `Thread runner`，运行任务的线程\n4. `WaitNode waiters`，表示当前参与等待执行结果的队列（链表），无锁数据结构\n5. `int state`，表示任务的状态\n    - NEW，刚创建，但是还没开始执行\n    - COMPLETING，正在执行过程当中\n    - NORMAL，执行结束，没有异常\n    - EXCEPTIONAL，执行结束，发生异常\n    - CANCELLED，被取消\n    - INTERRUPTING，任务正在被中断\n    - INTERRUPTED，任务中断完成  \n    **可能的状态转换：**\n    1. NEW --> COMPLETETING --> NORMAL\n    2. NEW --> COMPLETEING --> EXCEPTIONAL\n    3. NEW --> CANCEL\n    4. NEW --> INTERRUPTING --> INTERRUPTED\n***\n<!-- more -->\n\n# 主要方法\n## RunnableAdapter\n主要用于将Runnable转换成Callable，比较重要\n```java\nclass RunnableAdapter<T> implements Callable<T> {\n    final Runnable task;\n    final T result;\n\n    RunnableAdapter(Runnable task, T result) {\n        this.task = task;\n        this.result = result;\n    }\n\n    public T call() {\n        task.run();\n        return result;\n    }\n}\n```\n## run && runAndReset\n两个方法的区别在于，一个用于普通线程池（只期望执行一次），一个用于定时任务线程池（会执行多次）。\n代码层面上面唯一的区别**只有对于`set()`的调用**。\n```java\n// 设置异常状态\nprotected void setException(Throwable t) {\n    if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) {\n        outcome = t;\n        UNSAFE.putOrderedInt(this, stateOffset, EXCEPTIONAL); // final state\n        finishCompletion();\n    }\n}\n// 设置正常状态\nprotected void set(V v) {\n    if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) {\n        outcome = v;\n        UNSAFE.putOrderedInt(this, stateOffset, NORMAL); // final state\n        finishCompletion();\n    }\n}\n\n// 正在被中断的话，等待中断过程结束再返回\nprivate void handlePossibleCancellationInterrupt(int s) {\n    if (s == INTERRUPTING) {\n        while (state == INTERRUPTING)\n            Thread.yield(); \n}\n\n// 运行任务\npublic void run() {\n    // 查看状态，防止任务同时被启动两次\n    if (state != NEW ||\n        !UNSAFE.compareAndSwapObject(this, runnerOffset,\n                                        null, Thread.currentThread()))\n        return;\n    try {\n        Callable<V> c = callable;\n        if (c != null && state == NEW) {\n            // 运行结果\n            V result;\n            // 是否成功运行\n            boolean ran;\n            try {\n                result = c.call();\n                ran = true;\n            } catch (Throwable ex) {\n                result = null;\n                ran = false;\n                setException(ex);\n            }\n            // 设置结果\n            if (ran)\n                set(result);\n        }\n    } finally {\n        runner = null;\n        int s = state;\n        if (s >= INTERRUPTING)\n            // 已经结束\n            handlePossibleCancellationInterrupt(s);\n    }\n}\n\n// 运行任务，并且清空所有属性值\nprotected boolean runAndReset() {\n    // 这个就比较奇葩一些，不会更改任何相关状态\n    if (state != NEW ||\n        !UNSAFE.compareAndSwapObject(this, runnerOffset,\n                                        null, Thread.currentThread()))\n        return false;\n    boolean ran = false;\n    int s = state;\n    try {\n        Callable<V> c = callable;\n        if (c != null && s == NEW) {\n            try {\n                c.call(); // don't set result\n                ran = true;\n            } catch (Throwable ex) {\n                setException(ex);\n            }\n        }\n    } finally {\n        runner = null;\n        s = state;\n        if (s >= INTERRUPTING)\n            handlePossibleCancellationInterrupt(s);\n    }\n    return ran && s == NEW;\n}\n```\n## get\n等待任务执行完成，主要是分为以下两种状态\n1. 任务未完成，加入等待链表，执行\n2. 任务已完成（包含异常，以及正常），直接返回结果\n\n```java\n// 任务完成之后会调用这个函数，将所有线程从等待队列放出来\nprivate void finishCompletion() {\n    for (WaitNode q; (q = waiters) != null;) {\n        if (UNSAFE.compareAndSwapObject(this, waitersOffset, q, null)) {\n            for (;;) {\n                Thread t = q.thread;\n                if (t != null) {\n                    q.thread = null;\n                    LockSupport.unpark(t);\n                }\n                WaitNode next = q.next;\n                if (next == null)\n                    break;\n                q.next = null; // unlink to help gc\n                q = next;\n            }\n            break;\n        }\n    }\n    done();\n    callable = null;        // to reduce footprint\n}\n\npublic V get() throws InterruptedException, ExecutionException {\n    int s = state;\n    if (s <= COMPLETING)\n        s = awaitDone(false, 0L);\n    return report(s);\n}\n\npublic V get(long timeout, TimeUnit unit)\n    throws InterruptedException, ExecutionException, TimeoutException {\n    if (unit == null)\n        throw new NullPointerException();\n    int s = state;\n    if (s <= COMPLETING &&\n        (s = awaitDone(true, unit.toNanos(timeout))) <= COMPLETING)\n        throw new TimeoutException();\n    return report(s);\n}\n```\n\n一个比较精妙的地方是在于那么多else，一共三个步骤：\n1. 新建等待队列节点\n2. 加入到等待队列\n3. 进行等待\n这三个步骤之前都加入了是否已经完成的判断，最后才会等待，一共**自旋三次**，进行三次检测。\n```java\nprivate int awaitDone(boolean timed, long nanos)\n    throws InterruptedException {\n    final long deadline = timed ? System.nanoTime() + nanos : 0L;\n    WaitNode q = null;\n    // 表示当前线程是否已经被加入到等待队列当中\n    boolean queued = false;\n    for (;;) {\n        if (Thread.interrupted()) {\n            removeWaiter(q);\n            throw new InterruptedException();\n        }\n\n        int s = state;\n        // 如果不在运行\n        if (s > COMPLETING) {\n            if (q != null)\n                q.thread = null;\n            return s;\n        }\n        // 如果正在运行，自旋\n        else if (s == COMPLETING) // cannot time out yet\n            Thread.yield();\n        // 如果是第一次尽力，添加到等待链表\n        else if (q == null)\n            q = new WaitNode();\n        // 加入到等待队列中\n        else if (!queued)\n            queued = UNSAFE.compareAndSwapObject(this, waitersOffset,\n                                                    q.next = waiters, q);\n        // 下面是等待操作\n        else if (timed) {\n            nanos = deadline - System.nanoTime();\n            if (nanos <= 0L) {\n                removeWaiter(q);\n                return state;\n            }\n            LockSupport.parkNanos(this, nanos);\n        }\n        else\n            LockSupport.park(this);\n    }\n}\n```\n\n## cancel\n```java\npublic boolean cancel(boolean mayInterruptIfRunning) {\n    // 如果是new状态，则更改为Interrrupted或者Cancel状态\n    if (!(state == NEW &&\n            UNSAFE.compareAndSwapInt(this, stateOffset, NEW,\n                mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))\n        return false;\n    try {    \n        // 进行中断当前线程\n        if (mayInterruptIfRunning) {\n            try {\n                Thread t = runner;\n                if (t != null)\n                    t.interrupt();\n            } finally { // final state\n                UNSAFE.putOrderedInt(this, stateOffset, INTERRUPTED);\n            }\n        }\n    } finally {\n        finishCompletion();\n    }\n    return true;\n}\n```","slug":"FutureTask分析","published":1,"updated":"2018-06-23T11:02:38.216Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5u1tuu000a1av8r9preyjc","content":"<p>主要用于获取向线程池内提交的任务的执行状态以及执行结果，并且还可以操作任务的执行状态。<br><strong><a href=\"#get\"><code>awaitDone</code></a>的设计比较精妙，具体看<a href=\"#get\">get</a></strong></p>\n<h1 id=\"成员属性\"><a href=\"#成员属性\" class=\"headerlink\" title=\"成员属性\"></a>成员属性</h1><ol>\n<li><code>Callable&lt;V&gt; callable</code>，需要执行的任务对象</li>\n<li><code>Object outcome</code>，任务的运行结果</li>\n<li><code>Thread runner</code>，运行任务的线程</li>\n<li><code>WaitNode waiters</code>，表示当前参与等待执行结果的队列（链表），无锁数据结构</li>\n<li><code>int state</code>，表示任务的状态<ul>\n<li>NEW，刚创建，但是还没开始执行</li>\n<li>COMPLETING，正在执行过程当中</li>\n<li>NORMAL，执行结束，没有异常</li>\n<li>EXCEPTIONAL，执行结束，发生异常</li>\n<li>CANCELLED，被取消</li>\n<li>INTERRUPTING，任务正在被中断</li>\n<li>INTERRUPTED，任务中断完成<br><strong>可能的状态转换：</strong></li>\n</ul>\n<ol>\n<li>NEW –&gt; COMPLETETING –&gt; NORMAL</li>\n<li>NEW –&gt; COMPLETEING –&gt; EXCEPTIONAL</li>\n<li>NEW –&gt; CANCEL</li>\n<li>NEW –&gt; INTERRUPTING –&gt; INTERRUPTED</li>\n</ol>\n</li>\n</ol>\n<hr>\n<a id=\"more\"></a>\n<h1 id=\"主要方法\"><a href=\"#主要方法\" class=\"headerlink\" title=\"主要方法\"></a>主要方法</h1><h2 id=\"RunnableAdapter\"><a href=\"#RunnableAdapter\" class=\"headerlink\" title=\"RunnableAdapter\"></a>RunnableAdapter</h2><p>主要用于将Runnable转换成Callable，比较重要<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RunnableAdapter</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Callable</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Runnable task;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> T result;</span><br><span class=\"line\"></span><br><span class=\"line\">    RunnableAdapter(Runnable task, T result) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.task = task;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.result = result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">call</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        task.run();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"run-amp-amp-runAndReset\"><a href=\"#run-amp-amp-runAndReset\" class=\"headerlink\" title=\"run &amp;&amp; runAndReset\"></a>run &amp;&amp; runAndReset</h2><p>两个方法的区别在于，一个用于普通线程池（只期望执行一次），一个用于定时任务线程池（会执行多次）。<br>代码层面上面唯一的区别<strong>只有对于<code>set()</code>的调用</strong>。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 设置异常状态</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">setException</span><span class=\"params\">(Throwable t)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (UNSAFE.compareAndSwapInt(<span class=\"keyword\">this</span>, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class=\"line\">        outcome = t;</span><br><span class=\"line\">        UNSAFE.putOrderedInt(<span class=\"keyword\">this</span>, stateOffset, EXCEPTIONAL); <span class=\"comment\">// final state</span></span><br><span class=\"line\">        finishCompletion();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 设置正常状态</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(V v)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (UNSAFE.compareAndSwapInt(<span class=\"keyword\">this</span>, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class=\"line\">        outcome = v;</span><br><span class=\"line\">        UNSAFE.putOrderedInt(<span class=\"keyword\">this</span>, stateOffset, NORMAL); <span class=\"comment\">// final state</span></span><br><span class=\"line\">        finishCompletion();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 正在被中断的话，等待中断过程结束再返回</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">handlePossibleCancellationInterrupt</span><span class=\"params\">(<span class=\"keyword\">int</span> s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s == INTERRUPTING) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (state == INTERRUPTING)</span><br><span class=\"line\">            Thread.yield(); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 运行任务</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 查看状态，防止任务同时被启动两次</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state != NEW ||</span><br><span class=\"line\">        !UNSAFE.compareAndSwapObject(<span class=\"keyword\">this</span>, runnerOffset,</span><br><span class=\"line\">                                        <span class=\"keyword\">null</span>, Thread.currentThread()))</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        Callable&lt;V&gt; c = callable;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (c != <span class=\"keyword\">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 运行结果</span></span><br><span class=\"line\">            V result;</span><br><span class=\"line\">            <span class=\"comment\">// 是否成功运行</span></span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> ran;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                result = c.call();</span><br><span class=\"line\">                ran = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Throwable ex) &#123;</span><br><span class=\"line\">                result = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                ran = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                setException(ex);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 设置结果</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ran)</span><br><span class=\"line\">                set(result);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        runner = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> s = state;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s &gt;= INTERRUPTING)</span><br><span class=\"line\">            <span class=\"comment\">// 已经结束</span></span><br><span class=\"line\">            handlePossibleCancellationInterrupt(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 运行任务，并且清空所有属性值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">runAndReset</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这个就比较奇葩一些，不会更改任何相关状态</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state != NEW ||</span><br><span class=\"line\">        !UNSAFE.compareAndSwapObject(<span class=\"keyword\">this</span>, runnerOffset,</span><br><span class=\"line\">                                        <span class=\"keyword\">null</span>, Thread.currentThread()))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> ran = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> s = state;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        Callable&lt;V&gt; c = callable;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (c != <span class=\"keyword\">null</span> &amp;&amp; s == NEW) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                c.call(); <span class=\"comment\">// don't set result</span></span><br><span class=\"line\">                ran = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Throwable ex) &#123;</span><br><span class=\"line\">                setException(ex);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        runner = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        s = state;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s &gt;= INTERRUPTING)</span><br><span class=\"line\">            handlePossibleCancellationInterrupt(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ran &amp;&amp; s == NEW;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"get\"><a href=\"#get\" class=\"headerlink\" title=\"get\"></a>get</h2><p>等待任务执行完成，主要是分为以下两种状态</p>\n<ol>\n<li>任务未完成，加入等待链表，执行</li>\n<li>任务已完成（包含异常，以及正常），直接返回结果</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 任务完成之后会调用这个函数，将所有线程从等待队列放出来</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">finishCompletion</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (WaitNode q; (q = waiters) != <span class=\"keyword\">null</span>;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (UNSAFE.compareAndSwapObject(<span class=\"keyword\">this</span>, waitersOffset, q, <span class=\"keyword\">null</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">                Thread t = q.thread;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (t != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    q.thread = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    LockSupport.unpark(t);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                WaitNode next = q.next;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (next == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                q.next = <span class=\"keyword\">null</span>; <span class=\"comment\">// unlink to help gc</span></span><br><span class=\"line\">                q = next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    done();</span><br><span class=\"line\">    callable = <span class=\"keyword\">null</span>;        <span class=\"comment\">// to reduce footprint</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> s = state;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s &lt;= COMPLETING)</span><br><span class=\"line\">        s = awaitDone(<span class=\"keyword\">false</span>, <span class=\"number\">0L</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> report(s);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">long</span> timeout, TimeUnit unit)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (unit == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> s = state;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s &lt;= COMPLETING &amp;&amp;</span><br><span class=\"line\">        (s = awaitDone(<span class=\"keyword\">true</span>, unit.toNanos(timeout))) &lt;= COMPLETING)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> TimeoutException();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> report(s);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>一个比较精妙的地方是在于那么多else，一共三个步骤：</p>\n<ol>\n<li>新建等待队列节点</li>\n<li>加入到等待队列</li>\n<li>进行等待<br>这三个步骤之前都加入了是否已经完成的判断，最后才会等待，一共<strong>自旋三次</strong>，进行三次检测。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">awaitDone</span><span class=\"params\">(<span class=\"keyword\">boolean</span> timed, <span class=\"keyword\">long</span> nanos)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> deadline = timed ? System.nanoTime() + nanos : <span class=\"number\">0L</span>;</span><br><span class=\"line\">    WaitNode q = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 表示当前线程是否已经被加入到等待队列当中</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> queued = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Thread.interrupted()) &#123;</span><br><span class=\"line\">            removeWaiter(q);</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InterruptedException();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> s = state;</span><br><span class=\"line\">        <span class=\"comment\">// 如果不在运行</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s &gt; COMPLETING) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (q != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                q.thread = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 如果正在运行，自旋</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (s == COMPLETING) <span class=\"comment\">// cannot time out yet</span></span><br><span class=\"line\">            Thread.yield();</span><br><span class=\"line\">        <span class=\"comment\">// 如果是第一次尽力，添加到等待链表</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (q == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            q = <span class=\"keyword\">new</span> WaitNode();</span><br><span class=\"line\">        <span class=\"comment\">// 加入到等待队列中</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!queued)</span><br><span class=\"line\">            queued = UNSAFE.compareAndSwapObject(<span class=\"keyword\">this</span>, waitersOffset,</span><br><span class=\"line\">                                                    q.next = waiters, q);</span><br><span class=\"line\">        <span class=\"comment\">// 下面是等待操作</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (timed) &#123;</span><br><span class=\"line\">            nanos = deadline - System.nanoTime();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nanos &lt;= <span class=\"number\">0L</span>) &#123;</span><br><span class=\"line\">                removeWaiter(q);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> state;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            LockSupport.parkNanos(<span class=\"keyword\">this</span>, nanos);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            LockSupport.park(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"cancel\"><a href=\"#cancel\" class=\"headerlink\" title=\"cancel\"></a>cancel</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">cancel</span><span class=\"params\">(<span class=\"keyword\">boolean</span> mayInterruptIfRunning)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果是new状态，则更改为Interrrupted或者Cancel状态</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!(state == NEW &amp;&amp;</span><br><span class=\"line\">            UNSAFE.compareAndSwapInt(<span class=\"keyword\">this</span>, stateOffset, NEW,</span><br><span class=\"line\">                mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;    </span><br><span class=\"line\">        <span class=\"comment\">// 进行中断当前线程</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mayInterruptIfRunning) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                Thread t = runner;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (t != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    t.interrupt();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123; <span class=\"comment\">// final state</span></span><br><span class=\"line\">                UNSAFE.putOrderedInt(<span class=\"keyword\">this</span>, stateOffset, INTERRUPTED);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        finishCompletion();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>主要用于获取向线程池内提交的任务的执行状态以及执行结果，并且还可以操作任务的执行状态。<br><strong><a href=\"#get\"><code>awaitDone</code></a>的设计比较精妙，具体看<a href=\"#get\">get</a></strong></p>\n<h1 id=\"成员属性\"><a href=\"#成员属性\" class=\"headerlink\" title=\"成员属性\"></a>成员属性</h1><ol>\n<li><code>Callable&lt;V&gt; callable</code>，需要执行的任务对象</li>\n<li><code>Object outcome</code>，任务的运行结果</li>\n<li><code>Thread runner</code>，运行任务的线程</li>\n<li><code>WaitNode waiters</code>，表示当前参与等待执行结果的队列（链表），无锁数据结构</li>\n<li><code>int state</code>，表示任务的状态<ul>\n<li>NEW，刚创建，但是还没开始执行</li>\n<li>COMPLETING，正在执行过程当中</li>\n<li>NORMAL，执行结束，没有异常</li>\n<li>EXCEPTIONAL，执行结束，发生异常</li>\n<li>CANCELLED，被取消</li>\n<li>INTERRUPTING，任务正在被中断</li>\n<li>INTERRUPTED，任务中断完成<br><strong>可能的状态转换：</strong></li>\n</ul>\n<ol>\n<li>NEW –&gt; COMPLETETING –&gt; NORMAL</li>\n<li>NEW –&gt; COMPLETEING –&gt; EXCEPTIONAL</li>\n<li>NEW –&gt; CANCEL</li>\n<li>NEW –&gt; INTERRUPTING –&gt; INTERRUPTED</li>\n</ol>\n</li>\n</ol>\n<hr>","more":"<h1 id=\"主要方法\"><a href=\"#主要方法\" class=\"headerlink\" title=\"主要方法\"></a>主要方法</h1><h2 id=\"RunnableAdapter\"><a href=\"#RunnableAdapter\" class=\"headerlink\" title=\"RunnableAdapter\"></a>RunnableAdapter</h2><p>主要用于将Runnable转换成Callable，比较重要<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RunnableAdapter</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Callable</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Runnable task;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> T result;</span><br><span class=\"line\"></span><br><span class=\"line\">    RunnableAdapter(Runnable task, T result) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.task = task;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.result = result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">call</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        task.run();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"run-amp-amp-runAndReset\"><a href=\"#run-amp-amp-runAndReset\" class=\"headerlink\" title=\"run &amp;&amp; runAndReset\"></a>run &amp;&amp; runAndReset</h2><p>两个方法的区别在于，一个用于普通线程池（只期望执行一次），一个用于定时任务线程池（会执行多次）。<br>代码层面上面唯一的区别<strong>只有对于<code>set()</code>的调用</strong>。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 设置异常状态</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">setException</span><span class=\"params\">(Throwable t)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (UNSAFE.compareAndSwapInt(<span class=\"keyword\">this</span>, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class=\"line\">        outcome = t;</span><br><span class=\"line\">        UNSAFE.putOrderedInt(<span class=\"keyword\">this</span>, stateOffset, EXCEPTIONAL); <span class=\"comment\">// final state</span></span><br><span class=\"line\">        finishCompletion();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 设置正常状态</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(V v)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (UNSAFE.compareAndSwapInt(<span class=\"keyword\">this</span>, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class=\"line\">        outcome = v;</span><br><span class=\"line\">        UNSAFE.putOrderedInt(<span class=\"keyword\">this</span>, stateOffset, NORMAL); <span class=\"comment\">// final state</span></span><br><span class=\"line\">        finishCompletion();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 正在被中断的话，等待中断过程结束再返回</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">handlePossibleCancellationInterrupt</span><span class=\"params\">(<span class=\"keyword\">int</span> s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s == INTERRUPTING) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (state == INTERRUPTING)</span><br><span class=\"line\">            Thread.yield(); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 运行任务</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 查看状态，防止任务同时被启动两次</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state != NEW ||</span><br><span class=\"line\">        !UNSAFE.compareAndSwapObject(<span class=\"keyword\">this</span>, runnerOffset,</span><br><span class=\"line\">                                        <span class=\"keyword\">null</span>, Thread.currentThread()))</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        Callable&lt;V&gt; c = callable;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (c != <span class=\"keyword\">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 运行结果</span></span><br><span class=\"line\">            V result;</span><br><span class=\"line\">            <span class=\"comment\">// 是否成功运行</span></span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> ran;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                result = c.call();</span><br><span class=\"line\">                ran = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Throwable ex) &#123;</span><br><span class=\"line\">                result = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                ran = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                setException(ex);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 设置结果</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ran)</span><br><span class=\"line\">                set(result);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        runner = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> s = state;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s &gt;= INTERRUPTING)</span><br><span class=\"line\">            <span class=\"comment\">// 已经结束</span></span><br><span class=\"line\">            handlePossibleCancellationInterrupt(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 运行任务，并且清空所有属性值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">runAndReset</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这个就比较奇葩一些，不会更改任何相关状态</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state != NEW ||</span><br><span class=\"line\">        !UNSAFE.compareAndSwapObject(<span class=\"keyword\">this</span>, runnerOffset,</span><br><span class=\"line\">                                        <span class=\"keyword\">null</span>, Thread.currentThread()))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> ran = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> s = state;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        Callable&lt;V&gt; c = callable;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (c != <span class=\"keyword\">null</span> &amp;&amp; s == NEW) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                c.call(); <span class=\"comment\">// don't set result</span></span><br><span class=\"line\">                ran = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Throwable ex) &#123;</span><br><span class=\"line\">                setException(ex);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        runner = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        s = state;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s &gt;= INTERRUPTING)</span><br><span class=\"line\">            handlePossibleCancellationInterrupt(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ran &amp;&amp; s == NEW;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"get\"><a href=\"#get\" class=\"headerlink\" title=\"get\"></a>get</h2><p>等待任务执行完成，主要是分为以下两种状态</p>\n<ol>\n<li>任务未完成，加入等待链表，执行</li>\n<li>任务已完成（包含异常，以及正常），直接返回结果</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 任务完成之后会调用这个函数，将所有线程从等待队列放出来</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">finishCompletion</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (WaitNode q; (q = waiters) != <span class=\"keyword\">null</span>;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (UNSAFE.compareAndSwapObject(<span class=\"keyword\">this</span>, waitersOffset, q, <span class=\"keyword\">null</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">                Thread t = q.thread;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (t != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    q.thread = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    LockSupport.unpark(t);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                WaitNode next = q.next;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (next == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                q.next = <span class=\"keyword\">null</span>; <span class=\"comment\">// unlink to help gc</span></span><br><span class=\"line\">                q = next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    done();</span><br><span class=\"line\">    callable = <span class=\"keyword\">null</span>;        <span class=\"comment\">// to reduce footprint</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> s = state;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s &lt;= COMPLETING)</span><br><span class=\"line\">        s = awaitDone(<span class=\"keyword\">false</span>, <span class=\"number\">0L</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> report(s);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">long</span> timeout, TimeUnit unit)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (unit == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> s = state;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s &lt;= COMPLETING &amp;&amp;</span><br><span class=\"line\">        (s = awaitDone(<span class=\"keyword\">true</span>, unit.toNanos(timeout))) &lt;= COMPLETING)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> TimeoutException();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> report(s);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>一个比较精妙的地方是在于那么多else，一共三个步骤：</p>\n<ol>\n<li>新建等待队列节点</li>\n<li>加入到等待队列</li>\n<li>进行等待<br>这三个步骤之前都加入了是否已经完成的判断，最后才会等待，一共<strong>自旋三次</strong>，进行三次检测。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">awaitDone</span><span class=\"params\">(<span class=\"keyword\">boolean</span> timed, <span class=\"keyword\">long</span> nanos)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> deadline = timed ? System.nanoTime() + nanos : <span class=\"number\">0L</span>;</span><br><span class=\"line\">    WaitNode q = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 表示当前线程是否已经被加入到等待队列当中</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> queued = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Thread.interrupted()) &#123;</span><br><span class=\"line\">            removeWaiter(q);</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InterruptedException();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> s = state;</span><br><span class=\"line\">        <span class=\"comment\">// 如果不在运行</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s &gt; COMPLETING) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (q != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                q.thread = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 如果正在运行，自旋</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (s == COMPLETING) <span class=\"comment\">// cannot time out yet</span></span><br><span class=\"line\">            Thread.yield();</span><br><span class=\"line\">        <span class=\"comment\">// 如果是第一次尽力，添加到等待链表</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (q == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            q = <span class=\"keyword\">new</span> WaitNode();</span><br><span class=\"line\">        <span class=\"comment\">// 加入到等待队列中</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!queued)</span><br><span class=\"line\">            queued = UNSAFE.compareAndSwapObject(<span class=\"keyword\">this</span>, waitersOffset,</span><br><span class=\"line\">                                                    q.next = waiters, q);</span><br><span class=\"line\">        <span class=\"comment\">// 下面是等待操作</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (timed) &#123;</span><br><span class=\"line\">            nanos = deadline - System.nanoTime();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nanos &lt;= <span class=\"number\">0L</span>) &#123;</span><br><span class=\"line\">                removeWaiter(q);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> state;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            LockSupport.parkNanos(<span class=\"keyword\">this</span>, nanos);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            LockSupport.park(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"cancel\"><a href=\"#cancel\" class=\"headerlink\" title=\"cancel\"></a>cancel</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">cancel</span><span class=\"params\">(<span class=\"keyword\">boolean</span> mayInterruptIfRunning)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果是new状态，则更改为Interrrupted或者Cancel状态</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!(state == NEW &amp;&amp;</span><br><span class=\"line\">            UNSAFE.compareAndSwapInt(<span class=\"keyword\">this</span>, stateOffset, NEW,</span><br><span class=\"line\">                mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;    </span><br><span class=\"line\">        <span class=\"comment\">// 进行中断当前线程</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mayInterruptIfRunning) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                Thread t = runner;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (t != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    t.interrupt();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123; <span class=\"comment\">// final state</span></span><br><span class=\"line\">                UNSAFE.putOrderedInt(<span class=\"keyword\">this</span>, stateOffset, INTERRUPTED);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        finishCompletion();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"DTS技术调研：分库分表","date":"2018-07-02T00:19:54.000Z","toc":true,"_content":"## 介绍\n定位为轻量级Java框架，在Java的JDBC层提供的额外服务。 它使用客户端直连数据库，以jar包形式提供服务，无需额外部署和依赖，可理解为增强版的JDBC驱动，完全兼容JDBC和各种ORM框架。\n具有以下特性：\n1. 适用于任何基于Java的ORM框架，如：JPA, Hibernate, Mybatis, Spring JDBC Template或直接使用JDBC。\n2. 基于任何第三方的数据库连接池，如：DBCP, C3P0, BoneCP, Druid, HikariCP等。\n3. 支持任意实现JDBC规范的数据库。目前支持MySQL，Oracle，SQLServer和PostgreSQL。\n\n## 问题\n1. 为什么不适用ocean base，tidb：\n    - ob无法使用，虽然架构看起来很不错，但是奈何不开源啊，个人也无法购买。\n    - tidb开源不友好型，单机实测性能过差，问题较多\n2. 为什么选择sharding-jdbc\n    - sharding-jdbc国产的，爱国一下\n    - 没有找到其他合适的框架\n\n<!-- more -->\n## 作用\n在DTS中的作用：\n1. 分库分表，减少单数据库实例压力\n2. 提升sql操作性能（读取速度，插入速度）\n3. 主备，增加数据库的可用性（在没有购买阿里云drds的情况下，非常有用，不会带来额外的成本）\n\n当然也有坏处：\n1. 数据库结构设计上必须要支持分库分表（分库占用一个字段，分表占用一个字段）\n2. 分布式事务的支持比较粗糙：分布式事务性能太慢，所以支持的叫做**最大努力送达型**事务\n3. 批量插入不支持：数据会落在各个库中，分布式事务支持不是很好，所以不支持批量插入\n4. etc，待以后发现\n5. 发现一个，读写分离，没有数据同步功能，需要自己去做数据同步（mysql binlog）\n\n## 使用示例\n### 配置文件\n```yaml\n# mybatis配置不做解释\nmybatis:\n  mapper-locations: classpath*:mapper/*.xml\n  type-aliases-package: io.github.jasonnull.shardingjdbcsample.model\n  configuration:\n      map-underscore-to-camel-case: true\n\n# 以下是sharding-jdbc分库分表配置，加上主从配置例子\nsharding:\n  jdbc:\n    # 多数据源配置\n    datasource:\n      # 数据源名称（逗号后不要加空格）\n      names: ds0,ds0slave0,ds1,ds1slave0\n        # 数据源配置，连接池，驱动，mysql连接url，用户名，密码\n        ds0:\n            type: org.apache.commons.dbcp.BasicDataSource\n            driver-class-name: com.mysql.jdbc.Driver\n            url: jdbc:mysql://localhost:3306/test0\n            username: root\n            password: abcd1234_\n        ds0slave0:\n            type: org.apache.commons.dbcp.BasicDataSource\n            driver-class-name: com.mysql.jdbc.Driver\n            url: jdbc:mysql://localhost:3306/test2\n            username: root\n            password: abcd1234_\n        ds1:\n            type: org.apache.commons.dbcp.BasicDataSource\n            driver-class-name: com.mysql.jdbc.Driver\n            url: jdbc:mysql://localhost:3306/test1\n            username: root\n            password: abcd1234_\n        ds1slave0:\n            type: org.apache.commons.dbcp.BasicDataSource\n            driver-class-name: com.mysql.jdbc.Driver\n            url: jdbc:mysql://localhost:3306/test3\n            username: root\n            password: abcd1234_\n    # 分库分表配置\n    config:\n      sharding:\n        master-slave-rules:\n          # 逻辑名称\n          ds0:\n            # 主库的实际名称\n            master-data-source-name: ds0\n            # 从库的实际名称\n            slave-data-source-names: ds0slave0\n            # 读时候采用轮询\n            loadBalanceAlgorithmType: ROUND_ROBIN\n          ds1:\n            master-data-source-name: ds1\n            slave-data-source-names: ds1slave0\n            loadBalanceAlgorithmType: ROUND_ROBIN\n        default-database-strategy:\n          inline:\n            # 分库的确定列\n            sharding-column: age\n            # age对2取余，用于确定数据源\n            algorithm-expression: ds$->{age % 2}\n        tables:\n          # 确定用户表的分表策略\n          user:\n            # 数据库表确定（ds0.user0,ds0.user1,ds0.user2,ds0.user3,ds1.user0,ds1.user1,ds1.user2,ds1.user3)\n            actual-data-nodes: ds$->{0..1}.user$->{0..3}\n            table-strategy:\n              inline:\n                # 分表的决定列\n                sharding-column: id\n                # 根据id，选择列\n                algorithm-expression: user$->{id % 4}\n            # 分布式主键列（需要是唯一的，内置分布式主键算法）\n            key-generator-column-name: id\n```\n### Dao\n```java\npackage io.github.jasonnull.shardingjdbcsample.dao;\n\nimport io.github.jasonnull.shardingjdbcsample.model.User;\nimport org.apache.ibatis.annotations.Param;\nimport org.springframework.stereotype.Component;\n\nimport java.util.List;\n\n/**\n * Description:\n *\n * @author chenbin，wb-cb306312\n * @create 2018/7/1 17:44\n */\n@Component\npublic interface UserDao {\n    List<User> findAll();\n\n    int deleteAll();\n\n    int insertAll(List<User> users);\n\n    void insert(@Param(\"user\") User users);\n}\n\n```\n### Mapper\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<mapper namespace=\"io.github.jasonnull.shardingjdbcsample.dao.UserDao\">\n    <sql id=\"allFields\">\n        id,\n        name,\n        age,\n        sex\n    </sql>\n\n    <select id=\"findAll\" resultType=\"User\">\n        select\n        <include refid=\"allFields\"/>\n        from user\n    </select>\n\n    <delete id=\"deleteAll\">\n        delete from user\n    </delete>\n\n<!-- 无效\n    <insert id=\"insertAll\" parameterType=\"java.util.List\">\n        insert into user(\n        name,\n        age,\n        sex\n        ) values\n        <foreach collection=\"list\" item=\"user\" separator=\",\">\n            (\n            #{user.name},\n            #{user.age},\n            #{user.sex}\n            )\n        </foreach>\n    </insert> -->\n\n    <insert id=\"insert\" parameterType=\"User\">\n        insert into user(\n            name,\n            age,\n            sex\n        ) values\n        (\n            #{user.name},\n            #{user.age},\n            #{user.sex}\n        )\n    </insert>\n</mapper>\n```","source":"_posts/DTS技术调研：分库分表.md","raw":"---\ntitle: DTS技术调研：分库分表\ndate: 2018-07-02 08:19:54\ntags:\n- 框架\n- sharding-jdbc\ncategories:\n- 框架\ntoc: true\n---\n## 介绍\n定位为轻量级Java框架，在Java的JDBC层提供的额外服务。 它使用客户端直连数据库，以jar包形式提供服务，无需额外部署和依赖，可理解为增强版的JDBC驱动，完全兼容JDBC和各种ORM框架。\n具有以下特性：\n1. 适用于任何基于Java的ORM框架，如：JPA, Hibernate, Mybatis, Spring JDBC Template或直接使用JDBC。\n2. 基于任何第三方的数据库连接池，如：DBCP, C3P0, BoneCP, Druid, HikariCP等。\n3. 支持任意实现JDBC规范的数据库。目前支持MySQL，Oracle，SQLServer和PostgreSQL。\n\n## 问题\n1. 为什么不适用ocean base，tidb：\n    - ob无法使用，虽然架构看起来很不错，但是奈何不开源啊，个人也无法购买。\n    - tidb开源不友好型，单机实测性能过差，问题较多\n2. 为什么选择sharding-jdbc\n    - sharding-jdbc国产的，爱国一下\n    - 没有找到其他合适的框架\n\n<!-- more -->\n## 作用\n在DTS中的作用：\n1. 分库分表，减少单数据库实例压力\n2. 提升sql操作性能（读取速度，插入速度）\n3. 主备，增加数据库的可用性（在没有购买阿里云drds的情况下，非常有用，不会带来额外的成本）\n\n当然也有坏处：\n1. 数据库结构设计上必须要支持分库分表（分库占用一个字段，分表占用一个字段）\n2. 分布式事务的支持比较粗糙：分布式事务性能太慢，所以支持的叫做**最大努力送达型**事务\n3. 批量插入不支持：数据会落在各个库中，分布式事务支持不是很好，所以不支持批量插入\n4. etc，待以后发现\n5. 发现一个，读写分离，没有数据同步功能，需要自己去做数据同步（mysql binlog）\n\n## 使用示例\n### 配置文件\n```yaml\n# mybatis配置不做解释\nmybatis:\n  mapper-locations: classpath*:mapper/*.xml\n  type-aliases-package: io.github.jasonnull.shardingjdbcsample.model\n  configuration:\n      map-underscore-to-camel-case: true\n\n# 以下是sharding-jdbc分库分表配置，加上主从配置例子\nsharding:\n  jdbc:\n    # 多数据源配置\n    datasource:\n      # 数据源名称（逗号后不要加空格）\n      names: ds0,ds0slave0,ds1,ds1slave0\n        # 数据源配置，连接池，驱动，mysql连接url，用户名，密码\n        ds0:\n            type: org.apache.commons.dbcp.BasicDataSource\n            driver-class-name: com.mysql.jdbc.Driver\n            url: jdbc:mysql://localhost:3306/test0\n            username: root\n            password: abcd1234_\n        ds0slave0:\n            type: org.apache.commons.dbcp.BasicDataSource\n            driver-class-name: com.mysql.jdbc.Driver\n            url: jdbc:mysql://localhost:3306/test2\n            username: root\n            password: abcd1234_\n        ds1:\n            type: org.apache.commons.dbcp.BasicDataSource\n            driver-class-name: com.mysql.jdbc.Driver\n            url: jdbc:mysql://localhost:3306/test1\n            username: root\n            password: abcd1234_\n        ds1slave0:\n            type: org.apache.commons.dbcp.BasicDataSource\n            driver-class-name: com.mysql.jdbc.Driver\n            url: jdbc:mysql://localhost:3306/test3\n            username: root\n            password: abcd1234_\n    # 分库分表配置\n    config:\n      sharding:\n        master-slave-rules:\n          # 逻辑名称\n          ds0:\n            # 主库的实际名称\n            master-data-source-name: ds0\n            # 从库的实际名称\n            slave-data-source-names: ds0slave0\n            # 读时候采用轮询\n            loadBalanceAlgorithmType: ROUND_ROBIN\n          ds1:\n            master-data-source-name: ds1\n            slave-data-source-names: ds1slave0\n            loadBalanceAlgorithmType: ROUND_ROBIN\n        default-database-strategy:\n          inline:\n            # 分库的确定列\n            sharding-column: age\n            # age对2取余，用于确定数据源\n            algorithm-expression: ds$->{age % 2}\n        tables:\n          # 确定用户表的分表策略\n          user:\n            # 数据库表确定（ds0.user0,ds0.user1,ds0.user2,ds0.user3,ds1.user0,ds1.user1,ds1.user2,ds1.user3)\n            actual-data-nodes: ds$->{0..1}.user$->{0..3}\n            table-strategy:\n              inline:\n                # 分表的决定列\n                sharding-column: id\n                # 根据id，选择列\n                algorithm-expression: user$->{id % 4}\n            # 分布式主键列（需要是唯一的，内置分布式主键算法）\n            key-generator-column-name: id\n```\n### Dao\n```java\npackage io.github.jasonnull.shardingjdbcsample.dao;\n\nimport io.github.jasonnull.shardingjdbcsample.model.User;\nimport org.apache.ibatis.annotations.Param;\nimport org.springframework.stereotype.Component;\n\nimport java.util.List;\n\n/**\n * Description:\n *\n * @author chenbin，wb-cb306312\n * @create 2018/7/1 17:44\n */\n@Component\npublic interface UserDao {\n    List<User> findAll();\n\n    int deleteAll();\n\n    int insertAll(List<User> users);\n\n    void insert(@Param(\"user\") User users);\n}\n\n```\n### Mapper\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<mapper namespace=\"io.github.jasonnull.shardingjdbcsample.dao.UserDao\">\n    <sql id=\"allFields\">\n        id,\n        name,\n        age,\n        sex\n    </sql>\n\n    <select id=\"findAll\" resultType=\"User\">\n        select\n        <include refid=\"allFields\"/>\n        from user\n    </select>\n\n    <delete id=\"deleteAll\">\n        delete from user\n    </delete>\n\n<!-- 无效\n    <insert id=\"insertAll\" parameterType=\"java.util.List\">\n        insert into user(\n        name,\n        age,\n        sex\n        ) values\n        <foreach collection=\"list\" item=\"user\" separator=\",\">\n            (\n            #{user.name},\n            #{user.age},\n            #{user.sex}\n            )\n        </foreach>\n    </insert> -->\n\n    <insert id=\"insert\" parameterType=\"User\">\n        insert into user(\n            name,\n            age,\n            sex\n        ) values\n        (\n            #{user.name},\n            #{user.age},\n            #{user.sex}\n        )\n    </insert>\n</mapper>\n```","slug":"DTS技术调研：分库分表","published":1,"updated":"2018-07-03T04:53:27.009Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5u1tuw000d1av8do69ij6h","content":"<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>定位为轻量级Java框架，在Java的JDBC层提供的额外服务。 它使用客户端直连数据库，以jar包形式提供服务，无需额外部署和依赖，可理解为增强版的JDBC驱动，完全兼容JDBC和各种ORM框架。<br>具有以下特性：</p>\n<ol>\n<li>适用于任何基于Java的ORM框架，如：JPA, Hibernate, Mybatis, Spring JDBC Template或直接使用JDBC。</li>\n<li>基于任何第三方的数据库连接池，如：DBCP, C3P0, BoneCP, Druid, HikariCP等。</li>\n<li>支持任意实现JDBC规范的数据库。目前支持MySQL，Oracle，SQLServer和PostgreSQL。</li>\n</ol>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><ol>\n<li>为什么不适用ocean base，tidb：<ul>\n<li>ob无法使用，虽然架构看起来很不错，但是奈何不开源啊，个人也无法购买。</li>\n<li>tidb开源不友好型，单机实测性能过差，问题较多</li>\n</ul>\n</li>\n<li>为什么选择sharding-jdbc<ul>\n<li>sharding-jdbc国产的，爱国一下</li>\n<li>没有找到其他合适的框架</li>\n</ul>\n</li>\n</ol>\n<a id=\"more\"></a>\n<h2 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h2><p>在DTS中的作用：</p>\n<ol>\n<li>分库分表，减少单数据库实例压力</li>\n<li>提升sql操作性能（读取速度，插入速度）</li>\n<li>主备，增加数据库的可用性（在没有购买阿里云drds的情况下，非常有用，不会带来额外的成本）</li>\n</ol>\n<p>当然也有坏处：</p>\n<ol>\n<li>数据库结构设计上必须要支持分库分表（分库占用一个字段，分表占用一个字段）</li>\n<li>分布式事务的支持比较粗糙：分布式事务性能太慢，所以支持的叫做<strong>最大努力送达型</strong>事务</li>\n<li>批量插入不支持：数据会落在各个库中，分布式事务支持不是很好，所以不支持批量插入</li>\n<li>etc，待以后发现</li>\n<li>发现一个，读写分离，没有数据同步功能，需要自己去做数据同步（mysql binlog）</li>\n</ol>\n<h2 id=\"使用示例\"><a href=\"#使用示例\" class=\"headerlink\" title=\"使用示例\"></a>使用示例</h2><h3 id=\"配置文件\"><a href=\"#配置文件\" class=\"headerlink\" title=\"配置文件\"></a>配置文件</h3><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># mybatis配置不做解释</span></span><br><span class=\"line\"><span class=\"attr\">mybatis:</span></span><br><span class=\"line\"><span class=\"attr\">  mapper-locations:</span> <span class=\"string\">classpath*:mapper/*.xml</span></span><br><span class=\"line\"><span class=\"attr\">  type-aliases-package:</span> <span class=\"string\">io.github.jasonnull.shardingjdbcsample.model</span></span><br><span class=\"line\"><span class=\"attr\">  configuration:</span></span><br><span class=\"line\"><span class=\"attr\">      map-underscore-to-camel-case:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 以下是sharding-jdbc分库分表配置，加上主从配置例子</span></span><br><span class=\"line\"><span class=\"attr\">sharding:</span></span><br><span class=\"line\"><span class=\"attr\">  jdbc:</span></span><br><span class=\"line\">    <span class=\"comment\"># 多数据源配置</span></span><br><span class=\"line\"><span class=\"attr\">    datasource:</span></span><br><span class=\"line\">      <span class=\"comment\"># 数据源名称（逗号后不要加空格）</span></span><br><span class=\"line\"><span class=\"attr\">      names:</span> <span class=\"string\">ds0,ds0slave0,ds1,ds1slave0</span></span><br><span class=\"line\">        <span class=\"comment\"># 数据源配置，连接池，驱动，mysql连接url，用户名，密码</span></span><br><span class=\"line\"><span class=\"attr\">        ds0:</span></span><br><span class=\"line\"><span class=\"attr\">            type:</span> <span class=\"string\">org.apache.commons.dbcp.BasicDataSource</span></span><br><span class=\"line\"><span class=\"attr\">            driver-class-name:</span> <span class=\"string\">com.mysql.jdbc.Driver</span></span><br><span class=\"line\"><span class=\"attr\">            url:</span> <span class=\"attr\">jdbc:mysql://localhost:3306/test0</span></span><br><span class=\"line\"><span class=\"attr\">            username:</span> <span class=\"string\">root</span></span><br><span class=\"line\"><span class=\"attr\">            password:</span> <span class=\"string\">abcd1234_</span></span><br><span class=\"line\"><span class=\"attr\">        ds0slave0:</span></span><br><span class=\"line\"><span class=\"attr\">            type:</span> <span class=\"string\">org.apache.commons.dbcp.BasicDataSource</span></span><br><span class=\"line\"><span class=\"attr\">            driver-class-name:</span> <span class=\"string\">com.mysql.jdbc.Driver</span></span><br><span class=\"line\"><span class=\"attr\">            url:</span> <span class=\"attr\">jdbc:mysql://localhost:3306/test2</span></span><br><span class=\"line\"><span class=\"attr\">            username:</span> <span class=\"string\">root</span></span><br><span class=\"line\"><span class=\"attr\">            password:</span> <span class=\"string\">abcd1234_</span></span><br><span class=\"line\"><span class=\"attr\">        ds1:</span></span><br><span class=\"line\"><span class=\"attr\">            type:</span> <span class=\"string\">org.apache.commons.dbcp.BasicDataSource</span></span><br><span class=\"line\"><span class=\"attr\">            driver-class-name:</span> <span class=\"string\">com.mysql.jdbc.Driver</span></span><br><span class=\"line\"><span class=\"attr\">            url:</span> <span class=\"attr\">jdbc:mysql://localhost:3306/test1</span></span><br><span class=\"line\"><span class=\"attr\">            username:</span> <span class=\"string\">root</span></span><br><span class=\"line\"><span class=\"attr\">            password:</span> <span class=\"string\">abcd1234_</span></span><br><span class=\"line\"><span class=\"attr\">        ds1slave0:</span></span><br><span class=\"line\"><span class=\"attr\">            type:</span> <span class=\"string\">org.apache.commons.dbcp.BasicDataSource</span></span><br><span class=\"line\"><span class=\"attr\">            driver-class-name:</span> <span class=\"string\">com.mysql.jdbc.Driver</span></span><br><span class=\"line\"><span class=\"attr\">            url:</span> <span class=\"attr\">jdbc:mysql://localhost:3306/test3</span></span><br><span class=\"line\"><span class=\"attr\">            username:</span> <span class=\"string\">root</span></span><br><span class=\"line\"><span class=\"attr\">            password:</span> <span class=\"string\">abcd1234_</span></span><br><span class=\"line\">    <span class=\"comment\"># 分库分表配置</span></span><br><span class=\"line\"><span class=\"attr\">    config:</span></span><br><span class=\"line\"><span class=\"attr\">      sharding:</span></span><br><span class=\"line\"><span class=\"attr\">        master-slave-rules:</span></span><br><span class=\"line\">          <span class=\"comment\"># 逻辑名称</span></span><br><span class=\"line\"><span class=\"attr\">          ds0:</span></span><br><span class=\"line\">            <span class=\"comment\"># 主库的实际名称</span></span><br><span class=\"line\"><span class=\"attr\">            master-data-source-name:</span> <span class=\"string\">ds0</span></span><br><span class=\"line\">            <span class=\"comment\"># 从库的实际名称</span></span><br><span class=\"line\"><span class=\"attr\">            slave-data-source-names:</span> <span class=\"string\">ds0slave0</span></span><br><span class=\"line\">            <span class=\"comment\"># 读时候采用轮询</span></span><br><span class=\"line\"><span class=\"attr\">            loadBalanceAlgorithmType:</span> <span class=\"string\">ROUND_ROBIN</span></span><br><span class=\"line\"><span class=\"attr\">          ds1:</span></span><br><span class=\"line\"><span class=\"attr\">            master-data-source-name:</span> <span class=\"string\">ds1</span></span><br><span class=\"line\"><span class=\"attr\">            slave-data-source-names:</span> <span class=\"string\">ds1slave0</span></span><br><span class=\"line\"><span class=\"attr\">            loadBalanceAlgorithmType:</span> <span class=\"string\">ROUND_ROBIN</span></span><br><span class=\"line\"><span class=\"attr\">        default-database-strategy:</span></span><br><span class=\"line\"><span class=\"attr\">          inline:</span></span><br><span class=\"line\">            <span class=\"comment\"># 分库的确定列</span></span><br><span class=\"line\"><span class=\"attr\">            sharding-column:</span> <span class=\"string\">age</span></span><br><span class=\"line\">            <span class=\"comment\"># age对2取余，用于确定数据源</span></span><br><span class=\"line\"><span class=\"attr\">            algorithm-expression:</span> <span class=\"string\">ds$-&gt;&#123;age</span> <span class=\"string\">%</span> <span class=\"number\">2</span><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"attr\">        tables:</span></span><br><span class=\"line\">          <span class=\"comment\"># 确定用户表的分表策略</span></span><br><span class=\"line\"><span class=\"attr\">          user:</span></span><br><span class=\"line\">            <span class=\"comment\"># 数据库表确定（ds0.user0,ds0.user1,ds0.user2,ds0.user3,ds1.user0,ds1.user1,ds1.user2,ds1.user3)</span></span><br><span class=\"line\"><span class=\"attr\">            actual-data-nodes:</span> <span class=\"string\">ds$-&gt;&#123;0..1&#125;.user$-&gt;&#123;0..3&#125;</span></span><br><span class=\"line\"><span class=\"attr\">            table-strategy:</span></span><br><span class=\"line\"><span class=\"attr\">              inline:</span></span><br><span class=\"line\">                <span class=\"comment\"># 分表的决定列</span></span><br><span class=\"line\"><span class=\"attr\">                sharding-column:</span> <span class=\"string\">id</span></span><br><span class=\"line\">                <span class=\"comment\"># 根据id，选择列</span></span><br><span class=\"line\"><span class=\"attr\">                algorithm-expression:</span> <span class=\"string\">user$-&gt;&#123;id</span> <span class=\"string\">%</span> <span class=\"number\">4</span><span class=\"string\">&#125;</span></span><br><span class=\"line\">            <span class=\"comment\"># 分布式主键列（需要是唯一的，内置分布式主键算法）</span></span><br><span class=\"line\"><span class=\"attr\">            key-generator-column-name:</span> <span class=\"string\">id</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Dao\"><a href=\"#Dao\" class=\"headerlink\" title=\"Dao\"></a>Dao</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> io.github.jasonnull.shardingjdbcsample.dao;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> io.github.jasonnull.shardingjdbcsample.model.User;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.ibatis.annotations.Param;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Component;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Description:</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> chenbin，wb-cb306312</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@create</span> 2018/7/1 17:44</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UserDao</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">List&lt;User&gt; <span class=\"title\">findAll</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">deleteAll</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">insertAll</span><span class=\"params\">(List&lt;User&gt; users)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(@Param(<span class=\"string\">\"user\"</span>)</span> User users)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Mapper\"><a href=\"#Mapper\" class=\"headerlink\" title=\"Mapper\"></a>Mapper</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span><br><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"</span></span><br><span class=\"line\"><span class=\"meta\">        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mapper</span> <span class=\"attr\">namespace</span>=<span class=\"string\">\"io.github.jasonnull.shardingjdbcsample.dao.UserDao\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">sql</span> <span class=\"attr\">id</span>=<span class=\"string\">\"allFields\"</span>&gt;</span></span><br><span class=\"line\">        id,</span><br><span class=\"line\">        name,</span><br><span class=\"line\">        age,</span><br><span class=\"line\">        sex</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">sql</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">id</span>=<span class=\"string\">\"findAll\"</span> <span class=\"attr\">resultType</span>=<span class=\"string\">\"User\"</span>&gt;</span></span><br><span class=\"line\">        select</span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">include</span> <span class=\"attr\">refid</span>=<span class=\"string\">\"allFields\"</span>/&gt;</span></span><br><span class=\"line\">        from user</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">delete</span> <span class=\"attr\">id</span>=<span class=\"string\">\"deleteAll\"</span>&gt;</span></span><br><span class=\"line\">        delete from user</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">delete</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 无效</span></span><br><span class=\"line\"><span class=\"comment\">    &lt;insert id=\"insertAll\" parameterType=\"java.util.List\"&gt;</span></span><br><span class=\"line\"><span class=\"comment\">        insert into user(</span></span><br><span class=\"line\"><span class=\"comment\">        name,</span></span><br><span class=\"line\"><span class=\"comment\">        age,</span></span><br><span class=\"line\"><span class=\"comment\">        sex</span></span><br><span class=\"line\"><span class=\"comment\">        ) values</span></span><br><span class=\"line\"><span class=\"comment\">        &lt;foreach collection=\"list\" item=\"user\" separator=\",\"&gt;</span></span><br><span class=\"line\"><span class=\"comment\">            (</span></span><br><span class=\"line\"><span class=\"comment\">            #&#123;user.name&#125;,</span></span><br><span class=\"line\"><span class=\"comment\">            #&#123;user.age&#125;,</span></span><br><span class=\"line\"><span class=\"comment\">            #&#123;user.sex&#125;</span></span><br><span class=\"line\"><span class=\"comment\">            )</span></span><br><span class=\"line\"><span class=\"comment\">        &lt;/foreach&gt;</span></span><br><span class=\"line\"><span class=\"comment\">    &lt;/insert&gt; --&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">insert</span> <span class=\"attr\">id</span>=<span class=\"string\">\"insert\"</span> <span class=\"attr\">parameterType</span>=<span class=\"string\">\"User\"</span>&gt;</span></span><br><span class=\"line\">        insert into user(</span><br><span class=\"line\">            name,</span><br><span class=\"line\">            age,</span><br><span class=\"line\">            sex</span><br><span class=\"line\">        ) values</span><br><span class=\"line\">        (</span><br><span class=\"line\">            #&#123;user.name&#125;,</span><br><span class=\"line\">            #&#123;user.age&#125;,</span><br><span class=\"line\">            #&#123;user.sex&#125;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">insert</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>定位为轻量级Java框架，在Java的JDBC层提供的额外服务。 它使用客户端直连数据库，以jar包形式提供服务，无需额外部署和依赖，可理解为增强版的JDBC驱动，完全兼容JDBC和各种ORM框架。<br>具有以下特性：</p>\n<ol>\n<li>适用于任何基于Java的ORM框架，如：JPA, Hibernate, Mybatis, Spring JDBC Template或直接使用JDBC。</li>\n<li>基于任何第三方的数据库连接池，如：DBCP, C3P0, BoneCP, Druid, HikariCP等。</li>\n<li>支持任意实现JDBC规范的数据库。目前支持MySQL，Oracle，SQLServer和PostgreSQL。</li>\n</ol>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><ol>\n<li>为什么不适用ocean base，tidb：<ul>\n<li>ob无法使用，虽然架构看起来很不错，但是奈何不开源啊，个人也无法购买。</li>\n<li>tidb开源不友好型，单机实测性能过差，问题较多</li>\n</ul>\n</li>\n<li>为什么选择sharding-jdbc<ul>\n<li>sharding-jdbc国产的，爱国一下</li>\n<li>没有找到其他合适的框架</li>\n</ul>\n</li>\n</ol>","more":"<h2 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h2><p>在DTS中的作用：</p>\n<ol>\n<li>分库分表，减少单数据库实例压力</li>\n<li>提升sql操作性能（读取速度，插入速度）</li>\n<li>主备，增加数据库的可用性（在没有购买阿里云drds的情况下，非常有用，不会带来额外的成本）</li>\n</ol>\n<p>当然也有坏处：</p>\n<ol>\n<li>数据库结构设计上必须要支持分库分表（分库占用一个字段，分表占用一个字段）</li>\n<li>分布式事务的支持比较粗糙：分布式事务性能太慢，所以支持的叫做<strong>最大努力送达型</strong>事务</li>\n<li>批量插入不支持：数据会落在各个库中，分布式事务支持不是很好，所以不支持批量插入</li>\n<li>etc，待以后发现</li>\n<li>发现一个，读写分离，没有数据同步功能，需要自己去做数据同步（mysql binlog）</li>\n</ol>\n<h2 id=\"使用示例\"><a href=\"#使用示例\" class=\"headerlink\" title=\"使用示例\"></a>使用示例</h2><h3 id=\"配置文件\"><a href=\"#配置文件\" class=\"headerlink\" title=\"配置文件\"></a>配置文件</h3><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># mybatis配置不做解释</span></span><br><span class=\"line\"><span class=\"attr\">mybatis:</span></span><br><span class=\"line\"><span class=\"attr\">  mapper-locations:</span> <span class=\"string\">classpath*:mapper/*.xml</span></span><br><span class=\"line\"><span class=\"attr\">  type-aliases-package:</span> <span class=\"string\">io.github.jasonnull.shardingjdbcsample.model</span></span><br><span class=\"line\"><span class=\"attr\">  configuration:</span></span><br><span class=\"line\"><span class=\"attr\">      map-underscore-to-camel-case:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 以下是sharding-jdbc分库分表配置，加上主从配置例子</span></span><br><span class=\"line\"><span class=\"attr\">sharding:</span></span><br><span class=\"line\"><span class=\"attr\">  jdbc:</span></span><br><span class=\"line\">    <span class=\"comment\"># 多数据源配置</span></span><br><span class=\"line\"><span class=\"attr\">    datasource:</span></span><br><span class=\"line\">      <span class=\"comment\"># 数据源名称（逗号后不要加空格）</span></span><br><span class=\"line\"><span class=\"attr\">      names:</span> <span class=\"string\">ds0,ds0slave0,ds1,ds1slave0</span></span><br><span class=\"line\">        <span class=\"comment\"># 数据源配置，连接池，驱动，mysql连接url，用户名，密码</span></span><br><span class=\"line\"><span class=\"attr\">        ds0:</span></span><br><span class=\"line\"><span class=\"attr\">            type:</span> <span class=\"string\">org.apache.commons.dbcp.BasicDataSource</span></span><br><span class=\"line\"><span class=\"attr\">            driver-class-name:</span> <span class=\"string\">com.mysql.jdbc.Driver</span></span><br><span class=\"line\"><span class=\"attr\">            url:</span> <span class=\"attr\">jdbc:mysql://localhost:3306/test0</span></span><br><span class=\"line\"><span class=\"attr\">            username:</span> <span class=\"string\">root</span></span><br><span class=\"line\"><span class=\"attr\">            password:</span> <span class=\"string\">abcd1234_</span></span><br><span class=\"line\"><span class=\"attr\">        ds0slave0:</span></span><br><span class=\"line\"><span class=\"attr\">            type:</span> <span class=\"string\">org.apache.commons.dbcp.BasicDataSource</span></span><br><span class=\"line\"><span class=\"attr\">            driver-class-name:</span> <span class=\"string\">com.mysql.jdbc.Driver</span></span><br><span class=\"line\"><span class=\"attr\">            url:</span> <span class=\"attr\">jdbc:mysql://localhost:3306/test2</span></span><br><span class=\"line\"><span class=\"attr\">            username:</span> <span class=\"string\">root</span></span><br><span class=\"line\"><span class=\"attr\">            password:</span> <span class=\"string\">abcd1234_</span></span><br><span class=\"line\"><span class=\"attr\">        ds1:</span></span><br><span class=\"line\"><span class=\"attr\">            type:</span> <span class=\"string\">org.apache.commons.dbcp.BasicDataSource</span></span><br><span class=\"line\"><span class=\"attr\">            driver-class-name:</span> <span class=\"string\">com.mysql.jdbc.Driver</span></span><br><span class=\"line\"><span class=\"attr\">            url:</span> <span class=\"attr\">jdbc:mysql://localhost:3306/test1</span></span><br><span class=\"line\"><span class=\"attr\">            username:</span> <span class=\"string\">root</span></span><br><span class=\"line\"><span class=\"attr\">            password:</span> <span class=\"string\">abcd1234_</span></span><br><span class=\"line\"><span class=\"attr\">        ds1slave0:</span></span><br><span class=\"line\"><span class=\"attr\">            type:</span> <span class=\"string\">org.apache.commons.dbcp.BasicDataSource</span></span><br><span class=\"line\"><span class=\"attr\">            driver-class-name:</span> <span class=\"string\">com.mysql.jdbc.Driver</span></span><br><span class=\"line\"><span class=\"attr\">            url:</span> <span class=\"attr\">jdbc:mysql://localhost:3306/test3</span></span><br><span class=\"line\"><span class=\"attr\">            username:</span> <span class=\"string\">root</span></span><br><span class=\"line\"><span class=\"attr\">            password:</span> <span class=\"string\">abcd1234_</span></span><br><span class=\"line\">    <span class=\"comment\"># 分库分表配置</span></span><br><span class=\"line\"><span class=\"attr\">    config:</span></span><br><span class=\"line\"><span class=\"attr\">      sharding:</span></span><br><span class=\"line\"><span class=\"attr\">        master-slave-rules:</span></span><br><span class=\"line\">          <span class=\"comment\"># 逻辑名称</span></span><br><span class=\"line\"><span class=\"attr\">          ds0:</span></span><br><span class=\"line\">            <span class=\"comment\"># 主库的实际名称</span></span><br><span class=\"line\"><span class=\"attr\">            master-data-source-name:</span> <span class=\"string\">ds0</span></span><br><span class=\"line\">            <span class=\"comment\"># 从库的实际名称</span></span><br><span class=\"line\"><span class=\"attr\">            slave-data-source-names:</span> <span class=\"string\">ds0slave0</span></span><br><span class=\"line\">            <span class=\"comment\"># 读时候采用轮询</span></span><br><span class=\"line\"><span class=\"attr\">            loadBalanceAlgorithmType:</span> <span class=\"string\">ROUND_ROBIN</span></span><br><span class=\"line\"><span class=\"attr\">          ds1:</span></span><br><span class=\"line\"><span class=\"attr\">            master-data-source-name:</span> <span class=\"string\">ds1</span></span><br><span class=\"line\"><span class=\"attr\">            slave-data-source-names:</span> <span class=\"string\">ds1slave0</span></span><br><span class=\"line\"><span class=\"attr\">            loadBalanceAlgorithmType:</span> <span class=\"string\">ROUND_ROBIN</span></span><br><span class=\"line\"><span class=\"attr\">        default-database-strategy:</span></span><br><span class=\"line\"><span class=\"attr\">          inline:</span></span><br><span class=\"line\">            <span class=\"comment\"># 分库的确定列</span></span><br><span class=\"line\"><span class=\"attr\">            sharding-column:</span> <span class=\"string\">age</span></span><br><span class=\"line\">            <span class=\"comment\"># age对2取余，用于确定数据源</span></span><br><span class=\"line\"><span class=\"attr\">            algorithm-expression:</span> <span class=\"string\">ds$-&gt;&#123;age</span> <span class=\"string\">%</span> <span class=\"number\">2</span><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"attr\">        tables:</span></span><br><span class=\"line\">          <span class=\"comment\"># 确定用户表的分表策略</span></span><br><span class=\"line\"><span class=\"attr\">          user:</span></span><br><span class=\"line\">            <span class=\"comment\"># 数据库表确定（ds0.user0,ds0.user1,ds0.user2,ds0.user3,ds1.user0,ds1.user1,ds1.user2,ds1.user3)</span></span><br><span class=\"line\"><span class=\"attr\">            actual-data-nodes:</span> <span class=\"string\">ds$-&gt;&#123;0..1&#125;.user$-&gt;&#123;0..3&#125;</span></span><br><span class=\"line\"><span class=\"attr\">            table-strategy:</span></span><br><span class=\"line\"><span class=\"attr\">              inline:</span></span><br><span class=\"line\">                <span class=\"comment\"># 分表的决定列</span></span><br><span class=\"line\"><span class=\"attr\">                sharding-column:</span> <span class=\"string\">id</span></span><br><span class=\"line\">                <span class=\"comment\"># 根据id，选择列</span></span><br><span class=\"line\"><span class=\"attr\">                algorithm-expression:</span> <span class=\"string\">user$-&gt;&#123;id</span> <span class=\"string\">%</span> <span class=\"number\">4</span><span class=\"string\">&#125;</span></span><br><span class=\"line\">            <span class=\"comment\"># 分布式主键列（需要是唯一的，内置分布式主键算法）</span></span><br><span class=\"line\"><span class=\"attr\">            key-generator-column-name:</span> <span class=\"string\">id</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Dao\"><a href=\"#Dao\" class=\"headerlink\" title=\"Dao\"></a>Dao</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> io.github.jasonnull.shardingjdbcsample.dao;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> io.github.jasonnull.shardingjdbcsample.model.User;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.ibatis.annotations.Param;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Component;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Description:</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> chenbin，wb-cb306312</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@create</span> 2018/7/1 17:44</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UserDao</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">List&lt;User&gt; <span class=\"title\">findAll</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">deleteAll</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">insertAll</span><span class=\"params\">(List&lt;User&gt; users)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(@Param(<span class=\"string\">\"user\"</span>)</span> User users)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Mapper\"><a href=\"#Mapper\" class=\"headerlink\" title=\"Mapper\"></a>Mapper</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span><br><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"</span></span><br><span class=\"line\"><span class=\"meta\">        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mapper</span> <span class=\"attr\">namespace</span>=<span class=\"string\">\"io.github.jasonnull.shardingjdbcsample.dao.UserDao\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">sql</span> <span class=\"attr\">id</span>=<span class=\"string\">\"allFields\"</span>&gt;</span></span><br><span class=\"line\">        id,</span><br><span class=\"line\">        name,</span><br><span class=\"line\">        age,</span><br><span class=\"line\">        sex</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">sql</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">id</span>=<span class=\"string\">\"findAll\"</span> <span class=\"attr\">resultType</span>=<span class=\"string\">\"User\"</span>&gt;</span></span><br><span class=\"line\">        select</span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">include</span> <span class=\"attr\">refid</span>=<span class=\"string\">\"allFields\"</span>/&gt;</span></span><br><span class=\"line\">        from user</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">delete</span> <span class=\"attr\">id</span>=<span class=\"string\">\"deleteAll\"</span>&gt;</span></span><br><span class=\"line\">        delete from user</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">delete</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 无效</span></span><br><span class=\"line\"><span class=\"comment\">    &lt;insert id=\"insertAll\" parameterType=\"java.util.List\"&gt;</span></span><br><span class=\"line\"><span class=\"comment\">        insert into user(</span></span><br><span class=\"line\"><span class=\"comment\">        name,</span></span><br><span class=\"line\"><span class=\"comment\">        age,</span></span><br><span class=\"line\"><span class=\"comment\">        sex</span></span><br><span class=\"line\"><span class=\"comment\">        ) values</span></span><br><span class=\"line\"><span class=\"comment\">        &lt;foreach collection=\"list\" item=\"user\" separator=\",\"&gt;</span></span><br><span class=\"line\"><span class=\"comment\">            (</span></span><br><span class=\"line\"><span class=\"comment\">            #&#123;user.name&#125;,</span></span><br><span class=\"line\"><span class=\"comment\">            #&#123;user.age&#125;,</span></span><br><span class=\"line\"><span class=\"comment\">            #&#123;user.sex&#125;</span></span><br><span class=\"line\"><span class=\"comment\">            )</span></span><br><span class=\"line\"><span class=\"comment\">        &lt;/foreach&gt;</span></span><br><span class=\"line\"><span class=\"comment\">    &lt;/insert&gt; --&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">insert</span> <span class=\"attr\">id</span>=<span class=\"string\">\"insert\"</span> <span class=\"attr\">parameterType</span>=<span class=\"string\">\"User\"</span>&gt;</span></span><br><span class=\"line\">        insert into user(</span><br><span class=\"line\">            name,</span><br><span class=\"line\">            age,</span><br><span class=\"line\">            sex</span><br><span class=\"line\">        ) values</span><br><span class=\"line\">        (</span><br><span class=\"line\">            #&#123;user.name&#125;,</span><br><span class=\"line\">            #&#123;user.age&#125;,</span><br><span class=\"line\">            #&#123;user.sex&#125;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">insert</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>"},{"title":"List分析","date":"2018-06-23T10:38:29.000Z","toc":true,"_content":"# ArrayList\n## 静态属性\n1. DEFAULT_CAPACITY，默认大小，10\n2. EMPTY_ELEMENTDATA，初始数组，空\n3. DEFAULTCAPACITY_EMPTY_ELEMENTDATA，默认大小时使用的数组，空\n4. MAX_ARRAY_SIZE，elementData最大大小，这边有歧义，数组最大大小还是Integer.MAX_VALUE\n\n## 成员属性\n1. elementData，存储元素的数组\n2. size，大小\n3. modCount，操作次数（在AbstractList里面），每次进行非幂等操作的时候，都会增加这个值\n<!-- more -->\n\n## 特点\n1. 大小增长是1.5倍，默认大小时10\n2. indexOf中使用了equals\n3. 内部大量使用**Array.copyOf()** [创建一个全新数组], System.arraycopy() [数组之间元素的复制]\n4. clone方法内部使用了Arrays.copyOf()\n5. add(int index, E element)中用了System.arraycopy进行数组之间的复制\n6. clear()只是清除了引用，但是没有回收数组空间\n7. batchRemove()，里面有一个经典算法（如何在O(n)的时间范围内移除移除A数组中包含B数组的所有元素）\n8. modCount在ListIterator和Iterator中用于保证failfast（ConcurrentModificationException)\n9. ArrayListSpliterator用于并行分割计算\n10. List有两种迭代器，Iterator和ListIterator（可以前后迭代）\n11. SubList返回的不是一个全新的List，而是对原有List的一个引用（坑点）\n12. modCount是带有局限性的\n\n## 适用场景\n适用于可动态扩容的数组\n\n## 主要方法\n### grow(扩容)\n```java\nprivate void grow(int minCapacity) {\n    int oldCapacity = elementData.length;\n    // 1.5倍扩容\n    int newCapacity = oldCapacity + (oldCapacity >> 1);\n    if (newCapacity - minCapacity < 0)\n        newCapacity = minCapacity;\n    if (newCapacity - MAX_ARRAY_SIZE > 0)\n        newCapacity = hugeCapacity(minCapacity);\n    elementData = Arrays.copyOf(elementData, newCapacity);\n}\n```\n### contains\n\b用==或者equals做比较\n```java\n// 采用equals做比较\npublic boolean contains(Object o) {\n    return indexOf(o) >= 0;\n}\npublic int indexOf(Object o) {\n    if (o == null) {\n        for (int i = 0; i < size; i++)\n            if (elementData[i]==null)\n                return i;\n    } else {\n        for (int i = 0; i < size; i++)\n            if (o.equals(elementData[i]))\n                return i;\n    }\n    return -1;\n}\n```\n### add\n```java\npublic boolean add(E e) {\n    ensureCapacityInternal(size + 1);  // Increments modCount!!\n    elementData[size++] = e;\n    return true;\n}\n```\n### subList\n很多人认为subList()返回的是一个全新的list，但**不是**。\n```java\nprivate class SubList extends AbstractList<E> implements RandomAccess {\n    private final AbstractList<E> parent;\n    private final int parentOffset;\n    private final int offset;\n    int size;\n\n    SubList(AbstractList<E> parent,\n            int offset, int fromIndex, int toIndex) {\n        this.parent = parent;\n        this.parentOffset = fromIndex;\n        this.offset = offset + fromIndex;\n        this.size = toIndex - fromIndex;\n        this.modCount = ArrayList.this.modCount;\n    }\n\n    // 会修改原有的List\n    public E set(int index, E e) {\n        rangeCheck(index);\n        checkForComodification();\n        E oldValue = ArrayList.this.elementData(offset + index);\n        ArrayList.this.elementData[offset + index] = e;\n        return oldValue;\n    }\n}\n```\n### spliterator\n可以使用此对list做切割，然后并行的对每个部分做操作\n```java\nstatic final class ArrayListSpliterator<E> implements Spliterator<E> {\n    private final ArrayList<E> list;\n    // fence\n    private int index; // current index, modified on advance/split\n    private int fence; // -1 until used; then one past last index\n    private int expectedModCount; // initialized when fence set\n\n    ArrayListSpliterator(ArrayList<E> list, int origin, int fence,\n                            int expectedModCount) {\n        this.list = list; // OK if null unless traversed\n        this.index = origin;\n        this.fence = fence;\n        this.expectedModCount = expectedModCount;\n    }\n\n    private int getFence() { // initialize fence to size on first use\n        int hi; // (a specialized variant appears in method forEach)\n        ArrayList<E> lst;\n        if ((hi = fence) < 0) {\n            if ((lst = list) == null)\n                hi = fence = 0;\n            else {\n                expectedModCount = lst.modCount;\n                hi = fence = lst.size;\n            }\n        }\n        return hi;\n    }\n\n    public ArrayListSpliterator<E> trySplit() {\n        // 将现有的范围[index, fence)，分为\n        // [index, (index + fence)/2) 和 [(index + fence)/2,fence]\n        int hi = getFence(), lo = index, mid = (lo + hi) >>> 1;\n        return (lo >= mid) ? null : // divide range in half unless too small\n            new ArrayListSpliterator<E>(list, lo, index = mid,\n                                        expectedModCount);\n    }\n}\n```\n### equals和hashCode\nequals需要逐个元素的比较，hashCode会对所有的元素做hashCode\n\n---\n# LinkedList\n不做详细分析，只写特点。\n## 特点\n1. 底层数据结构是链表\n2. 插入删除复杂度为O(1)，查找复杂度为O(n)\n3. 适用于那种插入删除频繁的地方，可用于构建可变长队列，栈\n\n---\n# CopyOnWriteArrayList\n## 静态属性\n无\n## 成员属性\n1. array\nObject数组，\u001b用于存储元素\n2. lock\n可重入锁，用于控制非幂等操作的\u001b并发\u001b安全性问题。\n## 特点\n1. 初始长度为0，每次做非幂等操作（写入，删除）的时候都会创建一个全新的数组\n2. 写入时候复制，即使每次长度只增加1（这样有一个好处是遍历的时候不会出现问题）\n3. 内部大量使用Arrays.copyOf()[整段复制]和System.arrayCopy()[分段复制，native函数]\n## 使用场景\n特别适合那种写入少，读取量大的情况。\n缺点是写入特别耗时间。\n## 主要方法\n### get\n```java\nprivate E get(Object[] a, int index) {\n    return (E) a[index];\n}\n// getArray返回的是当前array\npublic E get(int index) {\n    return get(getArray(), index);\n}\n```\n### add\n```java\npublic boolean add(E e) {\n    final ReentrantLock lock = this.lock;\n    // 加锁\n    lock.lock();\n    try {\n        Object[] elements = getArray();\n        int len = elements.length;\n        // 复制整个数组\n        Object[] newElements = Arrays.copyOf(elements, len + 1);\n        newElements[len] = e;\n        setArray(newElements);\n        return true;\n    } finally {\n        lock.unlock();\n    }\n}\n```\n### remove\n```java\nprivate boolean remove(Object o, Object[] snapshot, int index) {\n    final ReentrantLock lock = this.lock;\n    lock.lock();\n    try {\n        Object[] current = getArray();\n        int len = current.length;\n        // snapshot不等于current，代表当前index可能已经过期了，需要再重新寻找\n        // 至于为什么这么做，主要是为了减少加锁时间，能够提升并发操作的性能\n        if (snapshot != current) findIndex: {\n            int prefix = Math.min(index, len);\n            for (int i = 0; i < prefix; i++) {\n                if (current[i] != snapshot[i] && eq(o, current[i])) {\n                    index = i;\n                    break findIndex;\n                }\n            }\n            if (index >= len)\n                return false;\n            if (current[index] == o)\n                break findIndex;\n            index = indexOf(o, current, index, len);\n            if (index < 0)\n                return false;\n        }\n        Object[] newElements = new Object[len - 1];\n        System.arraycopy(current, 0, newElements, 0, index);\n        System.arraycopy(current, index + 1,\n                            newElements, index,\n                            len - index - 1);\n        setArray(newElements);\n        return true;\n    } finally {\n        lock.unlock();\n    }\n}\n```\n\n### toArray\n```java\n// 返回一个全新的数组\npublic Object[] toArray() {\n    Object[] elements = getArray();\n    return Arrays.copyOf(elements, elements.length);\n}\n// \b原数组长度不够，创建新数组，返回新数组的信用\npublic <T> T[] toArray(T a[]) {\n    Object[] elements = getArray();\n    int len = elements.length;\n    if (a.length < len)\n        return (T[]) Arrays.copyOf(elements, len, a.getClass());\n    else {\n        System.arraycopy(elements, 0, a, 0, len);\n        if (a.length > len)\n            a[len] = null;\n        return a;\n    }\n}\n```\n### equals和hashCode\n同ArrayList\n\n---\n# Vector\njdk1.2推出的，使用synchronized加锁保证线程安全性\n\n# Stack\n继承于\bVector，也是线程安全的，实现了\b栈而已。\n\n# ListIterator\n和Iterator的主要区别是多了previous，hasPrevious，nextIndex，set和add方法","source":"_posts/List分析.md","raw":"---\ntitle: List分析\ndate: 2018-06-23 18:38:29\ntags:\n- java\n- 集合\n- 源码\ncategories:\n- java\n- 集合\ntoc: true\n---\n# ArrayList\n## 静态属性\n1. DEFAULT_CAPACITY，默认大小，10\n2. EMPTY_ELEMENTDATA，初始数组，空\n3. DEFAULTCAPACITY_EMPTY_ELEMENTDATA，默认大小时使用的数组，空\n4. MAX_ARRAY_SIZE，elementData最大大小，这边有歧义，数组最大大小还是Integer.MAX_VALUE\n\n## 成员属性\n1. elementData，存储元素的数组\n2. size，大小\n3. modCount，操作次数（在AbstractList里面），每次进行非幂等操作的时候，都会增加这个值\n<!-- more -->\n\n## 特点\n1. 大小增长是1.5倍，默认大小时10\n2. indexOf中使用了equals\n3. 内部大量使用**Array.copyOf()** [创建一个全新数组], System.arraycopy() [数组之间元素的复制]\n4. clone方法内部使用了Arrays.copyOf()\n5. add(int index, E element)中用了System.arraycopy进行数组之间的复制\n6. clear()只是清除了引用，但是没有回收数组空间\n7. batchRemove()，里面有一个经典算法（如何在O(n)的时间范围内移除移除A数组中包含B数组的所有元素）\n8. modCount在ListIterator和Iterator中用于保证failfast（ConcurrentModificationException)\n9. ArrayListSpliterator用于并行分割计算\n10. List有两种迭代器，Iterator和ListIterator（可以前后迭代）\n11. SubList返回的不是一个全新的List，而是对原有List的一个引用（坑点）\n12. modCount是带有局限性的\n\n## 适用场景\n适用于可动态扩容的数组\n\n## 主要方法\n### grow(扩容)\n```java\nprivate void grow(int minCapacity) {\n    int oldCapacity = elementData.length;\n    // 1.5倍扩容\n    int newCapacity = oldCapacity + (oldCapacity >> 1);\n    if (newCapacity - minCapacity < 0)\n        newCapacity = minCapacity;\n    if (newCapacity - MAX_ARRAY_SIZE > 0)\n        newCapacity = hugeCapacity(minCapacity);\n    elementData = Arrays.copyOf(elementData, newCapacity);\n}\n```\n### contains\n\b用==或者equals做比较\n```java\n// 采用equals做比较\npublic boolean contains(Object o) {\n    return indexOf(o) >= 0;\n}\npublic int indexOf(Object o) {\n    if (o == null) {\n        for (int i = 0; i < size; i++)\n            if (elementData[i]==null)\n                return i;\n    } else {\n        for (int i = 0; i < size; i++)\n            if (o.equals(elementData[i]))\n                return i;\n    }\n    return -1;\n}\n```\n### add\n```java\npublic boolean add(E e) {\n    ensureCapacityInternal(size + 1);  // Increments modCount!!\n    elementData[size++] = e;\n    return true;\n}\n```\n### subList\n很多人认为subList()返回的是一个全新的list，但**不是**。\n```java\nprivate class SubList extends AbstractList<E> implements RandomAccess {\n    private final AbstractList<E> parent;\n    private final int parentOffset;\n    private final int offset;\n    int size;\n\n    SubList(AbstractList<E> parent,\n            int offset, int fromIndex, int toIndex) {\n        this.parent = parent;\n        this.parentOffset = fromIndex;\n        this.offset = offset + fromIndex;\n        this.size = toIndex - fromIndex;\n        this.modCount = ArrayList.this.modCount;\n    }\n\n    // 会修改原有的List\n    public E set(int index, E e) {\n        rangeCheck(index);\n        checkForComodification();\n        E oldValue = ArrayList.this.elementData(offset + index);\n        ArrayList.this.elementData[offset + index] = e;\n        return oldValue;\n    }\n}\n```\n### spliterator\n可以使用此对list做切割，然后并行的对每个部分做操作\n```java\nstatic final class ArrayListSpliterator<E> implements Spliterator<E> {\n    private final ArrayList<E> list;\n    // fence\n    private int index; // current index, modified on advance/split\n    private int fence; // -1 until used; then one past last index\n    private int expectedModCount; // initialized when fence set\n\n    ArrayListSpliterator(ArrayList<E> list, int origin, int fence,\n                            int expectedModCount) {\n        this.list = list; // OK if null unless traversed\n        this.index = origin;\n        this.fence = fence;\n        this.expectedModCount = expectedModCount;\n    }\n\n    private int getFence() { // initialize fence to size on first use\n        int hi; // (a specialized variant appears in method forEach)\n        ArrayList<E> lst;\n        if ((hi = fence) < 0) {\n            if ((lst = list) == null)\n                hi = fence = 0;\n            else {\n                expectedModCount = lst.modCount;\n                hi = fence = lst.size;\n            }\n        }\n        return hi;\n    }\n\n    public ArrayListSpliterator<E> trySplit() {\n        // 将现有的范围[index, fence)，分为\n        // [index, (index + fence)/2) 和 [(index + fence)/2,fence]\n        int hi = getFence(), lo = index, mid = (lo + hi) >>> 1;\n        return (lo >= mid) ? null : // divide range in half unless too small\n            new ArrayListSpliterator<E>(list, lo, index = mid,\n                                        expectedModCount);\n    }\n}\n```\n### equals和hashCode\nequals需要逐个元素的比较，hashCode会对所有的元素做hashCode\n\n---\n# LinkedList\n不做详细分析，只写特点。\n## 特点\n1. 底层数据结构是链表\n2. 插入删除复杂度为O(1)，查找复杂度为O(n)\n3. 适用于那种插入删除频繁的地方，可用于构建可变长队列，栈\n\n---\n# CopyOnWriteArrayList\n## 静态属性\n无\n## 成员属性\n1. array\nObject数组，\u001b用于存储元素\n2. lock\n可重入锁，用于控制非幂等操作的\u001b并发\u001b安全性问题。\n## 特点\n1. 初始长度为0，每次做非幂等操作（写入，删除）的时候都会创建一个全新的数组\n2. 写入时候复制，即使每次长度只增加1（这样有一个好处是遍历的时候不会出现问题）\n3. 内部大量使用Arrays.copyOf()[整段复制]和System.arrayCopy()[分段复制，native函数]\n## 使用场景\n特别适合那种写入少，读取量大的情况。\n缺点是写入特别耗时间。\n## 主要方法\n### get\n```java\nprivate E get(Object[] a, int index) {\n    return (E) a[index];\n}\n// getArray返回的是当前array\npublic E get(int index) {\n    return get(getArray(), index);\n}\n```\n### add\n```java\npublic boolean add(E e) {\n    final ReentrantLock lock = this.lock;\n    // 加锁\n    lock.lock();\n    try {\n        Object[] elements = getArray();\n        int len = elements.length;\n        // 复制整个数组\n        Object[] newElements = Arrays.copyOf(elements, len + 1);\n        newElements[len] = e;\n        setArray(newElements);\n        return true;\n    } finally {\n        lock.unlock();\n    }\n}\n```\n### remove\n```java\nprivate boolean remove(Object o, Object[] snapshot, int index) {\n    final ReentrantLock lock = this.lock;\n    lock.lock();\n    try {\n        Object[] current = getArray();\n        int len = current.length;\n        // snapshot不等于current，代表当前index可能已经过期了，需要再重新寻找\n        // 至于为什么这么做，主要是为了减少加锁时间，能够提升并发操作的性能\n        if (snapshot != current) findIndex: {\n            int prefix = Math.min(index, len);\n            for (int i = 0; i < prefix; i++) {\n                if (current[i] != snapshot[i] && eq(o, current[i])) {\n                    index = i;\n                    break findIndex;\n                }\n            }\n            if (index >= len)\n                return false;\n            if (current[index] == o)\n                break findIndex;\n            index = indexOf(o, current, index, len);\n            if (index < 0)\n                return false;\n        }\n        Object[] newElements = new Object[len - 1];\n        System.arraycopy(current, 0, newElements, 0, index);\n        System.arraycopy(current, index + 1,\n                            newElements, index,\n                            len - index - 1);\n        setArray(newElements);\n        return true;\n    } finally {\n        lock.unlock();\n    }\n}\n```\n\n### toArray\n```java\n// 返回一个全新的数组\npublic Object[] toArray() {\n    Object[] elements = getArray();\n    return Arrays.copyOf(elements, elements.length);\n}\n// \b原数组长度不够，创建新数组，返回新数组的信用\npublic <T> T[] toArray(T a[]) {\n    Object[] elements = getArray();\n    int len = elements.length;\n    if (a.length < len)\n        return (T[]) Arrays.copyOf(elements, len, a.getClass());\n    else {\n        System.arraycopy(elements, 0, a, 0, len);\n        if (a.length > len)\n            a[len] = null;\n        return a;\n    }\n}\n```\n### equals和hashCode\n同ArrayList\n\n---\n# Vector\njdk1.2推出的，使用synchronized加锁保证线程安全性\n\n# Stack\n继承于\bVector，也是线程安全的，实现了\b栈而已。\n\n# ListIterator\n和Iterator的主要区别是多了previous，hasPrevious，nextIndex，set和add方法","slug":"List分析","published":1,"updated":"2018-06-23T10:51:35.413Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5u1tux000e1av8z9d2s3j3","content":"<h1 id=\"ArrayList\"><a href=\"#ArrayList\" class=\"headerlink\" title=\"ArrayList\"></a>ArrayList</h1><h2 id=\"静态属性\"><a href=\"#静态属性\" class=\"headerlink\" title=\"静态属性\"></a>静态属性</h2><ol>\n<li>DEFAULT_CAPACITY，默认大小，10</li>\n<li>EMPTY_ELEMENTDATA，初始数组，空</li>\n<li>DEFAULTCAPACITY_EMPTY_ELEMENTDATA，默认大小时使用的数组，空</li>\n<li>MAX_ARRAY_SIZE，elementData最大大小，这边有歧义，数组最大大小还是Integer.MAX_VALUE</li>\n</ol>\n<h2 id=\"成员属性\"><a href=\"#成员属性\" class=\"headerlink\" title=\"成员属性\"></a>成员属性</h2><ol>\n<li>elementData，存储元素的数组</li>\n<li>size，大小</li>\n<li>modCount，操作次数（在AbstractList里面），每次进行非幂等操作的时候，都会增加这个值<a id=\"more\"></a>\n</li>\n</ol>\n<h2 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h2><ol>\n<li>大小增长是1.5倍，默认大小时10</li>\n<li>indexOf中使用了equals</li>\n<li>内部大量使用<strong>Array.copyOf()</strong> [创建一个全新数组], System.arraycopy() [数组之间元素的复制]</li>\n<li>clone方法内部使用了Arrays.copyOf()</li>\n<li>add(int index, E element)中用了System.arraycopy进行数组之间的复制</li>\n<li>clear()只是清除了引用，但是没有回收数组空间</li>\n<li>batchRemove()，里面有一个经典算法（如何在O(n)的时间范围内移除移除A数组中包含B数组的所有元素）</li>\n<li>modCount在ListIterator和Iterator中用于保证failfast（ConcurrentModificationException)</li>\n<li>ArrayListSpliterator用于并行分割计算</li>\n<li>List有两种迭代器，Iterator和ListIterator（可以前后迭代）</li>\n<li>SubList返回的不是一个全新的List，而是对原有List的一个引用（坑点）</li>\n<li>modCount是带有局限性的</li>\n</ol>\n<h2 id=\"适用场景\"><a href=\"#适用场景\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h2><p>适用于可动态扩容的数组</p>\n<h2 id=\"主要方法\"><a href=\"#主要方法\" class=\"headerlink\" title=\"主要方法\"></a>主要方法</h2><h3 id=\"grow-扩容\"><a href=\"#grow-扩容\" class=\"headerlink\" title=\"grow(扩容)\"></a>grow(扩容)</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">grow</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldCapacity = elementData.length;</span><br><span class=\"line\">    <span class=\"comment\">// 1.5倍扩容</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - minCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        newCapacity = minCapacity;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        newCapacity = hugeCapacity(minCapacity);</span><br><span class=\"line\">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"contains\"><a href=\"#contains\" class=\"headerlink\" title=\"contains\"></a>contains</h3><p>\b用==或者equals做比较<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 采用equals做比较</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">contains</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> indexOf(o) &gt;= <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">indexOf</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (o == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (elementData[i]==<span class=\"keyword\">null</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (o.equals(elementData[i]))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"add\"><a href=\"#add\" class=\"headerlink\" title=\"add\"></a>add</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">    ensureCapacityInternal(size + <span class=\"number\">1</span>);  <span class=\"comment\">// Increments modCount!!</span></span><br><span class=\"line\">    elementData[size++] = e;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"subList\"><a href=\"#subList\" class=\"headerlink\" title=\"subList\"></a>subList</h3><p>很多人认为subList()返回的是一个全新的list，但<strong>不是</strong>。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SubList</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractList</span>&lt;<span class=\"title\">E</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">RandomAccess</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AbstractList&lt;E&gt; parent;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> parentOffset;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> offset;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size;</span><br><span class=\"line\"></span><br><span class=\"line\">    SubList(AbstractList&lt;E&gt; parent,</span><br><span class=\"line\">            <span class=\"keyword\">int</span> offset, <span class=\"keyword\">int</span> fromIndex, <span class=\"keyword\">int</span> toIndex) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.parent = parent;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.parentOffset = fromIndex;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.offset = offset + fromIndex;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.size = toIndex - fromIndex;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.modCount = ArrayList.<span class=\"keyword\">this</span>.modCount;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 会修改原有的List</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">set</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E e)</span> </span>&#123;</span><br><span class=\"line\">        rangeCheck(index);</span><br><span class=\"line\">        checkForComodification();</span><br><span class=\"line\">        E oldValue = ArrayList.<span class=\"keyword\">this</span>.elementData(offset + index);</span><br><span class=\"line\">        ArrayList.<span class=\"keyword\">this</span>.elementData[offset + index] = e;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"spliterator\"><a href=\"#spliterator\" class=\"headerlink\" title=\"spliterator\"></a>spliterator</h3><p>可以使用此对list做切割，然后并行的对每个部分做操作<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ArrayListSpliterator</span>&lt;<span class=\"title\">E</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Spliterator</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ArrayList&lt;E&gt; list;</span><br><span class=\"line\">    <span class=\"comment\">// fence</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> index; <span class=\"comment\">// current index, modified on advance/split</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> fence; <span class=\"comment\">// -1 until used; then one past last index</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> expectedModCount; <span class=\"comment\">// initialized when fence set</span></span><br><span class=\"line\"></span><br><span class=\"line\">    ArrayListSpliterator(ArrayList&lt;E&gt; list, <span class=\"keyword\">int</span> origin, <span class=\"keyword\">int</span> fence,</span><br><span class=\"line\">                            <span class=\"keyword\">int</span> expectedModCount) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.list = list; <span class=\"comment\">// OK if null unless traversed</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.index = origin;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.fence = fence;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.expectedModCount = expectedModCount;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">getFence</span><span class=\"params\">()</span> </span>&#123; <span class=\"comment\">// initialize fence to size on first use</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> hi; <span class=\"comment\">// (a specialized variant appears in method forEach)</span></span><br><span class=\"line\">        ArrayList&lt;E&gt; lst;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((hi = fence) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((lst = list) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                hi = fence = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                expectedModCount = lst.modCount;</span><br><span class=\"line\">                hi = fence = lst.size;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> hi;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ArrayListSpliterator&lt;E&gt; <span class=\"title\">trySplit</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 将现有的范围[index, fence)，分为</span></span><br><span class=\"line\">        <span class=\"comment\">// [index, (index + fence)/2) 和 [(index + fence)/2,fence]</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (lo &gt;= mid) ? <span class=\"keyword\">null</span> : <span class=\"comment\">// divide range in half unless too small</span></span><br><span class=\"line\">            <span class=\"keyword\">new</span> ArrayListSpliterator&lt;E&gt;(list, lo, index = mid,</span><br><span class=\"line\">                                        expectedModCount);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"equals和hashCode\"><a href=\"#equals和hashCode\" class=\"headerlink\" title=\"equals和hashCode\"></a>equals和hashCode</h3><p>equals需要逐个元素的比较，hashCode会对所有的元素做hashCode</p>\n<hr>\n<h1 id=\"LinkedList\"><a href=\"#LinkedList\" class=\"headerlink\" title=\"LinkedList\"></a>LinkedList</h1><p>不做详细分析，只写特点。</p>\n<h2 id=\"特点-1\"><a href=\"#特点-1\" class=\"headerlink\" title=\"特点\"></a>特点</h2><ol>\n<li>底层数据结构是链表</li>\n<li>插入删除复杂度为O(1)，查找复杂度为O(n)</li>\n<li>适用于那种插入删除频繁的地方，可用于构建可变长队列，栈</li>\n</ol>\n<hr>\n<h1 id=\"CopyOnWriteArrayList\"><a href=\"#CopyOnWriteArrayList\" class=\"headerlink\" title=\"CopyOnWriteArrayList\"></a>CopyOnWriteArrayList</h1><h2 id=\"静态属性-1\"><a href=\"#静态属性-1\" class=\"headerlink\" title=\"静态属性\"></a>静态属性</h2><p>无</p>\n<h2 id=\"成员属性-1\"><a href=\"#成员属性-1\" class=\"headerlink\" title=\"成员属性\"></a>成员属性</h2><ol>\n<li>array<br>Object数组，\u001b用于存储元素</li>\n<li>lock<br>可重入锁，用于控制非幂等操作的\u001b并发\u001b安全性问题。<h2 id=\"特点-2\"><a href=\"#特点-2\" class=\"headerlink\" title=\"特点\"></a>特点</h2></li>\n<li>初始长度为0，每次做非幂等操作（写入，删除）的时候都会创建一个全新的数组</li>\n<li>写入时候复制，即使每次长度只增加1（这样有一个好处是遍历的时候不会出现问题）</li>\n<li>内部大量使用Arrays.copyOf()[整段复制]和System.arrayCopy()[分段复制，native函数]<h2 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h2>特别适合那种写入少，读取量大的情况。<br>缺点是写入特别耗时间。<h2 id=\"主要方法-1\"><a href=\"#主要方法-1\" class=\"headerlink\" title=\"主要方法\"></a>主要方法</h2><h3 id=\"get\"><a href=\"#get\" class=\"headerlink\" title=\"get\"></a>get</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> E <span class=\"title\">get</span><span class=\"params\">(Object[] a, <span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (E) a[index];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// getArray返回的是当前array</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> get(getArray(), index);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"add-1\"><a href=\"#add-1\" class=\"headerlink\" title=\"add\"></a>add</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ReentrantLock lock = <span class=\"keyword\">this</span>.lock;</span><br><span class=\"line\">    <span class=\"comment\">// 加锁</span></span><br><span class=\"line\">    lock.lock();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        Object[] elements = getArray();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = elements.length;</span><br><span class=\"line\">        <span class=\"comment\">// 复制整个数组</span></span><br><span class=\"line\">        Object[] newElements = Arrays.copyOf(elements, len + <span class=\"number\">1</span>);</span><br><span class=\"line\">        newElements[len] = e;</span><br><span class=\"line\">        setArray(newElements);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"remove\"><a href=\"#remove\" class=\"headerlink\" title=\"remove\"></a>remove</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">remove</span><span class=\"params\">(Object o, Object[] snapshot, <span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ReentrantLock lock = <span class=\"keyword\">this</span>.lock;</span><br><span class=\"line\">    lock.lock();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        Object[] current = getArray();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = current.length;</span><br><span class=\"line\">        <span class=\"comment\">// snapshot不等于current，代表当前index可能已经过期了，需要再重新寻找</span></span><br><span class=\"line\">        <span class=\"comment\">// 至于为什么这么做，主要是为了减少加锁时间，能够提升并发操作的性能</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (snapshot != current) findIndex: &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> prefix = Math.min(index, len);</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; prefix; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (current[i] != snapshot[i] &amp;&amp; eq(o, current[i])) &#123;</span><br><span class=\"line\">                    index = i;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span> findIndex;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (index &gt;= len)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (current[index] == o)</span><br><span class=\"line\">                <span class=\"keyword\">break</span> findIndex;</span><br><span class=\"line\">            index = indexOf(o, current, index, len);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (index &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Object[] newElements = <span class=\"keyword\">new</span> Object[len - <span class=\"number\">1</span>];</span><br><span class=\"line\">        System.arraycopy(current, <span class=\"number\">0</span>, newElements, <span class=\"number\">0</span>, index);</span><br><span class=\"line\">        System.arraycopy(current, index + <span class=\"number\">1</span>,</span><br><span class=\"line\">                            newElements, index,</span><br><span class=\"line\">                            len - index - <span class=\"number\">1</span>);</span><br><span class=\"line\">        setArray(newElements);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"toArray\"><a href=\"#toArray\" class=\"headerlink\" title=\"toArray\"></a>toArray</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 返回一个全新的数组</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Object[] toArray() &#123;</span><br><span class=\"line\">    Object[] elements = getArray();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Arrays.copyOf(elements, elements.length);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// \b原数组长度不够，创建新数组，返回新数组的信用</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; T[] toArray(T a[]) &#123;</span><br><span class=\"line\">    Object[] elements = getArray();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = elements.length;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (a.length &lt; len)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (T[]) Arrays.copyOf(elements, len, a.getClass());</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        System.arraycopy(elements, <span class=\"number\">0</span>, a, <span class=\"number\">0</span>, len);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a.length &gt; len)</span><br><span class=\"line\">            a[len] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"equals和hashCode-1\"><a href=\"#equals和hashCode-1\" class=\"headerlink\" title=\"equals和hashCode\"></a>equals和hashCode</h3><p>同ArrayList</p>\n<hr>\n<h1 id=\"Vector\"><a href=\"#Vector\" class=\"headerlink\" title=\"Vector\"></a>Vector</h1><p>jdk1.2推出的，使用synchronized加锁保证线程安全性</p>\n<h1 id=\"Stack\"><a href=\"#Stack\" class=\"headerlink\" title=\"Stack\"></a>Stack</h1><p>继承于\bVector，也是线程安全的，实现了\b栈而已。</p>\n<h1 id=\"ListIterator\"><a href=\"#ListIterator\" class=\"headerlink\" title=\"ListIterator\"></a>ListIterator</h1><p>和Iterator的主要区别是多了previous，hasPrevious，nextIndex，set和add方法</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"ArrayList\"><a href=\"#ArrayList\" class=\"headerlink\" title=\"ArrayList\"></a>ArrayList</h1><h2 id=\"静态属性\"><a href=\"#静态属性\" class=\"headerlink\" title=\"静态属性\"></a>静态属性</h2><ol>\n<li>DEFAULT_CAPACITY，默认大小，10</li>\n<li>EMPTY_ELEMENTDATA，初始数组，空</li>\n<li>DEFAULTCAPACITY_EMPTY_ELEMENTDATA，默认大小时使用的数组，空</li>\n<li>MAX_ARRAY_SIZE，elementData最大大小，这边有歧义，数组最大大小还是Integer.MAX_VALUE</li>\n</ol>\n<h2 id=\"成员属性\"><a href=\"#成员属性\" class=\"headerlink\" title=\"成员属性\"></a>成员属性</h2><ol>\n<li>elementData，存储元素的数组</li>\n<li>size，大小</li>\n<li>modCount，操作次数（在AbstractList里面），每次进行非幂等操作的时候，都会增加这个值","more":"</li>\n</ol>\n<h2 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h2><ol>\n<li>大小增长是1.5倍，默认大小时10</li>\n<li>indexOf中使用了equals</li>\n<li>内部大量使用<strong>Array.copyOf()</strong> [创建一个全新数组], System.arraycopy() [数组之间元素的复制]</li>\n<li>clone方法内部使用了Arrays.copyOf()</li>\n<li>add(int index, E element)中用了System.arraycopy进行数组之间的复制</li>\n<li>clear()只是清除了引用，但是没有回收数组空间</li>\n<li>batchRemove()，里面有一个经典算法（如何在O(n)的时间范围内移除移除A数组中包含B数组的所有元素）</li>\n<li>modCount在ListIterator和Iterator中用于保证failfast（ConcurrentModificationException)</li>\n<li>ArrayListSpliterator用于并行分割计算</li>\n<li>List有两种迭代器，Iterator和ListIterator（可以前后迭代）</li>\n<li>SubList返回的不是一个全新的List，而是对原有List的一个引用（坑点）</li>\n<li>modCount是带有局限性的</li>\n</ol>\n<h2 id=\"适用场景\"><a href=\"#适用场景\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h2><p>适用于可动态扩容的数组</p>\n<h2 id=\"主要方法\"><a href=\"#主要方法\" class=\"headerlink\" title=\"主要方法\"></a>主要方法</h2><h3 id=\"grow-扩容\"><a href=\"#grow-扩容\" class=\"headerlink\" title=\"grow(扩容)\"></a>grow(扩容)</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">grow</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldCapacity = elementData.length;</span><br><span class=\"line\">    <span class=\"comment\">// 1.5倍扩容</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - minCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        newCapacity = minCapacity;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        newCapacity = hugeCapacity(minCapacity);</span><br><span class=\"line\">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"contains\"><a href=\"#contains\" class=\"headerlink\" title=\"contains\"></a>contains</h3><p>\b用==或者equals做比较<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 采用equals做比较</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">contains</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> indexOf(o) &gt;= <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">indexOf</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (o == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (elementData[i]==<span class=\"keyword\">null</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (o.equals(elementData[i]))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"add\"><a href=\"#add\" class=\"headerlink\" title=\"add\"></a>add</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">    ensureCapacityInternal(size + <span class=\"number\">1</span>);  <span class=\"comment\">// Increments modCount!!</span></span><br><span class=\"line\">    elementData[size++] = e;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"subList\"><a href=\"#subList\" class=\"headerlink\" title=\"subList\"></a>subList</h3><p>很多人认为subList()返回的是一个全新的list，但<strong>不是</strong>。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SubList</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractList</span>&lt;<span class=\"title\">E</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">RandomAccess</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AbstractList&lt;E&gt; parent;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> parentOffset;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> offset;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size;</span><br><span class=\"line\"></span><br><span class=\"line\">    SubList(AbstractList&lt;E&gt; parent,</span><br><span class=\"line\">            <span class=\"keyword\">int</span> offset, <span class=\"keyword\">int</span> fromIndex, <span class=\"keyword\">int</span> toIndex) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.parent = parent;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.parentOffset = fromIndex;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.offset = offset + fromIndex;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.size = toIndex - fromIndex;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.modCount = ArrayList.<span class=\"keyword\">this</span>.modCount;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 会修改原有的List</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">set</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E e)</span> </span>&#123;</span><br><span class=\"line\">        rangeCheck(index);</span><br><span class=\"line\">        checkForComodification();</span><br><span class=\"line\">        E oldValue = ArrayList.<span class=\"keyword\">this</span>.elementData(offset + index);</span><br><span class=\"line\">        ArrayList.<span class=\"keyword\">this</span>.elementData[offset + index] = e;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"spliterator\"><a href=\"#spliterator\" class=\"headerlink\" title=\"spliterator\"></a>spliterator</h3><p>可以使用此对list做切割，然后并行的对每个部分做操作<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ArrayListSpliterator</span>&lt;<span class=\"title\">E</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Spliterator</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ArrayList&lt;E&gt; list;</span><br><span class=\"line\">    <span class=\"comment\">// fence</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> index; <span class=\"comment\">// current index, modified on advance/split</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> fence; <span class=\"comment\">// -1 until used; then one past last index</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> expectedModCount; <span class=\"comment\">// initialized when fence set</span></span><br><span class=\"line\"></span><br><span class=\"line\">    ArrayListSpliterator(ArrayList&lt;E&gt; list, <span class=\"keyword\">int</span> origin, <span class=\"keyword\">int</span> fence,</span><br><span class=\"line\">                            <span class=\"keyword\">int</span> expectedModCount) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.list = list; <span class=\"comment\">// OK if null unless traversed</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.index = origin;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.fence = fence;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.expectedModCount = expectedModCount;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">getFence</span><span class=\"params\">()</span> </span>&#123; <span class=\"comment\">// initialize fence to size on first use</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> hi; <span class=\"comment\">// (a specialized variant appears in method forEach)</span></span><br><span class=\"line\">        ArrayList&lt;E&gt; lst;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((hi = fence) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((lst = list) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                hi = fence = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                expectedModCount = lst.modCount;</span><br><span class=\"line\">                hi = fence = lst.size;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> hi;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ArrayListSpliterator&lt;E&gt; <span class=\"title\">trySplit</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 将现有的范围[index, fence)，分为</span></span><br><span class=\"line\">        <span class=\"comment\">// [index, (index + fence)/2) 和 [(index + fence)/2,fence]</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (lo &gt;= mid) ? <span class=\"keyword\">null</span> : <span class=\"comment\">// divide range in half unless too small</span></span><br><span class=\"line\">            <span class=\"keyword\">new</span> ArrayListSpliterator&lt;E&gt;(list, lo, index = mid,</span><br><span class=\"line\">                                        expectedModCount);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"equals和hashCode\"><a href=\"#equals和hashCode\" class=\"headerlink\" title=\"equals和hashCode\"></a>equals和hashCode</h3><p>equals需要逐个元素的比较，hashCode会对所有的元素做hashCode</p>\n<hr>\n<h1 id=\"LinkedList\"><a href=\"#LinkedList\" class=\"headerlink\" title=\"LinkedList\"></a>LinkedList</h1><p>不做详细分析，只写特点。</p>\n<h2 id=\"特点-1\"><a href=\"#特点-1\" class=\"headerlink\" title=\"特点\"></a>特点</h2><ol>\n<li>底层数据结构是链表</li>\n<li>插入删除复杂度为O(1)，查找复杂度为O(n)</li>\n<li>适用于那种插入删除频繁的地方，可用于构建可变长队列，栈</li>\n</ol>\n<hr>\n<h1 id=\"CopyOnWriteArrayList\"><a href=\"#CopyOnWriteArrayList\" class=\"headerlink\" title=\"CopyOnWriteArrayList\"></a>CopyOnWriteArrayList</h1><h2 id=\"静态属性-1\"><a href=\"#静态属性-1\" class=\"headerlink\" title=\"静态属性\"></a>静态属性</h2><p>无</p>\n<h2 id=\"成员属性-1\"><a href=\"#成员属性-1\" class=\"headerlink\" title=\"成员属性\"></a>成员属性</h2><ol>\n<li>array<br>Object数组，\u001b用于存储元素</li>\n<li>lock<br>可重入锁，用于控制非幂等操作的\u001b并发\u001b安全性问题。<h2 id=\"特点-2\"><a href=\"#特点-2\" class=\"headerlink\" title=\"特点\"></a>特点</h2></li>\n<li>初始长度为0，每次做非幂等操作（写入，删除）的时候都会创建一个全新的数组</li>\n<li>写入时候复制，即使每次长度只增加1（这样有一个好处是遍历的时候不会出现问题）</li>\n<li>内部大量使用Arrays.copyOf()[整段复制]和System.arrayCopy()[分段复制，native函数]<h2 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h2>特别适合那种写入少，读取量大的情况。<br>缺点是写入特别耗时间。<h2 id=\"主要方法-1\"><a href=\"#主要方法-1\" class=\"headerlink\" title=\"主要方法\"></a>主要方法</h2><h3 id=\"get\"><a href=\"#get\" class=\"headerlink\" title=\"get\"></a>get</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> E <span class=\"title\">get</span><span class=\"params\">(Object[] a, <span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (E) a[index];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// getArray返回的是当前array</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> get(getArray(), index);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"add-1\"><a href=\"#add-1\" class=\"headerlink\" title=\"add\"></a>add</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ReentrantLock lock = <span class=\"keyword\">this</span>.lock;</span><br><span class=\"line\">    <span class=\"comment\">// 加锁</span></span><br><span class=\"line\">    lock.lock();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        Object[] elements = getArray();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = elements.length;</span><br><span class=\"line\">        <span class=\"comment\">// 复制整个数组</span></span><br><span class=\"line\">        Object[] newElements = Arrays.copyOf(elements, len + <span class=\"number\">1</span>);</span><br><span class=\"line\">        newElements[len] = e;</span><br><span class=\"line\">        setArray(newElements);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"remove\"><a href=\"#remove\" class=\"headerlink\" title=\"remove\"></a>remove</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">remove</span><span class=\"params\">(Object o, Object[] snapshot, <span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ReentrantLock lock = <span class=\"keyword\">this</span>.lock;</span><br><span class=\"line\">    lock.lock();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        Object[] current = getArray();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = current.length;</span><br><span class=\"line\">        <span class=\"comment\">// snapshot不等于current，代表当前index可能已经过期了，需要再重新寻找</span></span><br><span class=\"line\">        <span class=\"comment\">// 至于为什么这么做，主要是为了减少加锁时间，能够提升并发操作的性能</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (snapshot != current) findIndex: &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> prefix = Math.min(index, len);</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; prefix; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (current[i] != snapshot[i] &amp;&amp; eq(o, current[i])) &#123;</span><br><span class=\"line\">                    index = i;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span> findIndex;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (index &gt;= len)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (current[index] == o)</span><br><span class=\"line\">                <span class=\"keyword\">break</span> findIndex;</span><br><span class=\"line\">            index = indexOf(o, current, index, len);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (index &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Object[] newElements = <span class=\"keyword\">new</span> Object[len - <span class=\"number\">1</span>];</span><br><span class=\"line\">        System.arraycopy(current, <span class=\"number\">0</span>, newElements, <span class=\"number\">0</span>, index);</span><br><span class=\"line\">        System.arraycopy(current, index + <span class=\"number\">1</span>,</span><br><span class=\"line\">                            newElements, index,</span><br><span class=\"line\">                            len - index - <span class=\"number\">1</span>);</span><br><span class=\"line\">        setArray(newElements);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"toArray\"><a href=\"#toArray\" class=\"headerlink\" title=\"toArray\"></a>toArray</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 返回一个全新的数组</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Object[] toArray() &#123;</span><br><span class=\"line\">    Object[] elements = getArray();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Arrays.copyOf(elements, elements.length);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// \b原数组长度不够，创建新数组，返回新数组的信用</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; T[] toArray(T a[]) &#123;</span><br><span class=\"line\">    Object[] elements = getArray();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = elements.length;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (a.length &lt; len)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (T[]) Arrays.copyOf(elements, len, a.getClass());</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        System.arraycopy(elements, <span class=\"number\">0</span>, a, <span class=\"number\">0</span>, len);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a.length &gt; len)</span><br><span class=\"line\">            a[len] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"equals和hashCode-1\"><a href=\"#equals和hashCode-1\" class=\"headerlink\" title=\"equals和hashCode\"></a>equals和hashCode</h3><p>同ArrayList</p>\n<hr>\n<h1 id=\"Vector\"><a href=\"#Vector\" class=\"headerlink\" title=\"Vector\"></a>Vector</h1><p>jdk1.2推出的，使用synchronized加锁保证线程安全性</p>\n<h1 id=\"Stack\"><a href=\"#Stack\" class=\"headerlink\" title=\"Stack\"></a>Stack</h1><p>继承于\bVector，也是线程安全的，实现了\b栈而已。</p>\n<h1 id=\"ListIterator\"><a href=\"#ListIterator\" class=\"headerlink\" title=\"ListIterator\"></a>ListIterator</h1><p>和Iterator的主要区别是多了previous，hasPrevious，nextIndex，set和add方法</p>"},{"title":"Mysql笔记","date":"2018-06-24T07:26:18.000Z","toc":true,"_content":"#### mysql架构\n<img src=\"/images/mysql结构.jpg\" width=\"50%\" height=\"50%\">\n<!-- more -->\n\n#### 架构层面\n1. 读写分离（使用mycat，或者mysql自带的都行）\n2. 读多写少用myisam\n3. 读写都多用innodb\n4. 对mysql引擎进行调优，适当增加内存缓存\n\n这边有一个考点，如何进行分库分表的不宕机数据迁移\n1. 不用随机分片规则（hash取模），使用范围分片的规则\n2. 做数据的拷贝，然后停机一段时间，将现有数据在多个表上都拷贝一份\n3. 将id和库的映射关系，记录下来，比如说放在nosql数据库中\n\n#### 表结构\n1. 分库分表\n2. 表分区（mysql自带）\n3. 使用合适的字段类型，合适的字段长度\n4. 不使用外键\n5. 建合适的索引，不要滥用索引\n\n#### sql优化\n1. explain查看所有的sql语句，查看是否命中索引\n2. Group By以及Order By的字段是否命中索引（会使用filesort）\n3. 使用索引的最左前缀匹配原则\n4. 少用Join，join的字段应该走索引\n5. 不使用约束（外键约束，check约束）\n6. like查询走搜索引擎\n\n#### 不走索引总结\n1. 对索引列使用了函数，或者数学运算等操作\n2. 不能使用like %XXX\n3. 字符串列与数字直接比较\n4. 尽量避免or\n5. 判断字段是否为NULL\n6. IN, NOT IN, EXISTS等（范围扫描走，集合扫描不走）\n\n#### 索引\n1. 数据结构：B+树（与B树的区别），![B+树](/images/B+树.png)\n2. 分类：聚集索引和非聚集索引（聚集索引通常只有一个，数据按照聚集索引组织在一起）\n3. innodb索引规则：\n    - 没有主键则使用唯一索引做主键索引\n    - 存在多个唯一索引则按照索引顺序使用\n    - 不存在唯一索引，则建立占六个字节的匿名主键索引\n4. 联合索引的原理是B+树的叶子节点按照联合索引的各个字段来排序\n5. 联合索引中，区分度比较高的列应该放在前面，这样一次查询能够确定的数据范围比较小\n6. 走主键索引比较快，因为比二级索引少一次查询\n7. innodb插入比较慢，因为主要是涉及到索引的调整\n8. innodb默认是行锁，行锁锁的是索引(个人认为是同时锁多个索引)，如果查询语句没有走索引，就会升级为表锁\n9. limit的原理是扫描数据，最好是能够直接扫描索引，不用去根据id再去扫描完整数据\n10. innodb的**可重复读**避免了幻读，主要是通过间隙锁（主要是针对范围加锁）或者是行锁与间隙锁一起\n11. 行锁的实现是位图，通过一个bitmap记录了哪些行被加锁了\n\n#### 事务\n1. 原子性，一致性，隔离性，持久性\n2. 默认事务隔离级别是可重复读\n3. mysql通过mvcc来实现事务的隔离级别的\n\n#### mvcc\nmulti version concurrency control，多版本并发控制。\n事务的隔离级别是通过mvcc实现的，数据一般会存在有多个版本。\nmysql中的读取叫做快照读，读取的时候会根据当前的隔离级别，建立一个读取的快照（里面保存了可以对数据读取的事务的版本）。\n##### 下面是索引的结构\ntrx_id：该数据被提交修改了多少次（每行数据从0开始增长）\ndb_roll_ptr：在数据在undolog中的\n![索引结构](/images/MVCC1.jpg)\n具体的操作\n![mvcc流程](/images/MVCC2.jpg)\n\n#### 隔离级别\n隔离级别|出现现象|原因\n:-:|:-:|:-:\n未提交读|脏读，不可重复读，幻读|会直接读取当前行数据，即使当前行数据未提交\n已提交读|不可重复读，幻读|会读取当前最新的已经提交的修改，但是避免不了幻读，<br/>因为一个事务当中可能读取到其他事务的多次修改\n可重复读|幻读|会根据当前快照中的数据事务版本号，去undo log中读取当前事务开始时候的初始数据\n串行化|无|串行化就是直接加了排他锁\ninnodb的可重复读还解决了幻读的问题，\n\n#### log\n1. redo log，mysql的很多修改都是直接修改的内存，并且将修改记录到了redo log中。redo log用于防止mysql被突然重启，但是还有内存中的修改并未被刷新到磁盘上的现象出现。mysql重启的时候，会\u001b读取redo log，用于重新执行那些已经提交的修改。\n2. undo log，用于记录事务的反向操作，可以用于事务的回滚\n3. bin log，服务器端对数据操作的日志，通常用于数据恢复和数据同步，mysql的主从同步就是slave去\u001bmaster上拉取最新的binlog去执行\n\n#### 字段新增\n1. 复制旧表结构为新表\n2. 新增一个字段\n3. 将旧表数据复制过来（这时候就开始加表锁了）\n4. 删除旧表，重命名新表\n\n**如何优化**\n复制结构到新表，新增一个字段，将旧表数据复制过来，然后在旧表上面设置触发器，对数据的修改，同时全部通过触发器同步到新表之中，最后删除旧表，重命名新表\n\n#### 查询过程\n1. 查询缓存（相同语句，直接走缓存回去了）\n2. 词法分析，语法分析，语义分析，生成解析树\n3. \u001b交给查询优化器优化\n4. 执行\u001b引擎执行\n![mysql查询过程](/images/mysql查询过程.png)\n\n#### 索引\n1. system，表中只有一行数据或为空\n2. const，查询结果只有一行数据，唯一索引或主键索引\n3. eq_ref，连接查询时，使用唯一索引查询\n4. ref，普通非唯一索引\n5. range，索引的范围扫描\n6. index，索引全扫描\n7. all，表全扫描\n\n#### 三范式\n1. 第一范式：属性不可拆分（地址可以再拆分为省市区）\n2. 非主属性完全依赖于码（学生姓名完全依赖于学号）\n3. 非主属性之间没有任何传递依赖（班主任工号和班主任姓名）\n\n#### 字符集\n1. 数据库字符集\n2. 表字符集\n3. 列字符集","source":"_posts/Mysql笔记.md","raw":"---\ntitle: Mysql笔记\ndate: 2018-06-24 15:26:18\ntags:\n- 中间件\n- mysql\ncategories:\n- 中间件\ntoc: true\n---\n#### mysql架构\n<img src=\"/images/mysql结构.jpg\" width=\"50%\" height=\"50%\">\n<!-- more -->\n\n#### 架构层面\n1. 读写分离（使用mycat，或者mysql自带的都行）\n2. 读多写少用myisam\n3. 读写都多用innodb\n4. 对mysql引擎进行调优，适当增加内存缓存\n\n这边有一个考点，如何进行分库分表的不宕机数据迁移\n1. 不用随机分片规则（hash取模），使用范围分片的规则\n2. 做数据的拷贝，然后停机一段时间，将现有数据在多个表上都拷贝一份\n3. 将id和库的映射关系，记录下来，比如说放在nosql数据库中\n\n#### 表结构\n1. 分库分表\n2. 表分区（mysql自带）\n3. 使用合适的字段类型，合适的字段长度\n4. 不使用外键\n5. 建合适的索引，不要滥用索引\n\n#### sql优化\n1. explain查看所有的sql语句，查看是否命中索引\n2. Group By以及Order By的字段是否命中索引（会使用filesort）\n3. 使用索引的最左前缀匹配原则\n4. 少用Join，join的字段应该走索引\n5. 不使用约束（外键约束，check约束）\n6. like查询走搜索引擎\n\n#### 不走索引总结\n1. 对索引列使用了函数，或者数学运算等操作\n2. 不能使用like %XXX\n3. 字符串列与数字直接比较\n4. 尽量避免or\n5. 判断字段是否为NULL\n6. IN, NOT IN, EXISTS等（范围扫描走，集合扫描不走）\n\n#### 索引\n1. 数据结构：B+树（与B树的区别），![B+树](/images/B+树.png)\n2. 分类：聚集索引和非聚集索引（聚集索引通常只有一个，数据按照聚集索引组织在一起）\n3. innodb索引规则：\n    - 没有主键则使用唯一索引做主键索引\n    - 存在多个唯一索引则按照索引顺序使用\n    - 不存在唯一索引，则建立占六个字节的匿名主键索引\n4. 联合索引的原理是B+树的叶子节点按照联合索引的各个字段来排序\n5. 联合索引中，区分度比较高的列应该放在前面，这样一次查询能够确定的数据范围比较小\n6. 走主键索引比较快，因为比二级索引少一次查询\n7. innodb插入比较慢，因为主要是涉及到索引的调整\n8. innodb默认是行锁，行锁锁的是索引(个人认为是同时锁多个索引)，如果查询语句没有走索引，就会升级为表锁\n9. limit的原理是扫描数据，最好是能够直接扫描索引，不用去根据id再去扫描完整数据\n10. innodb的**可重复读**避免了幻读，主要是通过间隙锁（主要是针对范围加锁）或者是行锁与间隙锁一起\n11. 行锁的实现是位图，通过一个bitmap记录了哪些行被加锁了\n\n#### 事务\n1. 原子性，一致性，隔离性，持久性\n2. 默认事务隔离级别是可重复读\n3. mysql通过mvcc来实现事务的隔离级别的\n\n#### mvcc\nmulti version concurrency control，多版本并发控制。\n事务的隔离级别是通过mvcc实现的，数据一般会存在有多个版本。\nmysql中的读取叫做快照读，读取的时候会根据当前的隔离级别，建立一个读取的快照（里面保存了可以对数据读取的事务的版本）。\n##### 下面是索引的结构\ntrx_id：该数据被提交修改了多少次（每行数据从0开始增长）\ndb_roll_ptr：在数据在undolog中的\n![索引结构](/images/MVCC1.jpg)\n具体的操作\n![mvcc流程](/images/MVCC2.jpg)\n\n#### 隔离级别\n隔离级别|出现现象|原因\n:-:|:-:|:-:\n未提交读|脏读，不可重复读，幻读|会直接读取当前行数据，即使当前行数据未提交\n已提交读|不可重复读，幻读|会读取当前最新的已经提交的修改，但是避免不了幻读，<br/>因为一个事务当中可能读取到其他事务的多次修改\n可重复读|幻读|会根据当前快照中的数据事务版本号，去undo log中读取当前事务开始时候的初始数据\n串行化|无|串行化就是直接加了排他锁\ninnodb的可重复读还解决了幻读的问题，\n\n#### log\n1. redo log，mysql的很多修改都是直接修改的内存，并且将修改记录到了redo log中。redo log用于防止mysql被突然重启，但是还有内存中的修改并未被刷新到磁盘上的现象出现。mysql重启的时候，会\u001b读取redo log，用于重新执行那些已经提交的修改。\n2. undo log，用于记录事务的反向操作，可以用于事务的回滚\n3. bin log，服务器端对数据操作的日志，通常用于数据恢复和数据同步，mysql的主从同步就是slave去\u001bmaster上拉取最新的binlog去执行\n\n#### 字段新增\n1. 复制旧表结构为新表\n2. 新增一个字段\n3. 将旧表数据复制过来（这时候就开始加表锁了）\n4. 删除旧表，重命名新表\n\n**如何优化**\n复制结构到新表，新增一个字段，将旧表数据复制过来，然后在旧表上面设置触发器，对数据的修改，同时全部通过触发器同步到新表之中，最后删除旧表，重命名新表\n\n#### 查询过程\n1. 查询缓存（相同语句，直接走缓存回去了）\n2. 词法分析，语法分析，语义分析，生成解析树\n3. \u001b交给查询优化器优化\n4. 执行\u001b引擎执行\n![mysql查询过程](/images/mysql查询过程.png)\n\n#### 索引\n1. system，表中只有一行数据或为空\n2. const，查询结果只有一行数据，唯一索引或主键索引\n3. eq_ref，连接查询时，使用唯一索引查询\n4. ref，普通非唯一索引\n5. range，索引的范围扫描\n6. index，索引全扫描\n7. all，表全扫描\n\n#### 三范式\n1. 第一范式：属性不可拆分（地址可以再拆分为省市区）\n2. 非主属性完全依赖于码（学生姓名完全依赖于学号）\n3. 非主属性之间没有任何传递依赖（班主任工号和班主任姓名）\n\n#### 字符集\n1. 数据库字符集\n2. 表字符集\n3. 列字符集","slug":"Mysql笔记","published":1,"updated":"2018-06-24T07:56:21.758Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5u1tv0000h1av8dna6uff4","content":"<h4 id=\"mysql架构\"><a href=\"#mysql架构\" class=\"headerlink\" title=\"mysql架构\"></a>mysql架构</h4><p><img src=\"/images/mysql结构.jpg\" width=\"50%\" height=\"50%\"><br><a id=\"more\"></a></p>\n<h4 id=\"架构层面\"><a href=\"#架构层面\" class=\"headerlink\" title=\"架构层面\"></a>架构层面</h4><ol>\n<li>读写分离（使用mycat，或者mysql自带的都行）</li>\n<li>读多写少用myisam</li>\n<li>读写都多用innodb</li>\n<li>对mysql引擎进行调优，适当增加内存缓存</li>\n</ol>\n<p>这边有一个考点，如何进行分库分表的不宕机数据迁移</p>\n<ol>\n<li>不用随机分片规则（hash取模），使用范围分片的规则</li>\n<li>做数据的拷贝，然后停机一段时间，将现有数据在多个表上都拷贝一份</li>\n<li>将id和库的映射关系，记录下来，比如说放在nosql数据库中</li>\n</ol>\n<h4 id=\"表结构\"><a href=\"#表结构\" class=\"headerlink\" title=\"表结构\"></a>表结构</h4><ol>\n<li>分库分表</li>\n<li>表分区（mysql自带）</li>\n<li>使用合适的字段类型，合适的字段长度</li>\n<li>不使用外键</li>\n<li>建合适的索引，不要滥用索引</li>\n</ol>\n<h4 id=\"sql优化\"><a href=\"#sql优化\" class=\"headerlink\" title=\"sql优化\"></a>sql优化</h4><ol>\n<li>explain查看所有的sql语句，查看是否命中索引</li>\n<li>Group By以及Order By的字段是否命中索引（会使用filesort）</li>\n<li>使用索引的最左前缀匹配原则</li>\n<li>少用Join，join的字段应该走索引</li>\n<li>不使用约束（外键约束，check约束）</li>\n<li>like查询走搜索引擎</li>\n</ol>\n<h4 id=\"不走索引总结\"><a href=\"#不走索引总结\" class=\"headerlink\" title=\"不走索引总结\"></a>不走索引总结</h4><ol>\n<li>对索引列使用了函数，或者数学运算等操作</li>\n<li>不能使用like %XXX</li>\n<li>字符串列与数字直接比较</li>\n<li>尽量避免or</li>\n<li>判断字段是否为NULL</li>\n<li>IN, NOT IN, EXISTS等（范围扫描走，集合扫描不走）</li>\n</ol>\n<h4 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h4><ol>\n<li>数据结构：B+树（与B树的区别），<img src=\"/images/B+树.png\" alt=\"B+树\"></li>\n<li>分类：聚集索引和非聚集索引（聚集索引通常只有一个，数据按照聚集索引组织在一起）</li>\n<li>innodb索引规则：<ul>\n<li>没有主键则使用唯一索引做主键索引</li>\n<li>存在多个唯一索引则按照索引顺序使用</li>\n<li>不存在唯一索引，则建立占六个字节的匿名主键索引</li>\n</ul>\n</li>\n<li>联合索引的原理是B+树的叶子节点按照联合索引的各个字段来排序</li>\n<li>联合索引中，区分度比较高的列应该放在前面，这样一次查询能够确定的数据范围比较小</li>\n<li>走主键索引比较快，因为比二级索引少一次查询</li>\n<li>innodb插入比较慢，因为主要是涉及到索引的调整</li>\n<li>innodb默认是行锁，行锁锁的是索引(个人认为是同时锁多个索引)，如果查询语句没有走索引，就会升级为表锁</li>\n<li>limit的原理是扫描数据，最好是能够直接扫描索引，不用去根据id再去扫描完整数据</li>\n<li>innodb的<strong>可重复读</strong>避免了幻读，主要是通过间隙锁（主要是针对范围加锁）或者是行锁与间隙锁一起</li>\n<li>行锁的实现是位图，通过一个bitmap记录了哪些行被加锁了</li>\n</ol>\n<h4 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h4><ol>\n<li>原子性，一致性，隔离性，持久性</li>\n<li>默认事务隔离级别是可重复读</li>\n<li>mysql通过mvcc来实现事务的隔离级别的</li>\n</ol>\n<h4 id=\"mvcc\"><a href=\"#mvcc\" class=\"headerlink\" title=\"mvcc\"></a>mvcc</h4><p>multi version concurrency control，多版本并发控制。<br>事务的隔离级别是通过mvcc实现的，数据一般会存在有多个版本。<br>mysql中的读取叫做快照读，读取的时候会根据当前的隔离级别，建立一个读取的快照（里面保存了可以对数据读取的事务的版本）。</p>\n<h5 id=\"下面是索引的结构\"><a href=\"#下面是索引的结构\" class=\"headerlink\" title=\"下面是索引的结构\"></a>下面是索引的结构</h5><p>trx_id：该数据被提交修改了多少次（每行数据从0开始增长）<br>db_roll_ptr：在数据在undolog中的<br><img src=\"/images/MVCC1.jpg\" alt=\"索引结构\"><br>具体的操作<br><img src=\"/images/MVCC2.jpg\" alt=\"mvcc流程\"></p>\n<h4 id=\"隔离级别\"><a href=\"#隔离级别\" class=\"headerlink\" title=\"隔离级别\"></a>隔离级别</h4><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">隔离级别</th>\n<th style=\"text-align:center\">出现现象</th>\n<th style=\"text-align:center\">原因</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">未提交读</td>\n<td style=\"text-align:center\">脏读，不可重复读，幻读</td>\n<td style=\"text-align:center\">会直接读取当前行数据，即使当前行数据未提交</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">已提交读</td>\n<td style=\"text-align:center\">不可重复读，幻读</td>\n<td style=\"text-align:center\">会读取当前最新的已经提交的修改，但是避免不了幻读，<br>因为一个事务当中可能读取到其他事务的多次修改</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">可重复读</td>\n<td style=\"text-align:center\">幻读</td>\n<td style=\"text-align:center\">会根据当前快照中的数据事务版本号，去undo log中读取当前事务开始时候的初始数据</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">串行化</td>\n<td style=\"text-align:center\">无</td>\n<td style=\"text-align:center\">串行化就是直接加了排他锁</td>\n</tr>\n</tbody>\n</table>\n<p>innodb的可重复读还解决了幻读的问题，</p>\n<h4 id=\"log\"><a href=\"#log\" class=\"headerlink\" title=\"log\"></a>log</h4><ol>\n<li>redo log，mysql的很多修改都是直接修改的内存，并且将修改记录到了redo log中。redo log用于防止mysql被突然重启，但是还有内存中的修改并未被刷新到磁盘上的现象出现。mysql重启的时候，会\u001b读取redo log，用于重新执行那些已经提交的修改。</li>\n<li>undo log，用于记录事务的反向操作，可以用于事务的回滚</li>\n<li>bin log，服务器端对数据操作的日志，通常用于数据恢复和数据同步，mysql的主从同步就是slave去\u001bmaster上拉取最新的binlog去执行</li>\n</ol>\n<h4 id=\"字段新增\"><a href=\"#字段新增\" class=\"headerlink\" title=\"字段新增\"></a>字段新增</h4><ol>\n<li>复制旧表结构为新表</li>\n<li>新增一个字段</li>\n<li>将旧表数据复制过来（这时候就开始加表锁了）</li>\n<li>删除旧表，重命名新表</li>\n</ol>\n<p><strong>如何优化</strong><br>复制结构到新表，新增一个字段，将旧表数据复制过来，然后在旧表上面设置触发器，对数据的修改，同时全部通过触发器同步到新表之中，最后删除旧表，重命名新表</p>\n<h4 id=\"查询过程\"><a href=\"#查询过程\" class=\"headerlink\" title=\"查询过程\"></a>查询过程</h4><ol>\n<li>查询缓存（相同语句，直接走缓存回去了）</li>\n<li>词法分析，语法分析，语义分析，生成解析树</li>\n<li>\u001b交给查询优化器优化</li>\n<li>执行\u001b引擎执行<br><img src=\"/images/mysql查询过程.png\" alt=\"mysql查询过程\"></li>\n</ol>\n<h4 id=\"索引-1\"><a href=\"#索引-1\" class=\"headerlink\" title=\"索引\"></a>索引</h4><ol>\n<li>system，表中只有一行数据或为空</li>\n<li>const，查询结果只有一行数据，唯一索引或主键索引</li>\n<li>eq_ref，连接查询时，使用唯一索引查询</li>\n<li>ref，普通非唯一索引</li>\n<li>range，索引的范围扫描</li>\n<li>index，索引全扫描</li>\n<li>all，表全扫描</li>\n</ol>\n<h4 id=\"三范式\"><a href=\"#三范式\" class=\"headerlink\" title=\"三范式\"></a>三范式</h4><ol>\n<li>第一范式：属性不可拆分（地址可以再拆分为省市区）</li>\n<li>非主属性完全依赖于码（学生姓名完全依赖于学号）</li>\n<li>非主属性之间没有任何传递依赖（班主任工号和班主任姓名）</li>\n</ol>\n<h4 id=\"字符集\"><a href=\"#字符集\" class=\"headerlink\" title=\"字符集\"></a>字符集</h4><ol>\n<li>数据库字符集</li>\n<li>表字符集</li>\n<li>列字符集</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h4 id=\"mysql架构\"><a href=\"#mysql架构\" class=\"headerlink\" title=\"mysql架构\"></a>mysql架构</h4><p><img src=\"/images/mysql结构.jpg\" width=\"50%\" height=\"50%\"><br>","more":"</p>\n<h4 id=\"架构层面\"><a href=\"#架构层面\" class=\"headerlink\" title=\"架构层面\"></a>架构层面</h4><ol>\n<li>读写分离（使用mycat，或者mysql自带的都行）</li>\n<li>读多写少用myisam</li>\n<li>读写都多用innodb</li>\n<li>对mysql引擎进行调优，适当增加内存缓存</li>\n</ol>\n<p>这边有一个考点，如何进行分库分表的不宕机数据迁移</p>\n<ol>\n<li>不用随机分片规则（hash取模），使用范围分片的规则</li>\n<li>做数据的拷贝，然后停机一段时间，将现有数据在多个表上都拷贝一份</li>\n<li>将id和库的映射关系，记录下来，比如说放在nosql数据库中</li>\n</ol>\n<h4 id=\"表结构\"><a href=\"#表结构\" class=\"headerlink\" title=\"表结构\"></a>表结构</h4><ol>\n<li>分库分表</li>\n<li>表分区（mysql自带）</li>\n<li>使用合适的字段类型，合适的字段长度</li>\n<li>不使用外键</li>\n<li>建合适的索引，不要滥用索引</li>\n</ol>\n<h4 id=\"sql优化\"><a href=\"#sql优化\" class=\"headerlink\" title=\"sql优化\"></a>sql优化</h4><ol>\n<li>explain查看所有的sql语句，查看是否命中索引</li>\n<li>Group By以及Order By的字段是否命中索引（会使用filesort）</li>\n<li>使用索引的最左前缀匹配原则</li>\n<li>少用Join，join的字段应该走索引</li>\n<li>不使用约束（外键约束，check约束）</li>\n<li>like查询走搜索引擎</li>\n</ol>\n<h4 id=\"不走索引总结\"><a href=\"#不走索引总结\" class=\"headerlink\" title=\"不走索引总结\"></a>不走索引总结</h4><ol>\n<li>对索引列使用了函数，或者数学运算等操作</li>\n<li>不能使用like %XXX</li>\n<li>字符串列与数字直接比较</li>\n<li>尽量避免or</li>\n<li>判断字段是否为NULL</li>\n<li>IN, NOT IN, EXISTS等（范围扫描走，集合扫描不走）</li>\n</ol>\n<h4 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h4><ol>\n<li>数据结构：B+树（与B树的区别），<img src=\"/images/B+树.png\" alt=\"B+树\"></li>\n<li>分类：聚集索引和非聚集索引（聚集索引通常只有一个，数据按照聚集索引组织在一起）</li>\n<li>innodb索引规则：<ul>\n<li>没有主键则使用唯一索引做主键索引</li>\n<li>存在多个唯一索引则按照索引顺序使用</li>\n<li>不存在唯一索引，则建立占六个字节的匿名主键索引</li>\n</ul>\n</li>\n<li>联合索引的原理是B+树的叶子节点按照联合索引的各个字段来排序</li>\n<li>联合索引中，区分度比较高的列应该放在前面，这样一次查询能够确定的数据范围比较小</li>\n<li>走主键索引比较快，因为比二级索引少一次查询</li>\n<li>innodb插入比较慢，因为主要是涉及到索引的调整</li>\n<li>innodb默认是行锁，行锁锁的是索引(个人认为是同时锁多个索引)，如果查询语句没有走索引，就会升级为表锁</li>\n<li>limit的原理是扫描数据，最好是能够直接扫描索引，不用去根据id再去扫描完整数据</li>\n<li>innodb的<strong>可重复读</strong>避免了幻读，主要是通过间隙锁（主要是针对范围加锁）或者是行锁与间隙锁一起</li>\n<li>行锁的实现是位图，通过一个bitmap记录了哪些行被加锁了</li>\n</ol>\n<h4 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h4><ol>\n<li>原子性，一致性，隔离性，持久性</li>\n<li>默认事务隔离级别是可重复读</li>\n<li>mysql通过mvcc来实现事务的隔离级别的</li>\n</ol>\n<h4 id=\"mvcc\"><a href=\"#mvcc\" class=\"headerlink\" title=\"mvcc\"></a>mvcc</h4><p>multi version concurrency control，多版本并发控制。<br>事务的隔离级别是通过mvcc实现的，数据一般会存在有多个版本。<br>mysql中的读取叫做快照读，读取的时候会根据当前的隔离级别，建立一个读取的快照（里面保存了可以对数据读取的事务的版本）。</p>\n<h5 id=\"下面是索引的结构\"><a href=\"#下面是索引的结构\" class=\"headerlink\" title=\"下面是索引的结构\"></a>下面是索引的结构</h5><p>trx_id：该数据被提交修改了多少次（每行数据从0开始增长）<br>db_roll_ptr：在数据在undolog中的<br><img src=\"/images/MVCC1.jpg\" alt=\"索引结构\"><br>具体的操作<br><img src=\"/images/MVCC2.jpg\" alt=\"mvcc流程\"></p>\n<h4 id=\"隔离级别\"><a href=\"#隔离级别\" class=\"headerlink\" title=\"隔离级别\"></a>隔离级别</h4><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">隔离级别</th>\n<th style=\"text-align:center\">出现现象</th>\n<th style=\"text-align:center\">原因</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">未提交读</td>\n<td style=\"text-align:center\">脏读，不可重复读，幻读</td>\n<td style=\"text-align:center\">会直接读取当前行数据，即使当前行数据未提交</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">已提交读</td>\n<td style=\"text-align:center\">不可重复读，幻读</td>\n<td style=\"text-align:center\">会读取当前最新的已经提交的修改，但是避免不了幻读，<br>因为一个事务当中可能读取到其他事务的多次修改</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">可重复读</td>\n<td style=\"text-align:center\">幻读</td>\n<td style=\"text-align:center\">会根据当前快照中的数据事务版本号，去undo log中读取当前事务开始时候的初始数据</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">串行化</td>\n<td style=\"text-align:center\">无</td>\n<td style=\"text-align:center\">串行化就是直接加了排他锁</td>\n</tr>\n</tbody>\n</table>\n<p>innodb的可重复读还解决了幻读的问题，</p>\n<h4 id=\"log\"><a href=\"#log\" class=\"headerlink\" title=\"log\"></a>log</h4><ol>\n<li>redo log，mysql的很多修改都是直接修改的内存，并且将修改记录到了redo log中。redo log用于防止mysql被突然重启，但是还有内存中的修改并未被刷新到磁盘上的现象出现。mysql重启的时候，会\u001b读取redo log，用于重新执行那些已经提交的修改。</li>\n<li>undo log，用于记录事务的反向操作，可以用于事务的回滚</li>\n<li>bin log，服务器端对数据操作的日志，通常用于数据恢复和数据同步，mysql的主从同步就是slave去\u001bmaster上拉取最新的binlog去执行</li>\n</ol>\n<h4 id=\"字段新增\"><a href=\"#字段新增\" class=\"headerlink\" title=\"字段新增\"></a>字段新增</h4><ol>\n<li>复制旧表结构为新表</li>\n<li>新增一个字段</li>\n<li>将旧表数据复制过来（这时候就开始加表锁了）</li>\n<li>删除旧表，重命名新表</li>\n</ol>\n<p><strong>如何优化</strong><br>复制结构到新表，新增一个字段，将旧表数据复制过来，然后在旧表上面设置触发器，对数据的修改，同时全部通过触发器同步到新表之中，最后删除旧表，重命名新表</p>\n<h4 id=\"查询过程\"><a href=\"#查询过程\" class=\"headerlink\" title=\"查询过程\"></a>查询过程</h4><ol>\n<li>查询缓存（相同语句，直接走缓存回去了）</li>\n<li>词法分析，语法分析，语义分析，生成解析树</li>\n<li>\u001b交给查询优化器优化</li>\n<li>执行\u001b引擎执行<br><img src=\"/images/mysql查询过程.png\" alt=\"mysql查询过程\"></li>\n</ol>\n<h4 id=\"索引-1\"><a href=\"#索引-1\" class=\"headerlink\" title=\"索引\"></a>索引</h4><ol>\n<li>system，表中只有一行数据或为空</li>\n<li>const，查询结果只有一行数据，唯一索引或主键索引</li>\n<li>eq_ref，连接查询时，使用唯一索引查询</li>\n<li>ref，普通非唯一索引</li>\n<li>range，索引的范围扫描</li>\n<li>index，索引全扫描</li>\n<li>all，表全扫描</li>\n</ol>\n<h4 id=\"三范式\"><a href=\"#三范式\" class=\"headerlink\" title=\"三范式\"></a>三范式</h4><ol>\n<li>第一范式：属性不可拆分（地址可以再拆分为省市区）</li>\n<li>非主属性完全依赖于码（学生姓名完全依赖于学号）</li>\n<li>非主属性之间没有任何传递依赖（班主任工号和班主任姓名）</li>\n</ol>\n<h4 id=\"字符集\"><a href=\"#字符集\" class=\"headerlink\" title=\"字符集\"></a>字符集</h4><ol>\n<li>数据库字符集</li>\n<li>表字符集</li>\n<li>列字符集</li>\n</ol>"},{"title":"Queue分析","date":"2018-06-23T10:38:47.000Z","toc":true,"_content":"# 接口\n## queue\n- add，无法添加时候抛出异常\n- offer，无法添加时候返回false\n- poll，队列为空或者超时返回空\n- remove，删除某个元素，如果元素不存在，则抛出异常\n\n## blocking queue\n- put，无法添加则等待可以添加\n- take，队列为空，则等待到可取出元素为止\n- offer，超时等待版本\n- poll，超时等待版本\n<!-- more -->\n\n# PriorityQueue\n## 数据结构\n小根堆\n## 适用场景\n本质上是一个队列，但是是一个带有优先级的队列\b。元素插入的时候会进行\u001b比较，保证队列内的元素都是有序的。\n比如线程调度的时候，需要根据线程优先级去调度的。\n## 静态属性\n1. MAX_ARRAY_SIZE, Integer.MAX_VALUE - 8，**不是**队列的\b最大容量，最大仍为Integer.MAX_VALUE \n\n## 属性\n1. `int size = 0;`队列当前容量\n2. `Object[] queue;`队列存储的数组\n3. `final Comparator<? super E> comparator;`比较优先级使用的Comparator\n4. `int modCount = 0;`非幂等操作的计数\n\n## 特点\n1. 使用Comparator来做优先级比较，是小根堆\n2. 是用了大量的`Arrays.copyOf`来进行扩容\n\n## 主要方法\n### grow\n```java\n private void grow(int minCapacity) {\n    int oldCapacity = queue.length;\n    // Double size if small; else grow by 50%\n    // 队列比较小的情况下，2倍增长，比较大则1.5倍\n    int newCapacity = oldCapacity + ((oldCapacity < 64) ?\n                                        (oldCapacity + 2) :\n                                        (oldCapacity >> 1));\n    if (newCapacity - MAX_ARRAY_SIZE > 0)\n        newCapacity = hugeCapacity(minCapacity);\n    queue = Arrays.copyOf(queue, newCapacity);\n}\n```\n### add\n```java\npublic boolean offer(E e) {\n    if (e == null)\n        throw new NullPointerException();\n    modCount++;\n    int i = size;\n    if (i >= queue.length)\n        // 扩容\n        grow(i + 1);\n    size = i + 1;\n    if (i == 0)\n        queue[0] = e;\n    else\n        // 堆调整\n        siftUp(i, e);\n    return true;\n}\n\nprivate void siftUp(int k, E x) {\n    if (comparator != null)\n        siftUpUsingComparator(k, x);\n    else\n        siftUpComparable(k, x);\n}\n\n@SuppressWarnings(\"unchecked\")\nprivate void siftUpComparable(int k, E x) {\n    Comparable<? super E> key = (Comparable<? super E>) x;\n    while (k > 0) {\n        // 父节点\n        int parent = (k - 1) >>> 1;\n        Object e = queue[parent];\n        // 比父节点大，则break\n        if (key.compareTo((E) e) >= 0)\n            break;\n        // 比父节点小，则交换值\n        queue[k] = e;\n        k = parent;\n    }\n    queue[k] = key;\n}\n\n@SuppressWarnings(\"unchecked\")\nprivate void siftUpUsingComparator(int k, E x) {\n    while (k > 0) {\n        int parent = (k - 1) >>> 1;\n        Object e = queue[parent];\n        if (comparator.compare(x, (E) e) >= 0)\n            break;\n        queue[k] = e;\n        k = parent;\n    }\n    queue[k] = x;\n}\n```\n### poll\n```java\n public E poll() {\n    if (size == 0)\n        return null;\n    int s = --size;\n    modCount++;\n    E result = (E) queue[0];\n    E x = (E) queue[s];\n    queue[s] = null;\n    if (s != 0)\n        // 调整堆\n        siftDown(0, x);\n    return result;\n}\n\nprivate void siftDown(int k, E x) {\n    if (comparator != null)\n        siftDownUsingComparator(k, x);\n    else\n        siftDownComparable(k, x);\n}\n\n@SuppressWarnings(\"unchecked\")\nprivate void siftDownComparable(int k, E x) {\n    Comparable<? super E> key = (Comparable<? super E>)x;\n    int half = size >>> 1;        // loop while a non-leaf\n    while (k < half) {\n        int child = (k << 1) + 1; // assume left child is least\n        Object c = queue[child];\n        int right = child + 1;\n        // 选出左右叶子节点中比较大的一个\n        if (right < size &&\n            ((Comparable<? super E>) c).compareTo((E) queue[right]) > 0)\n            c = queue[child = right];\n        // 叶子节点都比自己大\n        if (key.compareTo((E) c) <= 0)\n            break;\n        queue[k] = c;\n        k = child;\n    }\n    queue[k] = key;\n}\n\n@SuppressWarnings(\"unchecked\")\nprivate void siftDownUsingComparator(int k, E x) {\n    int half = size >>> 1;\n    while (k < half) {\n        int child = (k << 1) + 1;\n        Object c = queue[child];\n        int right = child + 1;\n        if (right < size &&\n            comparator.compare((E) c, (E) queue[right]) > 0)\n            c = queue[child = right];\n        if (comparator.compare(x, (E) c) <= 0)\n            break;\n        queue[k] = c;\n        k = child;\n    }\n    queue[k] = x;\n}\n```\n****\n# ArrayDeque\n双端队列，底层是数组\n## 特点\n1. 默认长度是16，扩容每次扩两倍\n2. 拥有head和tail两个指针，用于对队列做循环操作\n3. 用了很多Arrays.copyOf和System.arraycopy\n\n***\n# ArrayBlockingQueue\n阻塞队列\n## 成员属性\n1. `Object[] items`，存储元素的数组\n2. `int takeIndex`，队列的头部\n3. `int putIndex`，\u001e队列的尾部\n4. `int count`，队列中元素的数量\n5. `ReentrantLock lock`，互斥锁，用于锁住非幂等操作使用\n6. `Condition notEmpty`，用于唤醒等待取数据的线程\n7. `Itrs itrs`，用于统一存储一些迭代器，便于控制迭代的准确性\n\n## 特点\n1. 为了线程安全，性能比较差，内部使用了ReentrantLock\n2. 容量是固定的，无法使用扩容\n\n## 主要方法\n### put\n```java\npublic void put(E e) throws InterruptedException {\n    checkNotNull(e);\n    final ReentrantLock lock = this.lock;\n    lock.lockInterruptibly();\n    try {\n        // 等待信号量，使用while为了保证不是signalAll触发的\n        while (count == items.length)\n            notFull.await();\n        enqueue(e);\n    } finally {\n        lock.unlock();\n    }\n}\nprivate void enqueue(E x) {\n    // assert lock.getHoldCount() == 1;\n    // assert items[putIndex] == null;\n    final Object[] items = this.items;\n    items[putIndex] = x;\n    if (++putIndex == items.length)\n        putIndex = 0;\n    count++;\n    // 唤醒信号量\n    notEmpty.signal();\n}\n```\n### poll\n```java\nprivate E dequeue() {\n    // assert lock.getHoldCount() == 1;\n    // assert items[takeIndex] != null;\n    final Object[] items = this.items;\n    @SuppressWarnings(\"unchecked\")\n    E x = (E) items[takeIndex];\n    items[takeIndex] = null;\n    if (++takeIndex == items.length)\n        takeIndex = 0;\n    count--;\n    if (itrs != null)\n        itrs.elementDequeued();\n    notFull.signal();\n    return x;\n}\npublic E poll() {\n    final ReentrantLock lock = this.lock;\n    lock.lock();\n    try {\n        return (count == 0) ? null : dequeue();\n    } finally {\n        lock.unlock();\n    }\n}\n```\n### Itrs\n```java\n// 这边把这个类的方法放出来\n// 从下面的方法可以看出，Itrs中保存了ArrayBlockingQueue对象中的所有迭代器\n// 内部\b是一个链表，用于保存所有的Iterator\n// \b每当\bqueue中做一些非幂等操作的时候，都会通知迭代器做响应的改变\n// 比如当`ArrayBlockingQueue.clear()`被调用的时候，\n// 都会顺带调用一下itrs.queueIsEmpty方法，把所有的保存的迭代器关闭并清空\nclass Itrs {\n    private class Node extends WeakReference<Itr> {\n        Node next;\n        Node(Itr iterator, Node next) {\n            super(iterator);\n            this.next = next;\n        }\n    }\n    int cycles = 0;\n    private Node head;\n    private Node sweeper = null;\n    private static final int SHORT_SWEEP_PROBES = 4;\n    private static final int LONG_SWEEP_PROBES = 16;\n\n    Itrs(Itr initial) {\n        register(initial);\n    }\n\n    void doSomeSweeping(boolean tryHarder) {    }\n\n    void register(Itr itr) {\n        head = new Node(itr, head);\n    }\n    void takeIndexWrapped() {    }\n    void removedAt(int removedIndex) {    }\n    void queueIsEmpty() {    }\n    void elementDequeued() {    }\n}\n```\n***\n# LinkedBlockingQueue\n和ArrayBlockinqQueue的区别就是底层是链表而已，**容量固定**\n> 稍微一些不同，LinkedBlockingQueue用了**两把锁，putLock和takeLock**，用于增加吞吐量。\n\n***\n# PriorityBlockingQueue\n和ArrayBlockinqQueue的区别就是底层是小根堆而已，**容量不固定的**，有餐构造函数传入的是初始大小\n\n*** \n# SynchronousQueue\n阻塞队列的一种，但是类似于生产者者消费者，放入的元素一定要被其他线程取走才能接触阻塞。\n\n## 数组结构\n底层使用了无锁链表（通过cas来构建链表）实现了栈和队列，用来实现公平与非公平。\n\n## 成员属性\n1.  transferer，Transferer对象，主要是实现无锁链表的。\n\n## 适用场景\n适合非常极端的场景。一对一的生产者消费者模式。\n\n## 重要方法\n### transfer\n```java\nstatic final class SNode {\n    volatile SNode next;        // next node in stack\n    volatile SNode match;       // the node matched to this\n    volatile Thread waiter;     // to control park/unpark\n    Object item;                // data; or null for REQUESTs\n    int mode;           // Note: item and mode \n}\n// 下面介绍的是栈\n// 链表内的节点有\u001b三种状态，request，data，fullfilling和canceled\n// request和data可以与fullfilling进行叠加\n// \b下面是队列的一个例子\n// request->request|canceled->request\n// 加入一个新的data节点，\n// 发现第一个是request节点，\b正好匹配，就尝试使用cas算法，将\u001b头结点移除，并且把数据给设置到match域中，并且再将睡眠的线程唤醒\n// 发现第一个节点是data节点，\b操作同上\n// 发现节点是一个request或者data节点，并且被取消了，因为时间到了，则直接将节点移除\nE transfer(E e, boolean timed, long nanos) {\n    SNode s = null; // constructed/reused as needed\n    int mode = (e == null) ? REQUEST : DATA;\n\n    // 这边是个死循环\n    for (;;) {\n        SNode h = head;\n        // 链表为空，或者头结点的模式和自己是一样的，证明头结点也在等待\n        if (h == null || h.mode == mode) {  // empty or same-mode\n            // 已经超时了 \n            if (timed && nanos <= 0) {      // can't wait\n                // 将cancel掉的节点删除\n                if (h != null && h.isCancelled())\n                    casHead(h, h.next);     // pop cancelled node\n                else\n                    return null;\n            // 将自己加入到链表中等待\n            } else if (casHead(h, s = snode(s, e, h, mode))) {\n                // 等待匹配\n                SNode m = awaitFulfill(s, timed, nanos);\n                // 证明超时\n                if (m == s) {               // wait was cancelled\n                    clean(s);\n                    return null;\n                }\n                // 直接将两个节点都删除\n                if ((h = head) != null && h.next == s)\n                    casHead(h, s.next);     // help s's fulfiller\n                return (E) ((mode == REQUEST) ? m.item : s.item);\n            }\n        // 当前头结点不在被匹配\n        } else if (!isFulfilling(h.mode)) { // try to fulfill\n            // 当前头结点已被删除\n            if (h.isCancelled())            // already cancelled\n                casHead(h, h.next);         // pop and retry\n            else if (casHead(h, s=snode(s, e, h, FULFILLING|mode))) {\n                for (;;) { // loop until matched or waiters disappear\n                    SNode m = s.next;       // m is s's match\n                    if (m == null) {        // all waiters are gone\n                        casHead(s, null);   // pop fulfill node\n                        s = null;           // use new node next time\n                        break;              // restart main loop\n                    }\n                    SNode mn = m.next;\n                    if (m.tryMatch(s)) {\n                        casHead(s, mn);     // pop both s and m\n                        return (E) ((mode == REQUEST) ? m.item : s.item);\n                    } else                  // lost match\n                        s.casNext(m, mn);   // help unlink\n                }\n            }\n        } else {                            // help a fulfiller\n            // 帮助匹配\n            SNode m = h.next;               // m is h's match\n            if (m == null)                  // waiter is gone\n                casHead(h, null);           // pop fulfilling node\n            else {\n                SNode mn = m.next;\n                if (m.tryMatch(h))          // help match\n                    casHead(h, mn);         // pop both h and m\n                else                        // lost match\n                    h.casNext(m, mn);       // help unlink\n            }\n        }\n    }\n}\n\nSNode awaitFulfill(SNode s, boolean timed, long nanos) {\n    final long deadline = timed ? System.nanoTime() + nanos : 0L;\n    Thread w = Thread.currentThread();\n    int spins = (shouldSpin(s) ?\n                    (timed ? maxTimedSpins : maxUntimedSpins) : 0);\n    // 这边使用自旋\n    for (;;) {\n        if (w.isInterrupted())\n            s.tryCancel();\n        SNode m = s.match;\n        if (m != null)\n            return m;\n        if (timed) {\n            nanos = deadline - System.nanoTime();\n            // 时间过期\n            if (nanos <= 0L) {\n                s.tryCancel();\n                continue;\n            }\n        }\n        if (spins > 0)\n            spins = shouldSpin(s) ? (spins-1) : 0;\n        else if (s.waiter == null)\n            s.waiter = w; // establish waiter so can park next iter\n        // 如果没有超时的话，一直等待\n        else if (!timed)\n            LockSupport.park(this);\n        // 超时等待\n        else if (nanos > spinForTimeoutThreshold)\n            LockSupport.parkNanos(this, nanos);\n    }\n}\n```","source":"_posts/Queue分析.md","raw":"---\ntitle: Queue分析\ndate: 2018-06-23 18:38:47\ntags:\n- java\n- 集合\n- 源码\ncategories:\n- java\n- 集合\ntoc: true\n---\n# 接口\n## queue\n- add，无法添加时候抛出异常\n- offer，无法添加时候返回false\n- poll，队列为空或者超时返回空\n- remove，删除某个元素，如果元素不存在，则抛出异常\n\n## blocking queue\n- put，无法添加则等待可以添加\n- take，队列为空，则等待到可取出元素为止\n- offer，超时等待版本\n- poll，超时等待版本\n<!-- more -->\n\n# PriorityQueue\n## 数据结构\n小根堆\n## 适用场景\n本质上是一个队列，但是是一个带有优先级的队列\b。元素插入的时候会进行\u001b比较，保证队列内的元素都是有序的。\n比如线程调度的时候，需要根据线程优先级去调度的。\n## 静态属性\n1. MAX_ARRAY_SIZE, Integer.MAX_VALUE - 8，**不是**队列的\b最大容量，最大仍为Integer.MAX_VALUE \n\n## 属性\n1. `int size = 0;`队列当前容量\n2. `Object[] queue;`队列存储的数组\n3. `final Comparator<? super E> comparator;`比较优先级使用的Comparator\n4. `int modCount = 0;`非幂等操作的计数\n\n## 特点\n1. 使用Comparator来做优先级比较，是小根堆\n2. 是用了大量的`Arrays.copyOf`来进行扩容\n\n## 主要方法\n### grow\n```java\n private void grow(int minCapacity) {\n    int oldCapacity = queue.length;\n    // Double size if small; else grow by 50%\n    // 队列比较小的情况下，2倍增长，比较大则1.5倍\n    int newCapacity = oldCapacity + ((oldCapacity < 64) ?\n                                        (oldCapacity + 2) :\n                                        (oldCapacity >> 1));\n    if (newCapacity - MAX_ARRAY_SIZE > 0)\n        newCapacity = hugeCapacity(minCapacity);\n    queue = Arrays.copyOf(queue, newCapacity);\n}\n```\n### add\n```java\npublic boolean offer(E e) {\n    if (e == null)\n        throw new NullPointerException();\n    modCount++;\n    int i = size;\n    if (i >= queue.length)\n        // 扩容\n        grow(i + 1);\n    size = i + 1;\n    if (i == 0)\n        queue[0] = e;\n    else\n        // 堆调整\n        siftUp(i, e);\n    return true;\n}\n\nprivate void siftUp(int k, E x) {\n    if (comparator != null)\n        siftUpUsingComparator(k, x);\n    else\n        siftUpComparable(k, x);\n}\n\n@SuppressWarnings(\"unchecked\")\nprivate void siftUpComparable(int k, E x) {\n    Comparable<? super E> key = (Comparable<? super E>) x;\n    while (k > 0) {\n        // 父节点\n        int parent = (k - 1) >>> 1;\n        Object e = queue[parent];\n        // 比父节点大，则break\n        if (key.compareTo((E) e) >= 0)\n            break;\n        // 比父节点小，则交换值\n        queue[k] = e;\n        k = parent;\n    }\n    queue[k] = key;\n}\n\n@SuppressWarnings(\"unchecked\")\nprivate void siftUpUsingComparator(int k, E x) {\n    while (k > 0) {\n        int parent = (k - 1) >>> 1;\n        Object e = queue[parent];\n        if (comparator.compare(x, (E) e) >= 0)\n            break;\n        queue[k] = e;\n        k = parent;\n    }\n    queue[k] = x;\n}\n```\n### poll\n```java\n public E poll() {\n    if (size == 0)\n        return null;\n    int s = --size;\n    modCount++;\n    E result = (E) queue[0];\n    E x = (E) queue[s];\n    queue[s] = null;\n    if (s != 0)\n        // 调整堆\n        siftDown(0, x);\n    return result;\n}\n\nprivate void siftDown(int k, E x) {\n    if (comparator != null)\n        siftDownUsingComparator(k, x);\n    else\n        siftDownComparable(k, x);\n}\n\n@SuppressWarnings(\"unchecked\")\nprivate void siftDownComparable(int k, E x) {\n    Comparable<? super E> key = (Comparable<? super E>)x;\n    int half = size >>> 1;        // loop while a non-leaf\n    while (k < half) {\n        int child = (k << 1) + 1; // assume left child is least\n        Object c = queue[child];\n        int right = child + 1;\n        // 选出左右叶子节点中比较大的一个\n        if (right < size &&\n            ((Comparable<? super E>) c).compareTo((E) queue[right]) > 0)\n            c = queue[child = right];\n        // 叶子节点都比自己大\n        if (key.compareTo((E) c) <= 0)\n            break;\n        queue[k] = c;\n        k = child;\n    }\n    queue[k] = key;\n}\n\n@SuppressWarnings(\"unchecked\")\nprivate void siftDownUsingComparator(int k, E x) {\n    int half = size >>> 1;\n    while (k < half) {\n        int child = (k << 1) + 1;\n        Object c = queue[child];\n        int right = child + 1;\n        if (right < size &&\n            comparator.compare((E) c, (E) queue[right]) > 0)\n            c = queue[child = right];\n        if (comparator.compare(x, (E) c) <= 0)\n            break;\n        queue[k] = c;\n        k = child;\n    }\n    queue[k] = x;\n}\n```\n****\n# ArrayDeque\n双端队列，底层是数组\n## 特点\n1. 默认长度是16，扩容每次扩两倍\n2. 拥有head和tail两个指针，用于对队列做循环操作\n3. 用了很多Arrays.copyOf和System.arraycopy\n\n***\n# ArrayBlockingQueue\n阻塞队列\n## 成员属性\n1. `Object[] items`，存储元素的数组\n2. `int takeIndex`，队列的头部\n3. `int putIndex`，\u001e队列的尾部\n4. `int count`，队列中元素的数量\n5. `ReentrantLock lock`，互斥锁，用于锁住非幂等操作使用\n6. `Condition notEmpty`，用于唤醒等待取数据的线程\n7. `Itrs itrs`，用于统一存储一些迭代器，便于控制迭代的准确性\n\n## 特点\n1. 为了线程安全，性能比较差，内部使用了ReentrantLock\n2. 容量是固定的，无法使用扩容\n\n## 主要方法\n### put\n```java\npublic void put(E e) throws InterruptedException {\n    checkNotNull(e);\n    final ReentrantLock lock = this.lock;\n    lock.lockInterruptibly();\n    try {\n        // 等待信号量，使用while为了保证不是signalAll触发的\n        while (count == items.length)\n            notFull.await();\n        enqueue(e);\n    } finally {\n        lock.unlock();\n    }\n}\nprivate void enqueue(E x) {\n    // assert lock.getHoldCount() == 1;\n    // assert items[putIndex] == null;\n    final Object[] items = this.items;\n    items[putIndex] = x;\n    if (++putIndex == items.length)\n        putIndex = 0;\n    count++;\n    // 唤醒信号量\n    notEmpty.signal();\n}\n```\n### poll\n```java\nprivate E dequeue() {\n    // assert lock.getHoldCount() == 1;\n    // assert items[takeIndex] != null;\n    final Object[] items = this.items;\n    @SuppressWarnings(\"unchecked\")\n    E x = (E) items[takeIndex];\n    items[takeIndex] = null;\n    if (++takeIndex == items.length)\n        takeIndex = 0;\n    count--;\n    if (itrs != null)\n        itrs.elementDequeued();\n    notFull.signal();\n    return x;\n}\npublic E poll() {\n    final ReentrantLock lock = this.lock;\n    lock.lock();\n    try {\n        return (count == 0) ? null : dequeue();\n    } finally {\n        lock.unlock();\n    }\n}\n```\n### Itrs\n```java\n// 这边把这个类的方法放出来\n// 从下面的方法可以看出，Itrs中保存了ArrayBlockingQueue对象中的所有迭代器\n// 内部\b是一个链表，用于保存所有的Iterator\n// \b每当\bqueue中做一些非幂等操作的时候，都会通知迭代器做响应的改变\n// 比如当`ArrayBlockingQueue.clear()`被调用的时候，\n// 都会顺带调用一下itrs.queueIsEmpty方法，把所有的保存的迭代器关闭并清空\nclass Itrs {\n    private class Node extends WeakReference<Itr> {\n        Node next;\n        Node(Itr iterator, Node next) {\n            super(iterator);\n            this.next = next;\n        }\n    }\n    int cycles = 0;\n    private Node head;\n    private Node sweeper = null;\n    private static final int SHORT_SWEEP_PROBES = 4;\n    private static final int LONG_SWEEP_PROBES = 16;\n\n    Itrs(Itr initial) {\n        register(initial);\n    }\n\n    void doSomeSweeping(boolean tryHarder) {    }\n\n    void register(Itr itr) {\n        head = new Node(itr, head);\n    }\n    void takeIndexWrapped() {    }\n    void removedAt(int removedIndex) {    }\n    void queueIsEmpty() {    }\n    void elementDequeued() {    }\n}\n```\n***\n# LinkedBlockingQueue\n和ArrayBlockinqQueue的区别就是底层是链表而已，**容量固定**\n> 稍微一些不同，LinkedBlockingQueue用了**两把锁，putLock和takeLock**，用于增加吞吐量。\n\n***\n# PriorityBlockingQueue\n和ArrayBlockinqQueue的区别就是底层是小根堆而已，**容量不固定的**，有餐构造函数传入的是初始大小\n\n*** \n# SynchronousQueue\n阻塞队列的一种，但是类似于生产者者消费者，放入的元素一定要被其他线程取走才能接触阻塞。\n\n## 数组结构\n底层使用了无锁链表（通过cas来构建链表）实现了栈和队列，用来实现公平与非公平。\n\n## 成员属性\n1.  transferer，Transferer对象，主要是实现无锁链表的。\n\n## 适用场景\n适合非常极端的场景。一对一的生产者消费者模式。\n\n## 重要方法\n### transfer\n```java\nstatic final class SNode {\n    volatile SNode next;        // next node in stack\n    volatile SNode match;       // the node matched to this\n    volatile Thread waiter;     // to control park/unpark\n    Object item;                // data; or null for REQUESTs\n    int mode;           // Note: item and mode \n}\n// 下面介绍的是栈\n// 链表内的节点有\u001b三种状态，request，data，fullfilling和canceled\n// request和data可以与fullfilling进行叠加\n// \b下面是队列的一个例子\n// request->request|canceled->request\n// 加入一个新的data节点，\n// 发现第一个是request节点，\b正好匹配，就尝试使用cas算法，将\u001b头结点移除，并且把数据给设置到match域中，并且再将睡眠的线程唤醒\n// 发现第一个节点是data节点，\b操作同上\n// 发现节点是一个request或者data节点，并且被取消了，因为时间到了，则直接将节点移除\nE transfer(E e, boolean timed, long nanos) {\n    SNode s = null; // constructed/reused as needed\n    int mode = (e == null) ? REQUEST : DATA;\n\n    // 这边是个死循环\n    for (;;) {\n        SNode h = head;\n        // 链表为空，或者头结点的模式和自己是一样的，证明头结点也在等待\n        if (h == null || h.mode == mode) {  // empty or same-mode\n            // 已经超时了 \n            if (timed && nanos <= 0) {      // can't wait\n                // 将cancel掉的节点删除\n                if (h != null && h.isCancelled())\n                    casHead(h, h.next);     // pop cancelled node\n                else\n                    return null;\n            // 将自己加入到链表中等待\n            } else if (casHead(h, s = snode(s, e, h, mode))) {\n                // 等待匹配\n                SNode m = awaitFulfill(s, timed, nanos);\n                // 证明超时\n                if (m == s) {               // wait was cancelled\n                    clean(s);\n                    return null;\n                }\n                // 直接将两个节点都删除\n                if ((h = head) != null && h.next == s)\n                    casHead(h, s.next);     // help s's fulfiller\n                return (E) ((mode == REQUEST) ? m.item : s.item);\n            }\n        // 当前头结点不在被匹配\n        } else if (!isFulfilling(h.mode)) { // try to fulfill\n            // 当前头结点已被删除\n            if (h.isCancelled())            // already cancelled\n                casHead(h, h.next);         // pop and retry\n            else if (casHead(h, s=snode(s, e, h, FULFILLING|mode))) {\n                for (;;) { // loop until matched or waiters disappear\n                    SNode m = s.next;       // m is s's match\n                    if (m == null) {        // all waiters are gone\n                        casHead(s, null);   // pop fulfill node\n                        s = null;           // use new node next time\n                        break;              // restart main loop\n                    }\n                    SNode mn = m.next;\n                    if (m.tryMatch(s)) {\n                        casHead(s, mn);     // pop both s and m\n                        return (E) ((mode == REQUEST) ? m.item : s.item);\n                    } else                  // lost match\n                        s.casNext(m, mn);   // help unlink\n                }\n            }\n        } else {                            // help a fulfiller\n            // 帮助匹配\n            SNode m = h.next;               // m is h's match\n            if (m == null)                  // waiter is gone\n                casHead(h, null);           // pop fulfilling node\n            else {\n                SNode mn = m.next;\n                if (m.tryMatch(h))          // help match\n                    casHead(h, mn);         // pop both h and m\n                else                        // lost match\n                    h.casNext(m, mn);       // help unlink\n            }\n        }\n    }\n}\n\nSNode awaitFulfill(SNode s, boolean timed, long nanos) {\n    final long deadline = timed ? System.nanoTime() + nanos : 0L;\n    Thread w = Thread.currentThread();\n    int spins = (shouldSpin(s) ?\n                    (timed ? maxTimedSpins : maxUntimedSpins) : 0);\n    // 这边使用自旋\n    for (;;) {\n        if (w.isInterrupted())\n            s.tryCancel();\n        SNode m = s.match;\n        if (m != null)\n            return m;\n        if (timed) {\n            nanos = deadline - System.nanoTime();\n            // 时间过期\n            if (nanos <= 0L) {\n                s.tryCancel();\n                continue;\n            }\n        }\n        if (spins > 0)\n            spins = shouldSpin(s) ? (spins-1) : 0;\n        else if (s.waiter == null)\n            s.waiter = w; // establish waiter so can park next iter\n        // 如果没有超时的话，一直等待\n        else if (!timed)\n            LockSupport.park(this);\n        // 超时等待\n        else if (nanos > spinForTimeoutThreshold)\n            LockSupport.parkNanos(this, nanos);\n    }\n}\n```","slug":"Queue分析","published":1,"updated":"2018-06-23T10:55:17.237Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5u1tv2000j1av8a61xtctn","content":"<h1 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h1><h2 id=\"queue\"><a href=\"#queue\" class=\"headerlink\" title=\"queue\"></a>queue</h2><ul>\n<li>add，无法添加时候抛出异常</li>\n<li>offer，无法添加时候返回false</li>\n<li>poll，队列为空或者超时返回空</li>\n<li>remove，删除某个元素，如果元素不存在，则抛出异常</li>\n</ul>\n<h2 id=\"blocking-queue\"><a href=\"#blocking-queue\" class=\"headerlink\" title=\"blocking queue\"></a>blocking queue</h2><ul>\n<li>put，无法添加则等待可以添加</li>\n<li>take，队列为空，则等待到可取出元素为止</li>\n<li>offer，超时等待版本</li>\n<li>poll，超时等待版本<a id=\"more\"></a>\n</li>\n</ul>\n<h1 id=\"PriorityQueue\"><a href=\"#PriorityQueue\" class=\"headerlink\" title=\"PriorityQueue\"></a>PriorityQueue</h1><h2 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h2><p>小根堆</p>\n<h2 id=\"适用场景\"><a href=\"#适用场景\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h2><p>本质上是一个队列，但是是一个带有优先级的队列\b。元素插入的时候会进行\u001b比较，保证队列内的元素都是有序的。<br>比如线程调度的时候，需要根据线程优先级去调度的。</p>\n<h2 id=\"静态属性\"><a href=\"#静态属性\" class=\"headerlink\" title=\"静态属性\"></a>静态属性</h2><ol>\n<li>MAX_ARRAY_SIZE, Integer.MAX_VALUE - 8，<strong>不是</strong>队列的\b最大容量，最大仍为Integer.MAX_VALUE </li>\n</ol>\n<h2 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h2><ol>\n<li><code>int size = 0;</code>队列当前容量</li>\n<li><code>Object[] queue;</code>队列存储的数组</li>\n<li><code>final Comparator&lt;? super E&gt; comparator;</code>比较优先级使用的Comparator</li>\n<li><code>int modCount = 0;</code>非幂等操作的计数</li>\n</ol>\n<h2 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h2><ol>\n<li>使用Comparator来做优先级比较，是小根堆</li>\n<li>是用了大量的<code>Arrays.copyOf</code>来进行扩容</li>\n</ol>\n<h2 id=\"主要方法\"><a href=\"#主要方法\" class=\"headerlink\" title=\"主要方法\"></a>主要方法</h2><h3 id=\"grow\"><a href=\"#grow\" class=\"headerlink\" title=\"grow\"></a>grow</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">grow</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldCapacity = queue.length;</span><br><span class=\"line\">    <span class=\"comment\">// Double size if small; else grow by 50%</span></span><br><span class=\"line\">    <span class=\"comment\">// 队列比较小的情况下，2倍增长，比较大则1.5倍</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> newCapacity = oldCapacity + ((oldCapacity &lt; <span class=\"number\">64</span>) ?</span><br><span class=\"line\">                                        (oldCapacity + <span class=\"number\">2</span>) :</span><br><span class=\"line\">                                        (oldCapacity &gt;&gt; <span class=\"number\">1</span>));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        newCapacity = hugeCapacity(minCapacity);</span><br><span class=\"line\">    queue = Arrays.copyOf(queue, newCapacity);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"add\"><a href=\"#add\" class=\"headerlink\" title=\"add\"></a>add</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">offer</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (e == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = size;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &gt;= queue.length)</span><br><span class=\"line\">        <span class=\"comment\">// 扩容</span></span><br><span class=\"line\">        grow(i + <span class=\"number\">1</span>);</span><br><span class=\"line\">    size = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span>)</span><br><span class=\"line\">        queue[<span class=\"number\">0</span>] = e;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"comment\">// 堆调整</span></span><br><span class=\"line\">        siftUp(i, e);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">siftUp</span><span class=\"params\">(<span class=\"keyword\">int</span> k, E x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (comparator != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        siftUpUsingComparator(k, x);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        siftUpComparable(k, x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">siftUpComparable</span><span class=\"params\">(<span class=\"keyword\">int</span> k, E x)</span> </span>&#123;</span><br><span class=\"line\">    Comparable&lt;? <span class=\"keyword\">super</span> E&gt; key = (Comparable&lt;? <span class=\"keyword\">super</span> E&gt;) x;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (k &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 父节点</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> parent = (k - <span class=\"number\">1</span>) &gt;&gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">        Object e = queue[parent];</span><br><span class=\"line\">        <span class=\"comment\">// 比父节点大，则break</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key.compareTo((E) e) &gt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 比父节点小，则交换值</span></span><br><span class=\"line\">        queue[k] = e;</span><br><span class=\"line\">        k = parent;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    queue[k] = key;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">siftUpUsingComparator</span><span class=\"params\">(<span class=\"keyword\">int</span> k, E x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (k &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> parent = (k - <span class=\"number\">1</span>) &gt;&gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">        Object e = queue[parent];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (comparator.compare(x, (E) e) &gt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        queue[k] = e;</span><br><span class=\"line\">        k = parent;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    queue[k] = x;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"poll\"><a href=\"#poll\" class=\"headerlink\" title=\"poll\"></a>poll</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">poll</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (size == <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> s = --size;</span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">    E result = (E) queue[<span class=\"number\">0</span>];</span><br><span class=\"line\">    E x = (E) queue[s];</span><br><span class=\"line\">    queue[s] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s != <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"comment\">// 调整堆</span></span><br><span class=\"line\">        siftDown(<span class=\"number\">0</span>, x);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">siftDown</span><span class=\"params\">(<span class=\"keyword\">int</span> k, E x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (comparator != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        siftDownUsingComparator(k, x);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        siftDownComparable(k, x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">siftDownComparable</span><span class=\"params\">(<span class=\"keyword\">int</span> k, E x)</span> </span>&#123;</span><br><span class=\"line\">    Comparable&lt;? <span class=\"keyword\">super</span> E&gt; key = (Comparable&lt;? <span class=\"keyword\">super</span> E&gt;)x;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> half = size &gt;&gt;&gt; <span class=\"number\">1</span>;        <span class=\"comment\">// loop while a non-leaf</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (k &lt; half) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> child = (k &lt;&lt; <span class=\"number\">1</span>) + <span class=\"number\">1</span>; <span class=\"comment\">// assume left child is least</span></span><br><span class=\"line\">        Object c = queue[child];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> right = child + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 选出左右叶子节点中比较大的一个</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (right &lt; size &amp;&amp;</span><br><span class=\"line\">            ((Comparable&lt;? <span class=\"keyword\">super</span> E&gt;) c).compareTo((E) queue[right]) &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            c = queue[child = right];</span><br><span class=\"line\">        <span class=\"comment\">// 叶子节点都比自己大</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key.compareTo((E) c) &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        queue[k] = c;</span><br><span class=\"line\">        k = child;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    queue[k] = key;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">siftDownUsingComparator</span><span class=\"params\">(<span class=\"keyword\">int</span> k, E x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> half = size &gt;&gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (k &lt; half) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> child = (k &lt;&lt; <span class=\"number\">1</span>) + <span class=\"number\">1</span>;</span><br><span class=\"line\">        Object c = queue[child];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> right = child + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (right &lt; size &amp;&amp;</span><br><span class=\"line\">            comparator.compare((E) c, (E) queue[right]) &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            c = queue[child = right];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (comparator.compare(x, (E) c) &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        queue[k] = c;</span><br><span class=\"line\">        k = child;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    queue[k] = x;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"ArrayDeque\"><a href=\"#ArrayDeque\" class=\"headerlink\" title=\"ArrayDeque\"></a>ArrayDeque</h1><p>双端队列，底层是数组</p>\n<h2 id=\"特点-1\"><a href=\"#特点-1\" class=\"headerlink\" title=\"特点\"></a>特点</h2><ol>\n<li>默认长度是16，扩容每次扩两倍</li>\n<li>拥有head和tail两个指针，用于对队列做循环操作</li>\n<li>用了很多Arrays.copyOf和System.arraycopy</li>\n</ol>\n<hr>\n<h1 id=\"ArrayBlockingQueue\"><a href=\"#ArrayBlockingQueue\" class=\"headerlink\" title=\"ArrayBlockingQueue\"></a>ArrayBlockingQueue</h1><p>阻塞队列</p>\n<h2 id=\"成员属性\"><a href=\"#成员属性\" class=\"headerlink\" title=\"成员属性\"></a>成员属性</h2><ol>\n<li><code>Object[] items</code>，存储元素的数组</li>\n<li><code>int takeIndex</code>，队列的头部</li>\n<li><code>int putIndex</code>，\u001e队列的尾部</li>\n<li><code>int count</code>，队列中元素的数量</li>\n<li><code>ReentrantLock lock</code>，互斥锁，用于锁住非幂等操作使用</li>\n<li><code>Condition notEmpty</code>，用于唤醒等待取数据的线程</li>\n<li><code>Itrs itrs</code>，用于统一存储一些迭代器，便于控制迭代的准确性</li>\n</ol>\n<h2 id=\"特点-2\"><a href=\"#特点-2\" class=\"headerlink\" title=\"特点\"></a>特点</h2><ol>\n<li>为了线程安全，性能比较差，内部使用了ReentrantLock</li>\n<li>容量是固定的，无法使用扩容</li>\n</ol>\n<h2 id=\"主要方法-1\"><a href=\"#主要方法-1\" class=\"headerlink\" title=\"主要方法\"></a>主要方法</h2><h3 id=\"put\"><a href=\"#put\" class=\"headerlink\" title=\"put\"></a>put</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">put</span><span class=\"params\">(E e)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    checkNotNull(e);</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ReentrantLock lock = <span class=\"keyword\">this</span>.lock;</span><br><span class=\"line\">    lock.lockInterruptibly();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 等待信号量，使用while为了保证不是signalAll触发的</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (count == items.length)</span><br><span class=\"line\">            notFull.await();</span><br><span class=\"line\">        enqueue(e);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">enqueue</span><span class=\"params\">(E x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// assert lock.getHoldCount() == 1;</span></span><br><span class=\"line\">    <span class=\"comment\">// assert items[putIndex] == null;</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Object[] items = <span class=\"keyword\">this</span>.items;</span><br><span class=\"line\">    items[putIndex] = x;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (++putIndex == items.length)</span><br><span class=\"line\">        putIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">    count++;</span><br><span class=\"line\">    <span class=\"comment\">// 唤醒信号量</span></span><br><span class=\"line\">    notEmpty.signal();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"poll-1\"><a href=\"#poll-1\" class=\"headerlink\" title=\"poll\"></a>poll</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> E <span class=\"title\">dequeue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// assert lock.getHoldCount() == 1;</span></span><br><span class=\"line\">    <span class=\"comment\">// assert items[takeIndex] != null;</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Object[] items = <span class=\"keyword\">this</span>.items;</span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">    E x = (E) items[takeIndex];</span><br><span class=\"line\">    items[takeIndex] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (++takeIndex == items.length)</span><br><span class=\"line\">        takeIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">    count--;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (itrs != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        itrs.elementDequeued();</span><br><span class=\"line\">    notFull.signal();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">poll</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ReentrantLock lock = <span class=\"keyword\">this</span>.lock;</span><br><span class=\"line\">    lock.lock();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (count == <span class=\"number\">0</span>) ? <span class=\"keyword\">null</span> : dequeue();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Itrs\"><a href=\"#Itrs\" class=\"headerlink\" title=\"Itrs\"></a>Itrs</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这边把这个类的方法放出来</span></span><br><span class=\"line\"><span class=\"comment\">// 从下面的方法可以看出，Itrs中保存了ArrayBlockingQueue对象中的所有迭代器</span></span><br><span class=\"line\"><span class=\"comment\">// 内部\b是一个链表，用于保存所有的Iterator</span></span><br><span class=\"line\"><span class=\"comment\">// \b每当\bqueue中做一些非幂等操作的时候，都会通知迭代器做响应的改变</span></span><br><span class=\"line\"><span class=\"comment\">// 比如当`ArrayBlockingQueue.clear()`被调用的时候，</span></span><br><span class=\"line\"><span class=\"comment\">// 都会顺带调用一下itrs.queueIsEmpty方法，把所有的保存的迭代器关闭并清空</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Itrs</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span> <span class=\"keyword\">extends</span> <span class=\"title\">WeakReference</span>&lt;<span class=\"title\">Itr</span>&gt; </span>&#123;</span><br><span class=\"line\">        Node next;</span><br><span class=\"line\">        Node(Itr iterator, Node next) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>(iterator);</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.next = next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> cycles = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Node head;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Node sweeper = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> SHORT_SWEEP_PROBES = <span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> LONG_SWEEP_PROBES = <span class=\"number\">16</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    Itrs(Itr initial) &#123;</span><br><span class=\"line\">        register(initial);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">doSomeSweeping</span><span class=\"params\">(<span class=\"keyword\">boolean</span> tryHarder)</span> </span>&#123;    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">register</span><span class=\"params\">(Itr itr)</span> </span>&#123;</span><br><span class=\"line\">        head = <span class=\"keyword\">new</span> Node(itr, head);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">takeIndexWrapped</span><span class=\"params\">()</span> </span>&#123;    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">removedAt</span><span class=\"params\">(<span class=\"keyword\">int</span> removedIndex)</span> </span>&#123;    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">queueIsEmpty</span><span class=\"params\">()</span> </span>&#123;    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">elementDequeued</span><span class=\"params\">()</span> </span>&#123;    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"LinkedBlockingQueue\"><a href=\"#LinkedBlockingQueue\" class=\"headerlink\" title=\"LinkedBlockingQueue\"></a>LinkedBlockingQueue</h1><p>和ArrayBlockinqQueue的区别就是底层是链表而已，<strong>容量固定</strong></p>\n<blockquote>\n<p>稍微一些不同，LinkedBlockingQueue用了<strong>两把锁，putLock和takeLock</strong>，用于增加吞吐量。</p>\n</blockquote>\n<hr>\n<h1 id=\"PriorityBlockingQueue\"><a href=\"#PriorityBlockingQueue\" class=\"headerlink\" title=\"PriorityBlockingQueue\"></a>PriorityBlockingQueue</h1><p>和ArrayBlockinqQueue的区别就是底层是小根堆而已，<strong>容量不固定的</strong>，有餐构造函数传入的是初始大小</p>\n<hr>\n<h1 id=\"SynchronousQueue\"><a href=\"#SynchronousQueue\" class=\"headerlink\" title=\"SynchronousQueue\"></a>SynchronousQueue</h1><p>阻塞队列的一种，但是类似于生产者者消费者，放入的元素一定要被其他线程取走才能接触阻塞。</p>\n<h2 id=\"数组结构\"><a href=\"#数组结构\" class=\"headerlink\" title=\"数组结构\"></a>数组结构</h2><p>底层使用了无锁链表（通过cas来构建链表）实现了栈和队列，用来实现公平与非公平。</p>\n<h2 id=\"成员属性-1\"><a href=\"#成员属性-1\" class=\"headerlink\" title=\"成员属性\"></a>成员属性</h2><ol>\n<li>transferer，Transferer对象，主要是实现无锁链表的。</li>\n</ol>\n<h2 id=\"适用场景-1\"><a href=\"#适用场景-1\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h2><p>适合非常极端的场景。一对一的生产者消费者模式。</p>\n<h2 id=\"重要方法\"><a href=\"#重要方法\" class=\"headerlink\" title=\"重要方法\"></a>重要方法</h2><h3 id=\"transfer\"><a href=\"#transfer\" class=\"headerlink\" title=\"transfer\"></a>transfer</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SNode</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> SNode next;        <span class=\"comment\">// next node in stack</span></span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> SNode match;       <span class=\"comment\">// the node matched to this</span></span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> Thread waiter;     <span class=\"comment\">// to control park/unpark</span></span><br><span class=\"line\">    Object item;                <span class=\"comment\">// data; or null for REQUESTs</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> mode;           <span class=\"comment\">// Note: item and mode </span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 下面介绍的是栈</span></span><br><span class=\"line\"><span class=\"comment\">// 链表内的节点有\u001b三种状态，request，data，fullfilling和canceled</span></span><br><span class=\"line\"><span class=\"comment\">// request和data可以与fullfilling进行叠加</span></span><br><span class=\"line\"><span class=\"comment\">// \b下面是队列的一个例子</span></span><br><span class=\"line\"><span class=\"comment\">// request-&gt;request|canceled-&gt;request</span></span><br><span class=\"line\"><span class=\"comment\">// 加入一个新的data节点，</span></span><br><span class=\"line\"><span class=\"comment\">// 发现第一个是request节点，\b正好匹配，就尝试使用cas算法，将\u001b头结点移除，并且把数据给设置到match域中，并且再将睡眠的线程唤醒</span></span><br><span class=\"line\"><span class=\"comment\">// 发现第一个节点是data节点，\b操作同上</span></span><br><span class=\"line\"><span class=\"comment\">// 发现节点是一个request或者data节点，并且被取消了，因为时间到了，则直接将节点移除</span></span><br><span class=\"line\"><span class=\"function\">E <span class=\"title\">transfer</span><span class=\"params\">(E e, <span class=\"keyword\">boolean</span> timed, <span class=\"keyword\">long</span> nanos)</span> </span>&#123;</span><br><span class=\"line\">    SNode s = <span class=\"keyword\">null</span>; <span class=\"comment\">// constructed/reused as needed</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> mode = (e == <span class=\"keyword\">null</span>) ? REQUEST : DATA;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 这边是个死循环</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        SNode h = head;</span><br><span class=\"line\">        <span class=\"comment\">// 链表为空，或者头结点的模式和自己是一样的，证明头结点也在等待</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (h == <span class=\"keyword\">null</span> || h.mode == mode) &#123;  <span class=\"comment\">// empty or same-mode</span></span><br><span class=\"line\">            <span class=\"comment\">// 已经超时了 </span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (timed &amp;&amp; nanos &lt;= <span class=\"number\">0</span>) &#123;      <span class=\"comment\">// can't wait</span></span><br><span class=\"line\">                <span class=\"comment\">// 将cancel掉的节点删除</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (h != <span class=\"keyword\">null</span> &amp;&amp; h.isCancelled())</span><br><span class=\"line\">                    casHead(h, h.next);     <span class=\"comment\">// pop cancelled node</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 将自己加入到链表中等待</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (casHead(h, s = snode(s, e, h, mode))) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 等待匹配</span></span><br><span class=\"line\">                SNode m = awaitFulfill(s, timed, nanos);</span><br><span class=\"line\">                <span class=\"comment\">// 证明超时</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (m == s) &#123;               <span class=\"comment\">// wait was cancelled</span></span><br><span class=\"line\">                    clean(s);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 直接将两个节点都删除</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((h = head) != <span class=\"keyword\">null</span> &amp;&amp; h.next == s)</span><br><span class=\"line\">                    casHead(h, s.next);     <span class=\"comment\">// help s's fulfiller</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> (E) ((mode == REQUEST) ? m.item : s.item);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 当前头结点不在被匹配</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!isFulfilling(h.mode)) &#123; <span class=\"comment\">// try to fulfill</span></span><br><span class=\"line\">            <span class=\"comment\">// 当前头结点已被删除</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (h.isCancelled())            <span class=\"comment\">// already cancelled</span></span><br><span class=\"line\">                casHead(h, h.next);         <span class=\"comment\">// pop and retry</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (casHead(h, s=snode(s, e, h, FULFILLING|mode))) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (;;) &#123; <span class=\"comment\">// loop until matched or waiters disappear</span></span><br><span class=\"line\">                    SNode m = s.next;       <span class=\"comment\">// m is s's match</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (m == <span class=\"keyword\">null</span>) &#123;        <span class=\"comment\">// all waiters are gone</span></span><br><span class=\"line\">                        casHead(s, <span class=\"keyword\">null</span>);   <span class=\"comment\">// pop fulfill node</span></span><br><span class=\"line\">                        s = <span class=\"keyword\">null</span>;           <span class=\"comment\">// use new node next time</span></span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;              <span class=\"comment\">// restart main loop</span></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    SNode mn = m.next;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (m.tryMatch(s)) &#123;</span><br><span class=\"line\">                        casHead(s, mn);     <span class=\"comment\">// pop both s and m</span></span><br><span class=\"line\">                        <span class=\"keyword\">return</span> (E) ((mode == REQUEST) ? m.item : s.item);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span>                  <span class=\"comment\">// lost match</span></span><br><span class=\"line\">                        s.casNext(m, mn);   <span class=\"comment\">// help unlink</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;                            <span class=\"comment\">// help a fulfiller</span></span><br><span class=\"line\">            <span class=\"comment\">// 帮助匹配</span></span><br><span class=\"line\">            SNode m = h.next;               <span class=\"comment\">// m is h's match</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (m == <span class=\"keyword\">null</span>)                  <span class=\"comment\">// waiter is gone</span></span><br><span class=\"line\">                casHead(h, <span class=\"keyword\">null</span>);           <span class=\"comment\">// pop fulfilling node</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                SNode mn = m.next;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (m.tryMatch(h))          <span class=\"comment\">// help match</span></span><br><span class=\"line\">                    casHead(h, mn);         <span class=\"comment\">// pop both h and m</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>                        <span class=\"comment\">// lost match</span></span><br><span class=\"line\">                    h.casNext(m, mn);       <span class=\"comment\">// help unlink</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">SNode <span class=\"title\">awaitFulfill</span><span class=\"params\">(SNode s, <span class=\"keyword\">boolean</span> timed, <span class=\"keyword\">long</span> nanos)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> deadline = timed ? System.nanoTime() + nanos : <span class=\"number\">0L</span>;</span><br><span class=\"line\">    Thread w = Thread.currentThread();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> spins = (shouldSpin(s) ?</span><br><span class=\"line\">                    (timed ? maxTimedSpins : maxUntimedSpins) : <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 这边使用自旋</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (w.isInterrupted())</span><br><span class=\"line\">            s.tryCancel();</span><br><span class=\"line\">        SNode m = s.match;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (m != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> m;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (timed) &#123;</span><br><span class=\"line\">            nanos = deadline - System.nanoTime();</span><br><span class=\"line\">            <span class=\"comment\">// 时间过期</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nanos &lt;= <span class=\"number\">0L</span>) &#123;</span><br><span class=\"line\">                s.tryCancel();</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (spins &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            spins = shouldSpin(s) ? (spins-<span class=\"number\">1</span>) : <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (s.waiter == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            s.waiter = w; <span class=\"comment\">// establish waiter so can park next iter</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果没有超时的话，一直等待</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!timed)</span><br><span class=\"line\">            LockSupport.park(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 超时等待</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nanos &gt; spinForTimeoutThreshold)</span><br><span class=\"line\">            LockSupport.parkNanos(<span class=\"keyword\">this</span>, nanos);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h1 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h1><h2 id=\"queue\"><a href=\"#queue\" class=\"headerlink\" title=\"queue\"></a>queue</h2><ul>\n<li>add，无法添加时候抛出异常</li>\n<li>offer，无法添加时候返回false</li>\n<li>poll，队列为空或者超时返回空</li>\n<li>remove，删除某个元素，如果元素不存在，则抛出异常</li>\n</ul>\n<h2 id=\"blocking-queue\"><a href=\"#blocking-queue\" class=\"headerlink\" title=\"blocking queue\"></a>blocking queue</h2><ul>\n<li>put，无法添加则等待可以添加</li>\n<li>take，队列为空，则等待到可取出元素为止</li>\n<li>offer，超时等待版本</li>\n<li>poll，超时等待版本","more":"</li>\n</ul>\n<h1 id=\"PriorityQueue\"><a href=\"#PriorityQueue\" class=\"headerlink\" title=\"PriorityQueue\"></a>PriorityQueue</h1><h2 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h2><p>小根堆</p>\n<h2 id=\"适用场景\"><a href=\"#适用场景\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h2><p>本质上是一个队列，但是是一个带有优先级的队列\b。元素插入的时候会进行\u001b比较，保证队列内的元素都是有序的。<br>比如线程调度的时候，需要根据线程优先级去调度的。</p>\n<h2 id=\"静态属性\"><a href=\"#静态属性\" class=\"headerlink\" title=\"静态属性\"></a>静态属性</h2><ol>\n<li>MAX_ARRAY_SIZE, Integer.MAX_VALUE - 8，<strong>不是</strong>队列的\b最大容量，最大仍为Integer.MAX_VALUE </li>\n</ol>\n<h2 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h2><ol>\n<li><code>int size = 0;</code>队列当前容量</li>\n<li><code>Object[] queue;</code>队列存储的数组</li>\n<li><code>final Comparator&lt;? super E&gt; comparator;</code>比较优先级使用的Comparator</li>\n<li><code>int modCount = 0;</code>非幂等操作的计数</li>\n</ol>\n<h2 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h2><ol>\n<li>使用Comparator来做优先级比较，是小根堆</li>\n<li>是用了大量的<code>Arrays.copyOf</code>来进行扩容</li>\n</ol>\n<h2 id=\"主要方法\"><a href=\"#主要方法\" class=\"headerlink\" title=\"主要方法\"></a>主要方法</h2><h3 id=\"grow\"><a href=\"#grow\" class=\"headerlink\" title=\"grow\"></a>grow</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">grow</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldCapacity = queue.length;</span><br><span class=\"line\">    <span class=\"comment\">// Double size if small; else grow by 50%</span></span><br><span class=\"line\">    <span class=\"comment\">// 队列比较小的情况下，2倍增长，比较大则1.5倍</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> newCapacity = oldCapacity + ((oldCapacity &lt; <span class=\"number\">64</span>) ?</span><br><span class=\"line\">                                        (oldCapacity + <span class=\"number\">2</span>) :</span><br><span class=\"line\">                                        (oldCapacity &gt;&gt; <span class=\"number\">1</span>));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        newCapacity = hugeCapacity(minCapacity);</span><br><span class=\"line\">    queue = Arrays.copyOf(queue, newCapacity);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"add\"><a href=\"#add\" class=\"headerlink\" title=\"add\"></a>add</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">offer</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (e == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = size;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &gt;= queue.length)</span><br><span class=\"line\">        <span class=\"comment\">// 扩容</span></span><br><span class=\"line\">        grow(i + <span class=\"number\">1</span>);</span><br><span class=\"line\">    size = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span>)</span><br><span class=\"line\">        queue[<span class=\"number\">0</span>] = e;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"comment\">// 堆调整</span></span><br><span class=\"line\">        siftUp(i, e);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">siftUp</span><span class=\"params\">(<span class=\"keyword\">int</span> k, E x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (comparator != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        siftUpUsingComparator(k, x);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        siftUpComparable(k, x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">siftUpComparable</span><span class=\"params\">(<span class=\"keyword\">int</span> k, E x)</span> </span>&#123;</span><br><span class=\"line\">    Comparable&lt;? <span class=\"keyword\">super</span> E&gt; key = (Comparable&lt;? <span class=\"keyword\">super</span> E&gt;) x;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (k &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 父节点</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> parent = (k - <span class=\"number\">1</span>) &gt;&gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">        Object e = queue[parent];</span><br><span class=\"line\">        <span class=\"comment\">// 比父节点大，则break</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key.compareTo((E) e) &gt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 比父节点小，则交换值</span></span><br><span class=\"line\">        queue[k] = e;</span><br><span class=\"line\">        k = parent;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    queue[k] = key;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">siftUpUsingComparator</span><span class=\"params\">(<span class=\"keyword\">int</span> k, E x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (k &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> parent = (k - <span class=\"number\">1</span>) &gt;&gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">        Object e = queue[parent];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (comparator.compare(x, (E) e) &gt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        queue[k] = e;</span><br><span class=\"line\">        k = parent;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    queue[k] = x;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"poll\"><a href=\"#poll\" class=\"headerlink\" title=\"poll\"></a>poll</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">poll</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (size == <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> s = --size;</span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">    E result = (E) queue[<span class=\"number\">0</span>];</span><br><span class=\"line\">    E x = (E) queue[s];</span><br><span class=\"line\">    queue[s] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s != <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"comment\">// 调整堆</span></span><br><span class=\"line\">        siftDown(<span class=\"number\">0</span>, x);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">siftDown</span><span class=\"params\">(<span class=\"keyword\">int</span> k, E x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (comparator != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        siftDownUsingComparator(k, x);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        siftDownComparable(k, x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">siftDownComparable</span><span class=\"params\">(<span class=\"keyword\">int</span> k, E x)</span> </span>&#123;</span><br><span class=\"line\">    Comparable&lt;? <span class=\"keyword\">super</span> E&gt; key = (Comparable&lt;? <span class=\"keyword\">super</span> E&gt;)x;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> half = size &gt;&gt;&gt; <span class=\"number\">1</span>;        <span class=\"comment\">// loop while a non-leaf</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (k &lt; half) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> child = (k &lt;&lt; <span class=\"number\">1</span>) + <span class=\"number\">1</span>; <span class=\"comment\">// assume left child is least</span></span><br><span class=\"line\">        Object c = queue[child];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> right = child + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 选出左右叶子节点中比较大的一个</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (right &lt; size &amp;&amp;</span><br><span class=\"line\">            ((Comparable&lt;? <span class=\"keyword\">super</span> E&gt;) c).compareTo((E) queue[right]) &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            c = queue[child = right];</span><br><span class=\"line\">        <span class=\"comment\">// 叶子节点都比自己大</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key.compareTo((E) c) &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        queue[k] = c;</span><br><span class=\"line\">        k = child;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    queue[k] = key;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">siftDownUsingComparator</span><span class=\"params\">(<span class=\"keyword\">int</span> k, E x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> half = size &gt;&gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (k &lt; half) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> child = (k &lt;&lt; <span class=\"number\">1</span>) + <span class=\"number\">1</span>;</span><br><span class=\"line\">        Object c = queue[child];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> right = child + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (right &lt; size &amp;&amp;</span><br><span class=\"line\">            comparator.compare((E) c, (E) queue[right]) &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            c = queue[child = right];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (comparator.compare(x, (E) c) &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        queue[k] = c;</span><br><span class=\"line\">        k = child;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    queue[k] = x;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"ArrayDeque\"><a href=\"#ArrayDeque\" class=\"headerlink\" title=\"ArrayDeque\"></a>ArrayDeque</h1><p>双端队列，底层是数组</p>\n<h2 id=\"特点-1\"><a href=\"#特点-1\" class=\"headerlink\" title=\"特点\"></a>特点</h2><ol>\n<li>默认长度是16，扩容每次扩两倍</li>\n<li>拥有head和tail两个指针，用于对队列做循环操作</li>\n<li>用了很多Arrays.copyOf和System.arraycopy</li>\n</ol>\n<hr>\n<h1 id=\"ArrayBlockingQueue\"><a href=\"#ArrayBlockingQueue\" class=\"headerlink\" title=\"ArrayBlockingQueue\"></a>ArrayBlockingQueue</h1><p>阻塞队列</p>\n<h2 id=\"成员属性\"><a href=\"#成员属性\" class=\"headerlink\" title=\"成员属性\"></a>成员属性</h2><ol>\n<li><code>Object[] items</code>，存储元素的数组</li>\n<li><code>int takeIndex</code>，队列的头部</li>\n<li><code>int putIndex</code>，\u001e队列的尾部</li>\n<li><code>int count</code>，队列中元素的数量</li>\n<li><code>ReentrantLock lock</code>，互斥锁，用于锁住非幂等操作使用</li>\n<li><code>Condition notEmpty</code>，用于唤醒等待取数据的线程</li>\n<li><code>Itrs itrs</code>，用于统一存储一些迭代器，便于控制迭代的准确性</li>\n</ol>\n<h2 id=\"特点-2\"><a href=\"#特点-2\" class=\"headerlink\" title=\"特点\"></a>特点</h2><ol>\n<li>为了线程安全，性能比较差，内部使用了ReentrantLock</li>\n<li>容量是固定的，无法使用扩容</li>\n</ol>\n<h2 id=\"主要方法-1\"><a href=\"#主要方法-1\" class=\"headerlink\" title=\"主要方法\"></a>主要方法</h2><h3 id=\"put\"><a href=\"#put\" class=\"headerlink\" title=\"put\"></a>put</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">put</span><span class=\"params\">(E e)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    checkNotNull(e);</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ReentrantLock lock = <span class=\"keyword\">this</span>.lock;</span><br><span class=\"line\">    lock.lockInterruptibly();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 等待信号量，使用while为了保证不是signalAll触发的</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (count == items.length)</span><br><span class=\"line\">            notFull.await();</span><br><span class=\"line\">        enqueue(e);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">enqueue</span><span class=\"params\">(E x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// assert lock.getHoldCount() == 1;</span></span><br><span class=\"line\">    <span class=\"comment\">// assert items[putIndex] == null;</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Object[] items = <span class=\"keyword\">this</span>.items;</span><br><span class=\"line\">    items[putIndex] = x;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (++putIndex == items.length)</span><br><span class=\"line\">        putIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">    count++;</span><br><span class=\"line\">    <span class=\"comment\">// 唤醒信号量</span></span><br><span class=\"line\">    notEmpty.signal();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"poll-1\"><a href=\"#poll-1\" class=\"headerlink\" title=\"poll\"></a>poll</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> E <span class=\"title\">dequeue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// assert lock.getHoldCount() == 1;</span></span><br><span class=\"line\">    <span class=\"comment\">// assert items[takeIndex] != null;</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Object[] items = <span class=\"keyword\">this</span>.items;</span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">    E x = (E) items[takeIndex];</span><br><span class=\"line\">    items[takeIndex] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (++takeIndex == items.length)</span><br><span class=\"line\">        takeIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">    count--;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (itrs != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        itrs.elementDequeued();</span><br><span class=\"line\">    notFull.signal();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">poll</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ReentrantLock lock = <span class=\"keyword\">this</span>.lock;</span><br><span class=\"line\">    lock.lock();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (count == <span class=\"number\">0</span>) ? <span class=\"keyword\">null</span> : dequeue();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Itrs\"><a href=\"#Itrs\" class=\"headerlink\" title=\"Itrs\"></a>Itrs</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这边把这个类的方法放出来</span></span><br><span class=\"line\"><span class=\"comment\">// 从下面的方法可以看出，Itrs中保存了ArrayBlockingQueue对象中的所有迭代器</span></span><br><span class=\"line\"><span class=\"comment\">// 内部\b是一个链表，用于保存所有的Iterator</span></span><br><span class=\"line\"><span class=\"comment\">// \b每当\bqueue中做一些非幂等操作的时候，都会通知迭代器做响应的改变</span></span><br><span class=\"line\"><span class=\"comment\">// 比如当`ArrayBlockingQueue.clear()`被调用的时候，</span></span><br><span class=\"line\"><span class=\"comment\">// 都会顺带调用一下itrs.queueIsEmpty方法，把所有的保存的迭代器关闭并清空</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Itrs</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span> <span class=\"keyword\">extends</span> <span class=\"title\">WeakReference</span>&lt;<span class=\"title\">Itr</span>&gt; </span>&#123;</span><br><span class=\"line\">        Node next;</span><br><span class=\"line\">        Node(Itr iterator, Node next) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>(iterator);</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.next = next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> cycles = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Node head;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Node sweeper = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> SHORT_SWEEP_PROBES = <span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> LONG_SWEEP_PROBES = <span class=\"number\">16</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    Itrs(Itr initial) &#123;</span><br><span class=\"line\">        register(initial);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">doSomeSweeping</span><span class=\"params\">(<span class=\"keyword\">boolean</span> tryHarder)</span> </span>&#123;    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">register</span><span class=\"params\">(Itr itr)</span> </span>&#123;</span><br><span class=\"line\">        head = <span class=\"keyword\">new</span> Node(itr, head);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">takeIndexWrapped</span><span class=\"params\">()</span> </span>&#123;    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">removedAt</span><span class=\"params\">(<span class=\"keyword\">int</span> removedIndex)</span> </span>&#123;    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">queueIsEmpty</span><span class=\"params\">()</span> </span>&#123;    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">elementDequeued</span><span class=\"params\">()</span> </span>&#123;    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"LinkedBlockingQueue\"><a href=\"#LinkedBlockingQueue\" class=\"headerlink\" title=\"LinkedBlockingQueue\"></a>LinkedBlockingQueue</h1><p>和ArrayBlockinqQueue的区别就是底层是链表而已，<strong>容量固定</strong></p>\n<blockquote>\n<p>稍微一些不同，LinkedBlockingQueue用了<strong>两把锁，putLock和takeLock</strong>，用于增加吞吐量。</p>\n</blockquote>\n<hr>\n<h1 id=\"PriorityBlockingQueue\"><a href=\"#PriorityBlockingQueue\" class=\"headerlink\" title=\"PriorityBlockingQueue\"></a>PriorityBlockingQueue</h1><p>和ArrayBlockinqQueue的区别就是底层是小根堆而已，<strong>容量不固定的</strong>，有餐构造函数传入的是初始大小</p>\n<hr>\n<h1 id=\"SynchronousQueue\"><a href=\"#SynchronousQueue\" class=\"headerlink\" title=\"SynchronousQueue\"></a>SynchronousQueue</h1><p>阻塞队列的一种，但是类似于生产者者消费者，放入的元素一定要被其他线程取走才能接触阻塞。</p>\n<h2 id=\"数组结构\"><a href=\"#数组结构\" class=\"headerlink\" title=\"数组结构\"></a>数组结构</h2><p>底层使用了无锁链表（通过cas来构建链表）实现了栈和队列，用来实现公平与非公平。</p>\n<h2 id=\"成员属性-1\"><a href=\"#成员属性-1\" class=\"headerlink\" title=\"成员属性\"></a>成员属性</h2><ol>\n<li>transferer，Transferer对象，主要是实现无锁链表的。</li>\n</ol>\n<h2 id=\"适用场景-1\"><a href=\"#适用场景-1\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h2><p>适合非常极端的场景。一对一的生产者消费者模式。</p>\n<h2 id=\"重要方法\"><a href=\"#重要方法\" class=\"headerlink\" title=\"重要方法\"></a>重要方法</h2><h3 id=\"transfer\"><a href=\"#transfer\" class=\"headerlink\" title=\"transfer\"></a>transfer</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SNode</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> SNode next;        <span class=\"comment\">// next node in stack</span></span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> SNode match;       <span class=\"comment\">// the node matched to this</span></span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> Thread waiter;     <span class=\"comment\">// to control park/unpark</span></span><br><span class=\"line\">    Object item;                <span class=\"comment\">// data; or null for REQUESTs</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> mode;           <span class=\"comment\">// Note: item and mode </span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 下面介绍的是栈</span></span><br><span class=\"line\"><span class=\"comment\">// 链表内的节点有\u001b三种状态，request，data，fullfilling和canceled</span></span><br><span class=\"line\"><span class=\"comment\">// request和data可以与fullfilling进行叠加</span></span><br><span class=\"line\"><span class=\"comment\">// \b下面是队列的一个例子</span></span><br><span class=\"line\"><span class=\"comment\">// request-&gt;request|canceled-&gt;request</span></span><br><span class=\"line\"><span class=\"comment\">// 加入一个新的data节点，</span></span><br><span class=\"line\"><span class=\"comment\">// 发现第一个是request节点，\b正好匹配，就尝试使用cas算法，将\u001b头结点移除，并且把数据给设置到match域中，并且再将睡眠的线程唤醒</span></span><br><span class=\"line\"><span class=\"comment\">// 发现第一个节点是data节点，\b操作同上</span></span><br><span class=\"line\"><span class=\"comment\">// 发现节点是一个request或者data节点，并且被取消了，因为时间到了，则直接将节点移除</span></span><br><span class=\"line\"><span class=\"function\">E <span class=\"title\">transfer</span><span class=\"params\">(E e, <span class=\"keyword\">boolean</span> timed, <span class=\"keyword\">long</span> nanos)</span> </span>&#123;</span><br><span class=\"line\">    SNode s = <span class=\"keyword\">null</span>; <span class=\"comment\">// constructed/reused as needed</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> mode = (e == <span class=\"keyword\">null</span>) ? REQUEST : DATA;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 这边是个死循环</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        SNode h = head;</span><br><span class=\"line\">        <span class=\"comment\">// 链表为空，或者头结点的模式和自己是一样的，证明头结点也在等待</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (h == <span class=\"keyword\">null</span> || h.mode == mode) &#123;  <span class=\"comment\">// empty or same-mode</span></span><br><span class=\"line\">            <span class=\"comment\">// 已经超时了 </span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (timed &amp;&amp; nanos &lt;= <span class=\"number\">0</span>) &#123;      <span class=\"comment\">// can't wait</span></span><br><span class=\"line\">                <span class=\"comment\">// 将cancel掉的节点删除</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (h != <span class=\"keyword\">null</span> &amp;&amp; h.isCancelled())</span><br><span class=\"line\">                    casHead(h, h.next);     <span class=\"comment\">// pop cancelled node</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 将自己加入到链表中等待</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (casHead(h, s = snode(s, e, h, mode))) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 等待匹配</span></span><br><span class=\"line\">                SNode m = awaitFulfill(s, timed, nanos);</span><br><span class=\"line\">                <span class=\"comment\">// 证明超时</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (m == s) &#123;               <span class=\"comment\">// wait was cancelled</span></span><br><span class=\"line\">                    clean(s);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 直接将两个节点都删除</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((h = head) != <span class=\"keyword\">null</span> &amp;&amp; h.next == s)</span><br><span class=\"line\">                    casHead(h, s.next);     <span class=\"comment\">// help s's fulfiller</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> (E) ((mode == REQUEST) ? m.item : s.item);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 当前头结点不在被匹配</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!isFulfilling(h.mode)) &#123; <span class=\"comment\">// try to fulfill</span></span><br><span class=\"line\">            <span class=\"comment\">// 当前头结点已被删除</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (h.isCancelled())            <span class=\"comment\">// already cancelled</span></span><br><span class=\"line\">                casHead(h, h.next);         <span class=\"comment\">// pop and retry</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (casHead(h, s=snode(s, e, h, FULFILLING|mode))) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (;;) &#123; <span class=\"comment\">// loop until matched or waiters disappear</span></span><br><span class=\"line\">                    SNode m = s.next;       <span class=\"comment\">// m is s's match</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (m == <span class=\"keyword\">null</span>) &#123;        <span class=\"comment\">// all waiters are gone</span></span><br><span class=\"line\">                        casHead(s, <span class=\"keyword\">null</span>);   <span class=\"comment\">// pop fulfill node</span></span><br><span class=\"line\">                        s = <span class=\"keyword\">null</span>;           <span class=\"comment\">// use new node next time</span></span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;              <span class=\"comment\">// restart main loop</span></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    SNode mn = m.next;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (m.tryMatch(s)) &#123;</span><br><span class=\"line\">                        casHead(s, mn);     <span class=\"comment\">// pop both s and m</span></span><br><span class=\"line\">                        <span class=\"keyword\">return</span> (E) ((mode == REQUEST) ? m.item : s.item);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span>                  <span class=\"comment\">// lost match</span></span><br><span class=\"line\">                        s.casNext(m, mn);   <span class=\"comment\">// help unlink</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;                            <span class=\"comment\">// help a fulfiller</span></span><br><span class=\"line\">            <span class=\"comment\">// 帮助匹配</span></span><br><span class=\"line\">            SNode m = h.next;               <span class=\"comment\">// m is h's match</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (m == <span class=\"keyword\">null</span>)                  <span class=\"comment\">// waiter is gone</span></span><br><span class=\"line\">                casHead(h, <span class=\"keyword\">null</span>);           <span class=\"comment\">// pop fulfilling node</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                SNode mn = m.next;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (m.tryMatch(h))          <span class=\"comment\">// help match</span></span><br><span class=\"line\">                    casHead(h, mn);         <span class=\"comment\">// pop both h and m</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>                        <span class=\"comment\">// lost match</span></span><br><span class=\"line\">                    h.casNext(m, mn);       <span class=\"comment\">// help unlink</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">SNode <span class=\"title\">awaitFulfill</span><span class=\"params\">(SNode s, <span class=\"keyword\">boolean</span> timed, <span class=\"keyword\">long</span> nanos)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> deadline = timed ? System.nanoTime() + nanos : <span class=\"number\">0L</span>;</span><br><span class=\"line\">    Thread w = Thread.currentThread();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> spins = (shouldSpin(s) ?</span><br><span class=\"line\">                    (timed ? maxTimedSpins : maxUntimedSpins) : <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 这边使用自旋</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (w.isInterrupted())</span><br><span class=\"line\">            s.tryCancel();</span><br><span class=\"line\">        SNode m = s.match;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (m != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> m;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (timed) &#123;</span><br><span class=\"line\">            nanos = deadline - System.nanoTime();</span><br><span class=\"line\">            <span class=\"comment\">// 时间过期</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nanos &lt;= <span class=\"number\">0L</span>) &#123;</span><br><span class=\"line\">                s.tryCancel();</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (spins &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            spins = shouldSpin(s) ? (spins-<span class=\"number\">1</span>) : <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (s.waiter == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            s.waiter = w; <span class=\"comment\">// establish waiter so can park next iter</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果没有超时的话，一直等待</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!timed)</span><br><span class=\"line\">            LockSupport.park(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 超时等待</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nanos &gt; spinForTimeoutThreshold)</span><br><span class=\"line\">            LockSupport.parkNanos(<span class=\"keyword\">this</span>, nanos);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"ScheduledThreadPoolExecutor分析","date":"2018-06-23T10:01:46.000Z","toc":true,"_content":"类似ThreadPoolExecutor，但是加了三个方法，`schedule()`，`scheduleAtFixedRate()`和`scheduleWithFixedDelay()`。\n<!-- more -->\n# 主要方法\n## DelayedWorkerQueue\n```java\nstatic class DelayedWorkQueue extends AbstractQueue<Runnable> implements BlockingQueue<Runnable> {\n    private static final int INITIAL_CAPACITY = 16;\n    private RunnableScheduledFuture<?>[] queue = new RunnableScheduledFuture<?>[INITIAL_CAPACITY];\n    // 内部一把锁，加锁\n    private final ReentrantLock lock = new ReentrantLock();\n    private final Condition available = lock.newCondition();\n    private int size = 0;\n    // leader代表当前线程正在等待\n    private Thread leader = null;\n\n    // 这边解释一下helpIndex，用于代表当前任务在整个队列当中处于的具体位置\n    private void setIndex(RunnableScheduledFuture<?> f, int idx) {\n        if (f instanceof ScheduledFutureTask)\n            ((ScheduledFutureTask)f).heapIndex = idx;\n    }\n\n    private void siftUp(int k, RunnableScheduledFuture<?> key) {\n        while (k > 0) {\n            int parent = (k - 1) >>> 1;\n            RunnableScheduledFuture<?> e = queue[parent];\n            if (key.compareTo(e) >= 0)\n                break;\n            queue[k] = e;\n            setIndex(e, k);\n            k = parent;\n        }\n        queue[k] = key;\n        setIndex(key, k);\n    }\n\n    private void siftDown(int k, RunnableScheduledFuture<?> key) {\n        int half = size >>> 1;\n        while (k < half) {\n            int child = (k << 1) + 1;\n            RunnableScheduledFuture<?> c = queue[child];\n            int right = child + 1;\n            if (right < size && c.compareTo(queue[right]) > 0)\n                c = queue[child = right];\n            if (key.compareTo(c) <= 0)\n                break;\n            queue[k] = c;\n            setIndex(c, k);\n            k = child;\n        }\n        queue[k] = key;\n        setIndex(key, k);\n    }\n\n    private void grow() {\n        int oldCapacity = queue.length;\n        int newCapacity = oldCapacity + (oldCapacity >> 1); // grow 50%\n\n        if (newCapacity < 0) // overflow\n            newCapacity = Integer.MAX_VALUE;\n        queue = Arrays.copyOf(queue, newCapacity);\n    }\n\n    // 删除\n    public boolean remove(Object x) {\n        final ReentrantLock lock = this.lock;\n        lock.lock();\n        try {\n            int i = indexOf(x);\n            if (i < 0)\n                return false;\n\n            setIndex(queue[i], -1);\n            int s = --size;\n            RunnableScheduledFuture<?> replacement = queue[s];\n            queue[s] = null;\n            if (s != i) {\n                // 调整根堆\n                siftDown(i, replacement);\n                if (queue[i] == replacement)\n                    siftUp(i, replacement);\n            }\n            return true;\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public int size() {\n        final ReentrantLock lock = this.lock;\n        lock.lock();\n        try {\n            return size;\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public boolean isEmpty() {\n        return size() == 0;\n    }\n\n    // 添加\n    public boolean offer(Runnable x) {\n        if (x == null)\n            throw new NullPointerException();\n        RunnableScheduledFuture<?> e = (RunnableScheduledFuture<?>)x;\n        final ReentrantLock lock = this.lock;\n        lock.lock();\n        try {\n            int i = size;\n            // 尝试插入\n            if (i >= queue.length)\n                grow();\n            size = i + 1;\n            if (i == 0) {\n                queue[0] = e;\n                setIndex(e, 0);\n            } else {\n                // 调整小根堆\n                siftUp(i, e);\n            }\n            // 队列头是e，代表数据刚插入，\n            // 第一个线程在等待\n            if (queue[0] == e) {\n                leader = null;\n                available.signal();\n            }\n        } finally {\n            lock.unlock();\n        }\n        return true;\n    }\n\n    // 获取\n    // 主要是几个点：\n    // 1. 多个线程可能同时进入，但是第一个线程会设置leader，使其!=null，第一个线程在退出时候会将leader设置为null，并且会signal线程\n    // 2. 其他线程则会无限期等待，每次插入数据的时候，会唤醒等待线程，去走1的逻辑\n    public RunnableScheduledFuture<?> take() throws InterruptedException {\n        final ReentrantLock lock = this.lock;\n        lock.lockInterruptibly();\n        try {\n            for (;;) {\n                RunnableScheduledFuture<?> first = queue[0];\n                if (first == null)\n                    // 等待\n                    available.await();\n                else {\n                    // 获取需要等待的时间\n                    long delay = first.getDelay(NANOSECONDS);\n                    if (delay <= 0)\n                        return finishPoll(first);\n                    first = null; // don't retain ref while waiting\n                    // 代表有线程在等待了\n                    if (leader != null)\n                        available.await();\n                    else {\n                        Thread thisThread = Thread.currentThread();\n                        leader = thisThread;\n                        try {\n                            available.awaitNanos(delay);\n                        } finally {\n                            if (leader == thisThread)\n                                leader = null;\n                        }\n                    }\n                }\n            }\n        } finally {\n            // 获取到了，并且队列中还有等待执行的数据\n            if (leader == null && queue[0] != null)\n                available.signal();\n            lock.unlock();\n        }\n    }\n\n    // 相比较take，poll在代码层面支持超时\n    public RunnableScheduledFuture<?> poll(long timeout, TimeUnit unit)\n            throws InterruptedException {\n        long nanos = unit.toNanos(timeout);\n        final ReentrantLock lock = this.lock;\n        lock.lockInterruptibly();\n        try {\n            for (;;) {\n                RunnableScheduledFuture<?> first = queue[0];\n                if (first == null) {\n                    if (nanos <= 0)\n                        return null;\n                    else\n                        nanos = available.awaitNanos(nanos);\n                } else {\n                    long delay = first.getDelay(NANOSECONDS);\n                    if (delay <= 0)\n                        return finishPoll(first);\n                    if (nanos <= 0)\n                        return null;\n                    // 为了更好的gc，在等待的时候清楚了本地引用\n                    first = null; // don't retain ref while waiting\n                    if (nanos < delay || leader != null)\n                        nanos = available.awaitNanos(nanos);\n                    else {\n                        Thread thisThread = Thread.currentThread();\n                        leader = thisThread;\n                        \n                        try {\n                            long timeLeft = available.awaitNanos(delay);\n                            nanos -= delay - timeLeft;\n                        } finally {\n                            if (leader == thisThread)\n                                leader = null;\n                        }\n                    }\n                }\n            }\n        } finally {\n            if (leader == null && queue[0] != null)\n                available.signal();\n            lock.unlock();\n        }\n    }\n\n    public void clear() {\n        final ReentrantLock lock = this.lock;\n        lock.lock();\n        try {\n            for (int i = 0; i < size; i++) {\n                RunnableScheduledFuture<?> t = queue[i];\n                if (t != null) {\n                    queue[i] = null;\n                    setIndex(t, -1);\n                }\n            }\n            size = 0;\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n```\n\n## ScheduledFutureTask\n```java\npublic void run() {\n    boolean periodic = isPeriodic();\n    // 不能运行\n    if (!canRunInCurrentRunState(periodic))\n        // 停止当前task，false代表不中断当前线程\n        cancel(false);\n    // 不是周期性执行\n    else if (!periodic)\n        ScheduledFutureTask.super.run();\n    // 是周期性执行，并且执行结果\b正常\n    // runAndReset只有在执行成功的时候才返回true\n    else if (ScheduledFutureTask.super.runAndReset()) {\n        // 计算下次执行时间\n        setNextRunTime();\n        // 再次进入DelayedWorkerQueue\n        reExecutePeriodic(outerTask);\n    }\n}\n```","source":"_posts/ScheduledThreadPoolExecutor分析.md","raw":"---\ntitle: ScheduledThreadPoolExecutor分析\ndate: 2018-06-23 18:01:46\ntags:\n- java\n- 多线程\n- 源码\ncategories: \n- java\n- 多线程\ntoc: true\n---\n类似ThreadPoolExecutor，但是加了三个方法，`schedule()`，`scheduleAtFixedRate()`和`scheduleWithFixedDelay()`。\n<!-- more -->\n# 主要方法\n## DelayedWorkerQueue\n```java\nstatic class DelayedWorkQueue extends AbstractQueue<Runnable> implements BlockingQueue<Runnable> {\n    private static final int INITIAL_CAPACITY = 16;\n    private RunnableScheduledFuture<?>[] queue = new RunnableScheduledFuture<?>[INITIAL_CAPACITY];\n    // 内部一把锁，加锁\n    private final ReentrantLock lock = new ReentrantLock();\n    private final Condition available = lock.newCondition();\n    private int size = 0;\n    // leader代表当前线程正在等待\n    private Thread leader = null;\n\n    // 这边解释一下helpIndex，用于代表当前任务在整个队列当中处于的具体位置\n    private void setIndex(RunnableScheduledFuture<?> f, int idx) {\n        if (f instanceof ScheduledFutureTask)\n            ((ScheduledFutureTask)f).heapIndex = idx;\n    }\n\n    private void siftUp(int k, RunnableScheduledFuture<?> key) {\n        while (k > 0) {\n            int parent = (k - 1) >>> 1;\n            RunnableScheduledFuture<?> e = queue[parent];\n            if (key.compareTo(e) >= 0)\n                break;\n            queue[k] = e;\n            setIndex(e, k);\n            k = parent;\n        }\n        queue[k] = key;\n        setIndex(key, k);\n    }\n\n    private void siftDown(int k, RunnableScheduledFuture<?> key) {\n        int half = size >>> 1;\n        while (k < half) {\n            int child = (k << 1) + 1;\n            RunnableScheduledFuture<?> c = queue[child];\n            int right = child + 1;\n            if (right < size && c.compareTo(queue[right]) > 0)\n                c = queue[child = right];\n            if (key.compareTo(c) <= 0)\n                break;\n            queue[k] = c;\n            setIndex(c, k);\n            k = child;\n        }\n        queue[k] = key;\n        setIndex(key, k);\n    }\n\n    private void grow() {\n        int oldCapacity = queue.length;\n        int newCapacity = oldCapacity + (oldCapacity >> 1); // grow 50%\n\n        if (newCapacity < 0) // overflow\n            newCapacity = Integer.MAX_VALUE;\n        queue = Arrays.copyOf(queue, newCapacity);\n    }\n\n    // 删除\n    public boolean remove(Object x) {\n        final ReentrantLock lock = this.lock;\n        lock.lock();\n        try {\n            int i = indexOf(x);\n            if (i < 0)\n                return false;\n\n            setIndex(queue[i], -1);\n            int s = --size;\n            RunnableScheduledFuture<?> replacement = queue[s];\n            queue[s] = null;\n            if (s != i) {\n                // 调整根堆\n                siftDown(i, replacement);\n                if (queue[i] == replacement)\n                    siftUp(i, replacement);\n            }\n            return true;\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public int size() {\n        final ReentrantLock lock = this.lock;\n        lock.lock();\n        try {\n            return size;\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public boolean isEmpty() {\n        return size() == 0;\n    }\n\n    // 添加\n    public boolean offer(Runnable x) {\n        if (x == null)\n            throw new NullPointerException();\n        RunnableScheduledFuture<?> e = (RunnableScheduledFuture<?>)x;\n        final ReentrantLock lock = this.lock;\n        lock.lock();\n        try {\n            int i = size;\n            // 尝试插入\n            if (i >= queue.length)\n                grow();\n            size = i + 1;\n            if (i == 0) {\n                queue[0] = e;\n                setIndex(e, 0);\n            } else {\n                // 调整小根堆\n                siftUp(i, e);\n            }\n            // 队列头是e，代表数据刚插入，\n            // 第一个线程在等待\n            if (queue[0] == e) {\n                leader = null;\n                available.signal();\n            }\n        } finally {\n            lock.unlock();\n        }\n        return true;\n    }\n\n    // 获取\n    // 主要是几个点：\n    // 1. 多个线程可能同时进入，但是第一个线程会设置leader，使其!=null，第一个线程在退出时候会将leader设置为null，并且会signal线程\n    // 2. 其他线程则会无限期等待，每次插入数据的时候，会唤醒等待线程，去走1的逻辑\n    public RunnableScheduledFuture<?> take() throws InterruptedException {\n        final ReentrantLock lock = this.lock;\n        lock.lockInterruptibly();\n        try {\n            for (;;) {\n                RunnableScheduledFuture<?> first = queue[0];\n                if (first == null)\n                    // 等待\n                    available.await();\n                else {\n                    // 获取需要等待的时间\n                    long delay = first.getDelay(NANOSECONDS);\n                    if (delay <= 0)\n                        return finishPoll(first);\n                    first = null; // don't retain ref while waiting\n                    // 代表有线程在等待了\n                    if (leader != null)\n                        available.await();\n                    else {\n                        Thread thisThread = Thread.currentThread();\n                        leader = thisThread;\n                        try {\n                            available.awaitNanos(delay);\n                        } finally {\n                            if (leader == thisThread)\n                                leader = null;\n                        }\n                    }\n                }\n            }\n        } finally {\n            // 获取到了，并且队列中还有等待执行的数据\n            if (leader == null && queue[0] != null)\n                available.signal();\n            lock.unlock();\n        }\n    }\n\n    // 相比较take，poll在代码层面支持超时\n    public RunnableScheduledFuture<?> poll(long timeout, TimeUnit unit)\n            throws InterruptedException {\n        long nanos = unit.toNanos(timeout);\n        final ReentrantLock lock = this.lock;\n        lock.lockInterruptibly();\n        try {\n            for (;;) {\n                RunnableScheduledFuture<?> first = queue[0];\n                if (first == null) {\n                    if (nanos <= 0)\n                        return null;\n                    else\n                        nanos = available.awaitNanos(nanos);\n                } else {\n                    long delay = first.getDelay(NANOSECONDS);\n                    if (delay <= 0)\n                        return finishPoll(first);\n                    if (nanos <= 0)\n                        return null;\n                    // 为了更好的gc，在等待的时候清楚了本地引用\n                    first = null; // don't retain ref while waiting\n                    if (nanos < delay || leader != null)\n                        nanos = available.awaitNanos(nanos);\n                    else {\n                        Thread thisThread = Thread.currentThread();\n                        leader = thisThread;\n                        \n                        try {\n                            long timeLeft = available.awaitNanos(delay);\n                            nanos -= delay - timeLeft;\n                        } finally {\n                            if (leader == thisThread)\n                                leader = null;\n                        }\n                    }\n                }\n            }\n        } finally {\n            if (leader == null && queue[0] != null)\n                available.signal();\n            lock.unlock();\n        }\n    }\n\n    public void clear() {\n        final ReentrantLock lock = this.lock;\n        lock.lock();\n        try {\n            for (int i = 0; i < size; i++) {\n                RunnableScheduledFuture<?> t = queue[i];\n                if (t != null) {\n                    queue[i] = null;\n                    setIndex(t, -1);\n                }\n            }\n            size = 0;\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n```\n\n## ScheduledFutureTask\n```java\npublic void run() {\n    boolean periodic = isPeriodic();\n    // 不能运行\n    if (!canRunInCurrentRunState(periodic))\n        // 停止当前task，false代表不中断当前线程\n        cancel(false);\n    // 不是周期性执行\n    else if (!periodic)\n        ScheduledFutureTask.super.run();\n    // 是周期性执行，并且执行结果\b正常\n    // runAndReset只有在执行成功的时候才返回true\n    else if (ScheduledFutureTask.super.runAndReset()) {\n        // 计算下次执行时间\n        setNextRunTime();\n        // 再次进入DelayedWorkerQueue\n        reExecutePeriodic(outerTask);\n    }\n}\n```","slug":"ScheduledThreadPoolExecutor分析","published":1,"updated":"2018-06-23T10:14:14.860Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5u1tv4000o1av8fyy1qwzk","content":"<p>类似ThreadPoolExecutor，但是加了三个方法，<code>schedule()</code>，<code>scheduleAtFixedRate()</code>和<code>scheduleWithFixedDelay()</code>。<br><a id=\"more\"></a></p>\n<h1 id=\"主要方法\"><a href=\"#主要方法\" class=\"headerlink\" title=\"主要方法\"></a>主要方法</h1><h2 id=\"DelayedWorkerQueue\"><a href=\"#DelayedWorkerQueue\" class=\"headerlink\" title=\"DelayedWorkerQueue\"></a>DelayedWorkerQueue</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DelayedWorkQueue</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractQueue</span>&lt;<span class=\"title\">Runnable</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">BlockingQueue</span>&lt;<span class=\"title\">Runnable</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> INITIAL_CAPACITY = <span class=\"number\">16</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> RunnableScheduledFuture&lt;?&gt;[] queue = <span class=\"keyword\">new</span> RunnableScheduledFuture&lt;?&gt;[INITIAL_CAPACITY];</span><br><span class=\"line\">    <span class=\"comment\">// 内部一把锁，加锁</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ReentrantLock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Condition available = lock.newCondition();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> size = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// leader代表当前线程正在等待</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Thread leader = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 这边解释一下helpIndex，用于代表当前任务在整个队列当中处于的具体位置</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">setIndex</span><span class=\"params\">(RunnableScheduledFuture&lt;?&gt; f, <span class=\"keyword\">int</span> idx)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (f <span class=\"keyword\">instanceof</span> ScheduledFutureTask)</span><br><span class=\"line\">            ((ScheduledFutureTask)f).heapIndex = idx;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">siftUp</span><span class=\"params\">(<span class=\"keyword\">int</span> k, RunnableScheduledFuture&lt;?&gt; key)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (k &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> parent = (k - <span class=\"number\">1</span>) &gt;&gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">            RunnableScheduledFuture&lt;?&gt; e = queue[parent];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (key.compareTo(e) &gt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            queue[k] = e;</span><br><span class=\"line\">            setIndex(e, k);</span><br><span class=\"line\">            k = parent;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        queue[k] = key;</span><br><span class=\"line\">        setIndex(key, k);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">siftDown</span><span class=\"params\">(<span class=\"keyword\">int</span> k, RunnableScheduledFuture&lt;?&gt; key)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> half = size &gt;&gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (k &lt; half) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> child = (k &lt;&lt; <span class=\"number\">1</span>) + <span class=\"number\">1</span>;</span><br><span class=\"line\">            RunnableScheduledFuture&lt;?&gt; c = queue[child];</span><br><span class=\"line\">            <span class=\"keyword\">int</span> right = child + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (right &lt; size &amp;&amp; c.compareTo(queue[right]) &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                c = queue[child = right];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (key.compareTo(c) &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            queue[k] = c;</span><br><span class=\"line\">            setIndex(c, k);</span><br><span class=\"line\">            k = child;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        queue[k] = key;</span><br><span class=\"line\">        setIndex(key, k);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">grow</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> oldCapacity = queue.length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class=\"number\">1</span>); <span class=\"comment\">// grow 50%</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newCapacity &lt; <span class=\"number\">0</span>) <span class=\"comment\">// overflow</span></span><br><span class=\"line\">            newCapacity = Integer.MAX_VALUE;</span><br><span class=\"line\">        queue = Arrays.copyOf(queue, newCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 删除</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">remove</span><span class=\"params\">(Object x)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> ReentrantLock lock = <span class=\"keyword\">this</span>.lock;</span><br><span class=\"line\">        lock.lock();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> i = indexOf(x);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            setIndex(queue[i], -<span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">int</span> s = --size;</span><br><span class=\"line\">            RunnableScheduledFuture&lt;?&gt; replacement = queue[s];</span><br><span class=\"line\">            queue[s] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (s != i) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 调整根堆</span></span><br><span class=\"line\">                siftDown(i, replacement);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (queue[i] == replacement)</span><br><span class=\"line\">                    siftUp(i, replacement);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">size</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> ReentrantLock lock = <span class=\"keyword\">this</span>.lock;</span><br><span class=\"line\">        lock.lock();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> size;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isEmpty</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> size() == <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 添加</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">offer</span><span class=\"params\">(Runnable x)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">        RunnableScheduledFuture&lt;?&gt; e = (RunnableScheduledFuture&lt;?&gt;)x;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> ReentrantLock lock = <span class=\"keyword\">this</span>.lock;</span><br><span class=\"line\">        lock.lock();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> i = size;</span><br><span class=\"line\">            <span class=\"comment\">// 尝试插入</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i &gt;= queue.length)</span><br><span class=\"line\">                grow();</span><br><span class=\"line\">            size = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                queue[<span class=\"number\">0</span>] = e;</span><br><span class=\"line\">                setIndex(e, <span class=\"number\">0</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 调整小根堆</span></span><br><span class=\"line\">                siftUp(i, e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 队列头是e，代表数据刚插入，</span></span><br><span class=\"line\">            <span class=\"comment\">// 第一个线程在等待</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (queue[<span class=\"number\">0</span>] == e) &#123;</span><br><span class=\"line\">                leader = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                available.signal();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取</span></span><br><span class=\"line\">    <span class=\"comment\">// 主要是几个点：</span></span><br><span class=\"line\">    <span class=\"comment\">// 1. 多个线程可能同时进入，但是第一个线程会设置leader，使其!=null，第一个线程在退出时候会将leader设置为null，并且会signal线程</span></span><br><span class=\"line\">    <span class=\"comment\">// 2. 其他线程则会无限期等待，每次插入数据的时候，会唤醒等待线程，去走1的逻辑</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> RunnableScheduledFuture&lt;?&gt; take() <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> ReentrantLock lock = <span class=\"keyword\">this</span>.lock;</span><br><span class=\"line\">        lock.lockInterruptibly();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">                RunnableScheduledFuture&lt;?&gt; first = queue[<span class=\"number\">0</span>];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (first == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    <span class=\"comment\">// 等待</span></span><br><span class=\"line\">                    available.await();</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 获取需要等待的时间</span></span><br><span class=\"line\">                    <span class=\"keyword\">long</span> delay = first.getDelay(NANOSECONDS);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (delay &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> finishPoll(first);</span><br><span class=\"line\">                    first = <span class=\"keyword\">null</span>; <span class=\"comment\">// don't retain ref while waiting</span></span><br><span class=\"line\">                    <span class=\"comment\">// 代表有线程在等待了</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (leader != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                        available.await();</span><br><span class=\"line\">                    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        Thread thisThread = Thread.currentThread();</span><br><span class=\"line\">                        leader = thisThread;</span><br><span class=\"line\">                        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                            available.awaitNanos(delay);</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (leader == thisThread)</span><br><span class=\"line\">                                leader = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 获取到了，并且队列中还有等待执行的数据</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (leader == <span class=\"keyword\">null</span> &amp;&amp; queue[<span class=\"number\">0</span>] != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                available.signal();</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 相比较take，poll在代码层面支持超时</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> RunnableScheduledFuture&lt;?&gt; poll(<span class=\"keyword\">long</span> timeout, TimeUnit unit)</span><br><span class=\"line\">            <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> nanos = unit.toNanos(timeout);</span><br><span class=\"line\">        <span class=\"keyword\">final</span> ReentrantLock lock = <span class=\"keyword\">this</span>.lock;</span><br><span class=\"line\">        lock.lockInterruptibly();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">                RunnableScheduledFuture&lt;?&gt; first = queue[<span class=\"number\">0</span>];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (first == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (nanos &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span></span><br><span class=\"line\">                        nanos = available.awaitNanos(nanos);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">long</span> delay = first.getDelay(NANOSECONDS);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (delay &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> finishPoll(first);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (nanos &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    <span class=\"comment\">// 为了更好的gc，在等待的时候清楚了本地引用</span></span><br><span class=\"line\">                    first = <span class=\"keyword\">null</span>; <span class=\"comment\">// don't retain ref while waiting</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (nanos &lt; delay || leader != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                        nanos = available.awaitNanos(nanos);</span><br><span class=\"line\">                    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        Thread thisThread = Thread.currentThread();</span><br><span class=\"line\">                        leader = thisThread;</span><br><span class=\"line\">                        </span><br><span class=\"line\">                        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">long</span> timeLeft = available.awaitNanos(delay);</span><br><span class=\"line\">                            nanos -= delay - timeLeft;</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (leader == thisThread)</span><br><span class=\"line\">                                leader = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (leader == <span class=\"keyword\">null</span> &amp;&amp; queue[<span class=\"number\">0</span>] != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                available.signal();</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">clear</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> ReentrantLock lock = <span class=\"keyword\">this</span>.lock;</span><br><span class=\"line\">        lock.lock();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++) &#123;</span><br><span class=\"line\">                RunnableScheduledFuture&lt;?&gt; t = queue[i];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (t != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    queue[i] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    setIndex(t, -<span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            size = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"ScheduledFutureTask\"><a href=\"#ScheduledFutureTask\" class=\"headerlink\" title=\"ScheduledFutureTask\"></a>ScheduledFutureTask</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> periodic = isPeriodic();</span><br><span class=\"line\">    <span class=\"comment\">// 不能运行</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!canRunInCurrentRunState(periodic))</span><br><span class=\"line\">        <span class=\"comment\">// 停止当前task，false代表不中断当前线程</span></span><br><span class=\"line\">        cancel(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 不是周期性执行</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!periodic)</span><br><span class=\"line\">        ScheduledFutureTask.<span class=\"keyword\">super</span>.run();</span><br><span class=\"line\">    <span class=\"comment\">// 是周期性执行，并且执行结果\b正常</span></span><br><span class=\"line\">    <span class=\"comment\">// runAndReset只有在执行成功的时候才返回true</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ScheduledFutureTask.<span class=\"keyword\">super</span>.runAndReset()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 计算下次执行时间</span></span><br><span class=\"line\">        setNextRunTime();</span><br><span class=\"line\">        <span class=\"comment\">// 再次进入DelayedWorkerQueue</span></span><br><span class=\"line\">        reExecutePeriodic(outerTask);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>类似ThreadPoolExecutor，但是加了三个方法，<code>schedule()</code>，<code>scheduleAtFixedRate()</code>和<code>scheduleWithFixedDelay()</code>。<br>","more":"</p>\n<h1 id=\"主要方法\"><a href=\"#主要方法\" class=\"headerlink\" title=\"主要方法\"></a>主要方法</h1><h2 id=\"DelayedWorkerQueue\"><a href=\"#DelayedWorkerQueue\" class=\"headerlink\" title=\"DelayedWorkerQueue\"></a>DelayedWorkerQueue</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DelayedWorkQueue</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractQueue</span>&lt;<span class=\"title\">Runnable</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">BlockingQueue</span>&lt;<span class=\"title\">Runnable</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> INITIAL_CAPACITY = <span class=\"number\">16</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> RunnableScheduledFuture&lt;?&gt;[] queue = <span class=\"keyword\">new</span> RunnableScheduledFuture&lt;?&gt;[INITIAL_CAPACITY];</span><br><span class=\"line\">    <span class=\"comment\">// 内部一把锁，加锁</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ReentrantLock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Condition available = lock.newCondition();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> size = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// leader代表当前线程正在等待</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Thread leader = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 这边解释一下helpIndex，用于代表当前任务在整个队列当中处于的具体位置</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">setIndex</span><span class=\"params\">(RunnableScheduledFuture&lt;?&gt; f, <span class=\"keyword\">int</span> idx)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (f <span class=\"keyword\">instanceof</span> ScheduledFutureTask)</span><br><span class=\"line\">            ((ScheduledFutureTask)f).heapIndex = idx;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">siftUp</span><span class=\"params\">(<span class=\"keyword\">int</span> k, RunnableScheduledFuture&lt;?&gt; key)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (k &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> parent = (k - <span class=\"number\">1</span>) &gt;&gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">            RunnableScheduledFuture&lt;?&gt; e = queue[parent];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (key.compareTo(e) &gt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            queue[k] = e;</span><br><span class=\"line\">            setIndex(e, k);</span><br><span class=\"line\">            k = parent;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        queue[k] = key;</span><br><span class=\"line\">        setIndex(key, k);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">siftDown</span><span class=\"params\">(<span class=\"keyword\">int</span> k, RunnableScheduledFuture&lt;?&gt; key)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> half = size &gt;&gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (k &lt; half) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> child = (k &lt;&lt; <span class=\"number\">1</span>) + <span class=\"number\">1</span>;</span><br><span class=\"line\">            RunnableScheduledFuture&lt;?&gt; c = queue[child];</span><br><span class=\"line\">            <span class=\"keyword\">int</span> right = child + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (right &lt; size &amp;&amp; c.compareTo(queue[right]) &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                c = queue[child = right];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (key.compareTo(c) &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            queue[k] = c;</span><br><span class=\"line\">            setIndex(c, k);</span><br><span class=\"line\">            k = child;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        queue[k] = key;</span><br><span class=\"line\">        setIndex(key, k);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">grow</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> oldCapacity = queue.length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class=\"number\">1</span>); <span class=\"comment\">// grow 50%</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newCapacity &lt; <span class=\"number\">0</span>) <span class=\"comment\">// overflow</span></span><br><span class=\"line\">            newCapacity = Integer.MAX_VALUE;</span><br><span class=\"line\">        queue = Arrays.copyOf(queue, newCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 删除</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">remove</span><span class=\"params\">(Object x)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> ReentrantLock lock = <span class=\"keyword\">this</span>.lock;</span><br><span class=\"line\">        lock.lock();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> i = indexOf(x);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            setIndex(queue[i], -<span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">int</span> s = --size;</span><br><span class=\"line\">            RunnableScheduledFuture&lt;?&gt; replacement = queue[s];</span><br><span class=\"line\">            queue[s] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (s != i) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 调整根堆</span></span><br><span class=\"line\">                siftDown(i, replacement);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (queue[i] == replacement)</span><br><span class=\"line\">                    siftUp(i, replacement);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">size</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> ReentrantLock lock = <span class=\"keyword\">this</span>.lock;</span><br><span class=\"line\">        lock.lock();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> size;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isEmpty</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> size() == <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 添加</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">offer</span><span class=\"params\">(Runnable x)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">        RunnableScheduledFuture&lt;?&gt; e = (RunnableScheduledFuture&lt;?&gt;)x;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> ReentrantLock lock = <span class=\"keyword\">this</span>.lock;</span><br><span class=\"line\">        lock.lock();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> i = size;</span><br><span class=\"line\">            <span class=\"comment\">// 尝试插入</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i &gt;= queue.length)</span><br><span class=\"line\">                grow();</span><br><span class=\"line\">            size = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                queue[<span class=\"number\">0</span>] = e;</span><br><span class=\"line\">                setIndex(e, <span class=\"number\">0</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 调整小根堆</span></span><br><span class=\"line\">                siftUp(i, e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 队列头是e，代表数据刚插入，</span></span><br><span class=\"line\">            <span class=\"comment\">// 第一个线程在等待</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (queue[<span class=\"number\">0</span>] == e) &#123;</span><br><span class=\"line\">                leader = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                available.signal();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取</span></span><br><span class=\"line\">    <span class=\"comment\">// 主要是几个点：</span></span><br><span class=\"line\">    <span class=\"comment\">// 1. 多个线程可能同时进入，但是第一个线程会设置leader，使其!=null，第一个线程在退出时候会将leader设置为null，并且会signal线程</span></span><br><span class=\"line\">    <span class=\"comment\">// 2. 其他线程则会无限期等待，每次插入数据的时候，会唤醒等待线程，去走1的逻辑</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> RunnableScheduledFuture&lt;?&gt; take() <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> ReentrantLock lock = <span class=\"keyword\">this</span>.lock;</span><br><span class=\"line\">        lock.lockInterruptibly();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">                RunnableScheduledFuture&lt;?&gt; first = queue[<span class=\"number\">0</span>];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (first == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    <span class=\"comment\">// 等待</span></span><br><span class=\"line\">                    available.await();</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 获取需要等待的时间</span></span><br><span class=\"line\">                    <span class=\"keyword\">long</span> delay = first.getDelay(NANOSECONDS);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (delay &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> finishPoll(first);</span><br><span class=\"line\">                    first = <span class=\"keyword\">null</span>; <span class=\"comment\">// don't retain ref while waiting</span></span><br><span class=\"line\">                    <span class=\"comment\">// 代表有线程在等待了</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (leader != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                        available.await();</span><br><span class=\"line\">                    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        Thread thisThread = Thread.currentThread();</span><br><span class=\"line\">                        leader = thisThread;</span><br><span class=\"line\">                        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                            available.awaitNanos(delay);</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (leader == thisThread)</span><br><span class=\"line\">                                leader = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 获取到了，并且队列中还有等待执行的数据</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (leader == <span class=\"keyword\">null</span> &amp;&amp; queue[<span class=\"number\">0</span>] != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                available.signal();</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 相比较take，poll在代码层面支持超时</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> RunnableScheduledFuture&lt;?&gt; poll(<span class=\"keyword\">long</span> timeout, TimeUnit unit)</span><br><span class=\"line\">            <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> nanos = unit.toNanos(timeout);</span><br><span class=\"line\">        <span class=\"keyword\">final</span> ReentrantLock lock = <span class=\"keyword\">this</span>.lock;</span><br><span class=\"line\">        lock.lockInterruptibly();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">                RunnableScheduledFuture&lt;?&gt; first = queue[<span class=\"number\">0</span>];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (first == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (nanos &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span></span><br><span class=\"line\">                        nanos = available.awaitNanos(nanos);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">long</span> delay = first.getDelay(NANOSECONDS);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (delay &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> finishPoll(first);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (nanos &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    <span class=\"comment\">// 为了更好的gc，在等待的时候清楚了本地引用</span></span><br><span class=\"line\">                    first = <span class=\"keyword\">null</span>; <span class=\"comment\">// don't retain ref while waiting</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (nanos &lt; delay || leader != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                        nanos = available.awaitNanos(nanos);</span><br><span class=\"line\">                    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        Thread thisThread = Thread.currentThread();</span><br><span class=\"line\">                        leader = thisThread;</span><br><span class=\"line\">                        </span><br><span class=\"line\">                        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">long</span> timeLeft = available.awaitNanos(delay);</span><br><span class=\"line\">                            nanos -= delay - timeLeft;</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (leader == thisThread)</span><br><span class=\"line\">                                leader = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (leader == <span class=\"keyword\">null</span> &amp;&amp; queue[<span class=\"number\">0</span>] != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                available.signal();</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">clear</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> ReentrantLock lock = <span class=\"keyword\">this</span>.lock;</span><br><span class=\"line\">        lock.lock();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++) &#123;</span><br><span class=\"line\">                RunnableScheduledFuture&lt;?&gt; t = queue[i];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (t != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    queue[i] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    setIndex(t, -<span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            size = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"ScheduledFutureTask\"><a href=\"#ScheduledFutureTask\" class=\"headerlink\" title=\"ScheduledFutureTask\"></a>ScheduledFutureTask</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> periodic = isPeriodic();</span><br><span class=\"line\">    <span class=\"comment\">// 不能运行</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!canRunInCurrentRunState(periodic))</span><br><span class=\"line\">        <span class=\"comment\">// 停止当前task，false代表不中断当前线程</span></span><br><span class=\"line\">        cancel(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 不是周期性执行</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!periodic)</span><br><span class=\"line\">        ScheduledFutureTask.<span class=\"keyword\">super</span>.run();</span><br><span class=\"line\">    <span class=\"comment\">// 是周期性执行，并且执行结果\b正常</span></span><br><span class=\"line\">    <span class=\"comment\">// runAndReset只有在执行成功的时候才返回true</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ScheduledFutureTask.<span class=\"keyword\">super</span>.runAndReset()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 计算下次执行时间</span></span><br><span class=\"line\">        setNextRunTime();</span><br><span class=\"line\">        <span class=\"comment\">// 再次进入DelayedWorkerQueue</span></span><br><span class=\"line\">        reExecutePeriodic(outerTask);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Set分析","date":"2018-06-23T10:38:55.000Z","toc":true,"_content":"不分析了，基本所有的Set都是基于相对应的Map实现的，区别是value是一个固定值而已。","source":"_posts/Set分析.md","raw":"---\ntitle: Set分析\ndate: 2018-06-23 18:38:55\ntags:\n- java\n- 集合\n- 源码\ncategories:\n- java\n- 集合\ntoc: true\n---\n不分析了，基本所有的Set都是基于相对应的Map实现的，区别是value是一个固定值而已。","slug":"Set分析","published":1,"updated":"2018-06-23T10:51:19.350Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5u1tv6000q1av8tl4swwjm","content":"<p>不分析了，基本所有的Set都是基于相对应的Map实现的，区别是value是一个固定值而已。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>不分析了，基本所有的Set都是基于相对应的Map实现的，区别是value是一个固定值而已。</p>\n"},{"title":"RocketMQ笔记","date":"2018-06-24T08:14:37.000Z","_content":"#### 介绍\n1. rocket来源于阿里中间件团队，前身是kafaka，改进了kafka在消息可靠性\n2. kafka是linkedin公司为了收集日志开发的消息中间件，scala语言编写，吞吐量单机在100万左右\n3. kafka吞吐量高的一个原因是是，客户端发送消息是会进行合并，将多个消息一起发送给服务端，服务端同时处理\n4. 两个消息的写入都会同时使用页写入的策略，一次写入一页的消息，效率更高\n<!-- more -->\n\n#### 模式\n1. 点对点，p2p\n2. 发布/订阅，topic\nons上为集群模式，或者是广播模式，配置中心在广播模式之下\n\n#### 概念\n1. topic，用于区分消息的业务类型\n2. queue，最大数量为4（可调整），从属于topic，消息是按照queue的维度来进行存储和发送的，每个消息都会归属于一个指定的queue（默认三种路由策略，随机，一致性hash，和机器随机\n3. consumer，监听topic的应用\n4. producer，生产指定消息的应用\n5. consumer group，一组监听同一个topic的consumer的集合\n\n#### 组件\n1. nameserver，存储broker（主从），broker与topic信息（包含queue），topic与queue\n2. broker，用于转发消息，一般每台broker上会有多个\n\n#### 存储\n1. consumeQueue，用于存储queue已经消费到那个message了，里面有针对commitLog的文件偏移量\n2. commitLog，具体存储消息的地方，顺序存储，一次落盘，充分利用磁盘顺序读写（块设备）的特性\n\n#### 消息可靠性\n1. broker，主从同写，异步复制\n2. 消费失败，会进入重试队列，重试16次，每次10秒\n\n#### 怎么保证消息消费的顺序性\n1. 自定义queue策略，将相同订单id的消息扔到相同队列中去\n\n#### 接口幂等性\n1. 使用消息队列需要保证接口的幂等性，如果消息已经被处理过，那就不应该再次被处理。\n2. 如果消息重发，需要先查找上次处理的进度，然后继续业务逻辑","source":"_posts/RocketMQ笔记.md","raw":"---\ntitle: RocketMQ笔记\ndate: 2018-06-24 16:14:37\ntags: \n- 中间件\n- rocketmq\ncategories:\n- 中间件\n---\n#### 介绍\n1. rocket来源于阿里中间件团队，前身是kafaka，改进了kafka在消息可靠性\n2. kafka是linkedin公司为了收集日志开发的消息中间件，scala语言编写，吞吐量单机在100万左右\n3. kafka吞吐量高的一个原因是是，客户端发送消息是会进行合并，将多个消息一起发送给服务端，服务端同时处理\n4. 两个消息的写入都会同时使用页写入的策略，一次写入一页的消息，效率更高\n<!-- more -->\n\n#### 模式\n1. 点对点，p2p\n2. 发布/订阅，topic\nons上为集群模式，或者是广播模式，配置中心在广播模式之下\n\n#### 概念\n1. topic，用于区分消息的业务类型\n2. queue，最大数量为4（可调整），从属于topic，消息是按照queue的维度来进行存储和发送的，每个消息都会归属于一个指定的queue（默认三种路由策略，随机，一致性hash，和机器随机\n3. consumer，监听topic的应用\n4. producer，生产指定消息的应用\n5. consumer group，一组监听同一个topic的consumer的集合\n\n#### 组件\n1. nameserver，存储broker（主从），broker与topic信息（包含queue），topic与queue\n2. broker，用于转发消息，一般每台broker上会有多个\n\n#### 存储\n1. consumeQueue，用于存储queue已经消费到那个message了，里面有针对commitLog的文件偏移量\n2. commitLog，具体存储消息的地方，顺序存储，一次落盘，充分利用磁盘顺序读写（块设备）的特性\n\n#### 消息可靠性\n1. broker，主从同写，异步复制\n2. 消费失败，会进入重试队列，重试16次，每次10秒\n\n#### 怎么保证消息消费的顺序性\n1. 自定义queue策略，将相同订单id的消息扔到相同队列中去\n\n#### 接口幂等性\n1. 使用消息队列需要保证接口的幂等性，如果消息已经被处理过，那就不应该再次被处理。\n2. 如果消息重发，需要先查找上次处理的进度，然后继续业务逻辑","slug":"RocketMQ笔记","published":1,"updated":"2018-06-24T08:18:08.213Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5u1tv8000u1av8g1d75qm8","content":"<h4 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><ol>\n<li>rocket来源于阿里中间件团队，前身是kafaka，改进了kafka在消息可靠性</li>\n<li>kafka是linkedin公司为了收集日志开发的消息中间件，scala语言编写，吞吐量单机在100万左右</li>\n<li>kafka吞吐量高的一个原因是是，客户端发送消息是会进行合并，将多个消息一起发送给服务端，服务端同时处理</li>\n<li>两个消息的写入都会同时使用页写入的策略，一次写入一页的消息，效率更高<a id=\"more\"></a>\n</li>\n</ol>\n<h4 id=\"模式\"><a href=\"#模式\" class=\"headerlink\" title=\"模式\"></a>模式</h4><ol>\n<li>点对点，p2p</li>\n<li>发布/订阅，topic<br>ons上为集群模式，或者是广播模式，配置中心在广播模式之下</li>\n</ol>\n<h4 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h4><ol>\n<li>topic，用于区分消息的业务类型</li>\n<li>queue，最大数量为4（可调整），从属于topic，消息是按照queue的维度来进行存储和发送的，每个消息都会归属于一个指定的queue（默认三种路由策略，随机，一致性hash，和机器随机</li>\n<li>consumer，监听topic的应用</li>\n<li>producer，生产指定消息的应用</li>\n<li>consumer group，一组监听同一个topic的consumer的集合</li>\n</ol>\n<h4 id=\"组件\"><a href=\"#组件\" class=\"headerlink\" title=\"组件\"></a>组件</h4><ol>\n<li>nameserver，存储broker（主从），broker与topic信息（包含queue），topic与queue</li>\n<li>broker，用于转发消息，一般每台broker上会有多个</li>\n</ol>\n<h4 id=\"存储\"><a href=\"#存储\" class=\"headerlink\" title=\"存储\"></a>存储</h4><ol>\n<li>consumeQueue，用于存储queue已经消费到那个message了，里面有针对commitLog的文件偏移量</li>\n<li>commitLog，具体存储消息的地方，顺序存储，一次落盘，充分利用磁盘顺序读写（块设备）的特性</li>\n</ol>\n<h4 id=\"消息可靠性\"><a href=\"#消息可靠性\" class=\"headerlink\" title=\"消息可靠性\"></a>消息可靠性</h4><ol>\n<li>broker，主从同写，异步复制</li>\n<li>消费失败，会进入重试队列，重试16次，每次10秒</li>\n</ol>\n<h4 id=\"怎么保证消息消费的顺序性\"><a href=\"#怎么保证消息消费的顺序性\" class=\"headerlink\" title=\"怎么保证消息消费的顺序性\"></a>怎么保证消息消费的顺序性</h4><ol>\n<li>自定义queue策略，将相同订单id的消息扔到相同队列中去</li>\n</ol>\n<h4 id=\"接口幂等性\"><a href=\"#接口幂等性\" class=\"headerlink\" title=\"接口幂等性\"></a>接口幂等性</h4><ol>\n<li>使用消息队列需要保证接口的幂等性，如果消息已经被处理过，那就不应该再次被处理。</li>\n<li>如果消息重发，需要先查找上次处理的进度，然后继续业务逻辑</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h4 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><ol>\n<li>rocket来源于阿里中间件团队，前身是kafaka，改进了kafka在消息可靠性</li>\n<li>kafka是linkedin公司为了收集日志开发的消息中间件，scala语言编写，吞吐量单机在100万左右</li>\n<li>kafka吞吐量高的一个原因是是，客户端发送消息是会进行合并，将多个消息一起发送给服务端，服务端同时处理</li>\n<li>两个消息的写入都会同时使用页写入的策略，一次写入一页的消息，效率更高","more":"</li>\n</ol>\n<h4 id=\"模式\"><a href=\"#模式\" class=\"headerlink\" title=\"模式\"></a>模式</h4><ol>\n<li>点对点，p2p</li>\n<li>发布/订阅，topic<br>ons上为集群模式，或者是广播模式，配置中心在广播模式之下</li>\n</ol>\n<h4 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h4><ol>\n<li>topic，用于区分消息的业务类型</li>\n<li>queue，最大数量为4（可调整），从属于topic，消息是按照queue的维度来进行存储和发送的，每个消息都会归属于一个指定的queue（默认三种路由策略，随机，一致性hash，和机器随机</li>\n<li>consumer，监听topic的应用</li>\n<li>producer，生产指定消息的应用</li>\n<li>consumer group，一组监听同一个topic的consumer的集合</li>\n</ol>\n<h4 id=\"组件\"><a href=\"#组件\" class=\"headerlink\" title=\"组件\"></a>组件</h4><ol>\n<li>nameserver，存储broker（主从），broker与topic信息（包含queue），topic与queue</li>\n<li>broker，用于转发消息，一般每台broker上会有多个</li>\n</ol>\n<h4 id=\"存储\"><a href=\"#存储\" class=\"headerlink\" title=\"存储\"></a>存储</h4><ol>\n<li>consumeQueue，用于存储queue已经消费到那个message了，里面有针对commitLog的文件偏移量</li>\n<li>commitLog，具体存储消息的地方，顺序存储，一次落盘，充分利用磁盘顺序读写（块设备）的特性</li>\n</ol>\n<h4 id=\"消息可靠性\"><a href=\"#消息可靠性\" class=\"headerlink\" title=\"消息可靠性\"></a>消息可靠性</h4><ol>\n<li>broker，主从同写，异步复制</li>\n<li>消费失败，会进入重试队列，重试16次，每次10秒</li>\n</ol>\n<h4 id=\"怎么保证消息消费的顺序性\"><a href=\"#怎么保证消息消费的顺序性\" class=\"headerlink\" title=\"怎么保证消息消费的顺序性\"></a>怎么保证消息消费的顺序性</h4><ol>\n<li>自定义queue策略，将相同订单id的消息扔到相同队列中去</li>\n</ol>\n<h4 id=\"接口幂等性\"><a href=\"#接口幂等性\" class=\"headerlink\" title=\"接口幂等性\"></a>接口幂等性</h4><ol>\n<li>使用消息队列需要保证接口的幂等性，如果消息已经被处理过，那就不应该再次被处理。</li>\n<li>如果消息重发，需要先查找上次处理的进度，然后继续业务逻辑</li>\n</ol>"},{"title":"Redis笔记","date":"2018-06-24T07:53:41.000Z","toc":true,"_content":"### 数据类型\n字符串，hash，list，set，sort set\n\n#### 跳表\n优点：\n1. 实现更加简单，查找复杂度类似\n2. 插入性能更高\n<!-- more -->\n当然也会坏处，占用内存更多，多了更多无用的节点\n![跳跃表](/images/skip-list.jpg)\n\n#### 字符串存储结构\nSDS，simple dynamic string，简单动态字符串\n\n#### 过期策略\n1. 定时器删除\n2. 惰性删除\n3. 定期扫描删除\n对key设置过期的时候，是将key加入到了过期字典当中。\nredis采取了定期扫描删除和惰性删除结合的策略。","source":"_posts/Redis笔记.md","raw":"---\ntitle: Redis笔记\ndate: 2018-06-24 15:53:41\ntags:\n- 中间件\n- redis\ncategories:\n- 中间件\ntoc: true\n---\n### 数据类型\n字符串，hash，list，set，sort set\n\n#### 跳表\n优点：\n1. 实现更加简单，查找复杂度类似\n2. 插入性能更高\n<!-- more -->\n当然也会坏处，占用内存更多，多了更多无用的节点\n![跳跃表](/images/skip-list.jpg)\n\n#### 字符串存储结构\nSDS，simple dynamic string，简单动态字符串\n\n#### 过期策略\n1. 定时器删除\n2. 惰性删除\n3. 定期扫描删除\n对key设置过期的时候，是将key加入到了过期字典当中。\nredis采取了定期扫描删除和惰性删除结合的策略。","slug":"Redis笔记","published":1,"updated":"2018-06-24T08:14:17.013Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5u1tv9000w1av89r2c4y3w","content":"<h3 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h3><p>字符串，hash，list，set，sort set</p>\n<h4 id=\"跳表\"><a href=\"#跳表\" class=\"headerlink\" title=\"跳表\"></a>跳表</h4><p>优点：</p>\n<ol>\n<li>实现更加简单，查找复杂度类似</li>\n<li>插入性能更高<a id=\"more\"></a>\n当然也会坏处，占用内存更多，多了更多无用的节点<br><img src=\"/images/skip-list.jpg\" alt=\"跳跃表\"></li>\n</ol>\n<h4 id=\"字符串存储结构\"><a href=\"#字符串存储结构\" class=\"headerlink\" title=\"字符串存储结构\"></a>字符串存储结构</h4><p>SDS，simple dynamic string，简单动态字符串</p>\n<h4 id=\"过期策略\"><a href=\"#过期策略\" class=\"headerlink\" title=\"过期策略\"></a>过期策略</h4><ol>\n<li>定时器删除</li>\n<li>惰性删除</li>\n<li>定期扫描删除<br>对key设置过期的时候，是将key加入到了过期字典当中。<br>redis采取了定期扫描删除和惰性删除结合的策略。</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h3 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h3><p>字符串，hash，list，set，sort set</p>\n<h4 id=\"跳表\"><a href=\"#跳表\" class=\"headerlink\" title=\"跳表\"></a>跳表</h4><p>优点：</p>\n<ol>\n<li>实现更加简单，查找复杂度类似</li>\n<li>插入性能更高","more":"当然也会坏处，占用内存更多，多了更多无用的节点<br><img src=\"/images/skip-list.jpg\" alt=\"跳跃表\"></li>\n</ol>\n<h4 id=\"字符串存储结构\"><a href=\"#字符串存储结构\" class=\"headerlink\" title=\"字符串存储结构\"></a>字符串存储结构</h4><p>SDS，simple dynamic string，简单动态字符串</p>\n<h4 id=\"过期策略\"><a href=\"#过期策略\" class=\"headerlink\" title=\"过期策略\"></a>过期策略</h4><ol>\n<li>定时器删除</li>\n<li>惰性删除</li>\n<li>定期扫描删除<br>对key设置过期的时候，是将key加入到了过期字典当中。<br>redis采取了定期扫描删除和惰性删除结合的策略。</li>\n</ol>"},{"title":"Thread分析","date":"2018-06-23T10:08:21.000Z","toc":true,"_content":"# 成员属性\n1. `String name`, 线程名称\n2. `int priority`, 优先级\n3. `Thread threadQ`, 不知道\n4. `long eetop`, 不知道\n5. `boolean single_step`, 不知道 \n6. `boolean daemon = false`, 是否是后台线程\n7. `boolean stillborn = false`, 表示中间状态\n8. `Runnable target`, 表示当前正在执行的指令\n<!-- more -->\n9. `ThreadGroup group`, 线程组\n10. `ClassLoader contextClassLoader`, 用于加载类的\n11. `AccessControlContext inheritedAccessControlContext`, 不知道\n12. `ThreadLocal.ThreadLocalMap threadLocals`, 线程本地存储\n13. `ThreadLocal.ThreadLocalMap inheritableThreadLocals`, 继承的线程本地存储\n14. `long stackSize`, 栈的大小\n15. `long nativeParkEventPointer`, 不知道\n16. `long tid`, 线程的id\n17. `int threadStatus`, 线程状态\n18. `Object parkBlocker`, 表示当前线程正在等待的对象\n19. `Interruptible blocker`, 不知道\n20. `Object blockerLock`, 不知道\n\n# 静态属性\n1. `long threadSeqNumber`, 线程id的生成器\n\n# 主要方法\n## start\n不能start两次，否则抛出IllegalThreadStateException\n\n## interrupt, isInterrupted, interrupted\n1. interrupt中断线程的阻塞，（其实是释放了linux信号量，并且设置了是否被中断标记位）\n2. isInterrupted则是检测当前线程的中断标记位是否被设置，但是不清除标记位的设置\n3. interrupted检测线程是否被中断，并且清除标记位的设置\n\n## tip\n1. `Thread.interrupt`只在Object.wait() .Thread.join(), Thread.sleep()等几个native方法上面抛出异常\n2. `LockSupport.parkNanos`，只是会让它立即返回\n3. 在AQS上面是主动监测了标记位，然后跑出了异常\n4. java的Thread对象会对应一个系统级别的线程。","source":"_posts/Thread分析.md","raw":"---\ntitle: Thread分析\ndate: 2018-06-23 18:08:21\ntags:\n- java\n- 多线程\n- 源码\ncategories: \n- java\n- 多线程\ntoc: true\n---\n# 成员属性\n1. `String name`, 线程名称\n2. `int priority`, 优先级\n3. `Thread threadQ`, 不知道\n4. `long eetop`, 不知道\n5. `boolean single_step`, 不知道 \n6. `boolean daemon = false`, 是否是后台线程\n7. `boolean stillborn = false`, 表示中间状态\n8. `Runnable target`, 表示当前正在执行的指令\n<!-- more -->\n9. `ThreadGroup group`, 线程组\n10. `ClassLoader contextClassLoader`, 用于加载类的\n11. `AccessControlContext inheritedAccessControlContext`, 不知道\n12. `ThreadLocal.ThreadLocalMap threadLocals`, 线程本地存储\n13. `ThreadLocal.ThreadLocalMap inheritableThreadLocals`, 继承的线程本地存储\n14. `long stackSize`, 栈的大小\n15. `long nativeParkEventPointer`, 不知道\n16. `long tid`, 线程的id\n17. `int threadStatus`, 线程状态\n18. `Object parkBlocker`, 表示当前线程正在等待的对象\n19. `Interruptible blocker`, 不知道\n20. `Object blockerLock`, 不知道\n\n# 静态属性\n1. `long threadSeqNumber`, 线程id的生成器\n\n# 主要方法\n## start\n不能start两次，否则抛出IllegalThreadStateException\n\n## interrupt, isInterrupted, interrupted\n1. interrupt中断线程的阻塞，（其实是释放了linux信号量，并且设置了是否被中断标记位）\n2. isInterrupted则是检测当前线程的中断标记位是否被设置，但是不清除标记位的设置\n3. interrupted检测线程是否被中断，并且清除标记位的设置\n\n## tip\n1. `Thread.interrupt`只在Object.wait() .Thread.join(), Thread.sleep()等几个native方法上面抛出异常\n2. `LockSupport.parkNanos`，只是会让它立即返回\n3. 在AQS上面是主动监测了标记位，然后跑出了异常\n4. java的Thread对象会对应一个系统级别的线程。","slug":"Thread分析","published":1,"updated":"2018-06-23T10:14:05.674Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5u1tvb000z1av82xzgf7qp","content":"<h1 id=\"成员属性\"><a href=\"#成员属性\" class=\"headerlink\" title=\"成员属性\"></a>成员属性</h1><ol>\n<li><code>String name</code>, 线程名称</li>\n<li><code>int priority</code>, 优先级</li>\n<li><code>Thread threadQ</code>, 不知道</li>\n<li><code>long eetop</code>, 不知道</li>\n<li><code>boolean single_step</code>, 不知道 </li>\n<li><code>boolean daemon = false</code>, 是否是后台线程</li>\n<li><code>boolean stillborn = false</code>, 表示中间状态</li>\n<li><code>Runnable target</code>, 表示当前正在执行的指令<a id=\"more\"></a></li>\n<li><code>ThreadGroup group</code>, 线程组</li>\n<li><code>ClassLoader contextClassLoader</code>, 用于加载类的</li>\n<li><code>AccessControlContext inheritedAccessControlContext</code>, 不知道</li>\n<li><code>ThreadLocal.ThreadLocalMap threadLocals</code>, 线程本地存储</li>\n<li><code>ThreadLocal.ThreadLocalMap inheritableThreadLocals</code>, 继承的线程本地存储</li>\n<li><code>long stackSize</code>, 栈的大小</li>\n<li><code>long nativeParkEventPointer</code>, 不知道</li>\n<li><code>long tid</code>, 线程的id</li>\n<li><code>int threadStatus</code>, 线程状态</li>\n<li><code>Object parkBlocker</code>, 表示当前线程正在等待的对象</li>\n<li><code>Interruptible blocker</code>, 不知道</li>\n<li><code>Object blockerLock</code>, 不知道</li>\n</ol>\n<h1 id=\"静态属性\"><a href=\"#静态属性\" class=\"headerlink\" title=\"静态属性\"></a>静态属性</h1><ol>\n<li><code>long threadSeqNumber</code>, 线程id的生成器</li>\n</ol>\n<h1 id=\"主要方法\"><a href=\"#主要方法\" class=\"headerlink\" title=\"主要方法\"></a>主要方法</h1><h2 id=\"start\"><a href=\"#start\" class=\"headerlink\" title=\"start\"></a>start</h2><p>不能start两次，否则抛出IllegalThreadStateException</p>\n<h2 id=\"interrupt-isInterrupted-interrupted\"><a href=\"#interrupt-isInterrupted-interrupted\" class=\"headerlink\" title=\"interrupt, isInterrupted, interrupted\"></a>interrupt, isInterrupted, interrupted</h2><ol>\n<li>interrupt中断线程的阻塞，（其实是释放了linux信号量，并且设置了是否被中断标记位）</li>\n<li>isInterrupted则是检测当前线程的中断标记位是否被设置，但是不清除标记位的设置</li>\n<li>interrupted检测线程是否被中断，并且清除标记位的设置</li>\n</ol>\n<h2 id=\"tip\"><a href=\"#tip\" class=\"headerlink\" title=\"tip\"></a>tip</h2><ol>\n<li><code>Thread.interrupt</code>只在Object.wait() .Thread.join(), Thread.sleep()等几个native方法上面抛出异常</li>\n<li><code>LockSupport.parkNanos</code>，只是会让它立即返回</li>\n<li>在AQS上面是主动监测了标记位，然后跑出了异常</li>\n<li>java的Thread对象会对应一个系统级别的线程。</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h1 id=\"成员属性\"><a href=\"#成员属性\" class=\"headerlink\" title=\"成员属性\"></a>成员属性</h1><ol>\n<li><code>String name</code>, 线程名称</li>\n<li><code>int priority</code>, 优先级</li>\n<li><code>Thread threadQ</code>, 不知道</li>\n<li><code>long eetop</code>, 不知道</li>\n<li><code>boolean single_step</code>, 不知道 </li>\n<li><code>boolean daemon = false</code>, 是否是后台线程</li>\n<li><code>boolean stillborn = false</code>, 表示中间状态</li>\n<li><code>Runnable target</code>, 表示当前正在执行的指令","more":"</li>\n<li><code>ThreadGroup group</code>, 线程组</li>\n<li><code>ClassLoader contextClassLoader</code>, 用于加载类的</li>\n<li><code>AccessControlContext inheritedAccessControlContext</code>, 不知道</li>\n<li><code>ThreadLocal.ThreadLocalMap threadLocals</code>, 线程本地存储</li>\n<li><code>ThreadLocal.ThreadLocalMap inheritableThreadLocals</code>, 继承的线程本地存储</li>\n<li><code>long stackSize</code>, 栈的大小</li>\n<li><code>long nativeParkEventPointer</code>, 不知道</li>\n<li><code>long tid</code>, 线程的id</li>\n<li><code>int threadStatus</code>, 线程状态</li>\n<li><code>Object parkBlocker</code>, 表示当前线程正在等待的对象</li>\n<li><code>Interruptible blocker</code>, 不知道</li>\n<li><code>Object blockerLock</code>, 不知道</li>\n</ol>\n<h1 id=\"静态属性\"><a href=\"#静态属性\" class=\"headerlink\" title=\"静态属性\"></a>静态属性</h1><ol>\n<li><code>long threadSeqNumber</code>, 线程id的生成器</li>\n</ol>\n<h1 id=\"主要方法\"><a href=\"#主要方法\" class=\"headerlink\" title=\"主要方法\"></a>主要方法</h1><h2 id=\"start\"><a href=\"#start\" class=\"headerlink\" title=\"start\"></a>start</h2><p>不能start两次，否则抛出IllegalThreadStateException</p>\n<h2 id=\"interrupt-isInterrupted-interrupted\"><a href=\"#interrupt-isInterrupted-interrupted\" class=\"headerlink\" title=\"interrupt, isInterrupted, interrupted\"></a>interrupt, isInterrupted, interrupted</h2><ol>\n<li>interrupt中断线程的阻塞，（其实是释放了linux信号量，并且设置了是否被中断标记位）</li>\n<li>isInterrupted则是检测当前线程的中断标记位是否被设置，但是不清除标记位的设置</li>\n<li>interrupted检测线程是否被中断，并且清除标记位的设置</li>\n</ol>\n<h2 id=\"tip\"><a href=\"#tip\" class=\"headerlink\" title=\"tip\"></a>tip</h2><ol>\n<li><code>Thread.interrupt</code>只在Object.wait() .Thread.join(), Thread.sleep()等几个native方法上面抛出异常</li>\n<li><code>LockSupport.parkNanos</code>，只是会让它立即返回</li>\n<li>在AQS上面是主动监测了标记位，然后跑出了异常</li>\n<li>java的Thread对象会对应一个系统级别的线程。</li>\n</ol>"},{"title":"ThreadLocal分析","date":"2018-06-23T10:10:59.000Z","toc":true,"_content":"# 原理\nThread对象中有一个[ThreadLocalMap](/2018/06/23/Thread%E5%88%86%E6%9E%90/)对象，ThreadLocal对象被存储在线程的ThreadLocalMap中，叫做threadLocals。\n<!-- more -->\n# 主要方法\n## get\n```java\nThreadLocalMap getMap(Thread t) {\n    return t.threadLocals;\n}\n\n// 设置初始的Map\nvoid createMap(Thread t, T firstValue) {\n    t.threadLocals = new ThreadLocalMap(this, firstValue);\n}\n\n// 初始化Map，或者设置当前的初始值\nprivate T setInitialValue() {\n    T value = initialValue();\n    Thread t = Thread.currentThread();\n    ThreadLocalMap map = getMap(t);\n\n    if (map != null)\n        map.set(this, value);\n    else\n        createMap(t, value);\n    \n    return value;\n}\n\npublic T get() {\n    // 获取当前线程\n    Thread t = Thread.currentThread();\n    // 获取当前线程的threadLocals\n    ThreadLocalMap map = getMap(t);\n\n    // 如果当前map不为空\n    if (map != null) {\n        ThreadLocalMap.Entry e = map.getEntry(this);\n        if (e != null) {\n            @SuppressWarnings(\"unchecked\")\n            T result = (T)e.value;\n            return result;\n        }\n    }\n    // 设置初始值\n    return setInitialValue();\n}\n```\n## set\n```java\npublic void set(T value) {\n    Thread t = Thread.currentThread();\n    ThreadLocalMap map = getMap(t);\n\n    if (map != null)\n        // 直接设置map的初始值\n        map.set(this, value);\n    else\n        createMap(t, value);\n}\n```\n## ThreadLocalMap\n```java\nstatic class ThreadLocalMap {\n    // 特别重要的一点，防止内存泄漏\n    // WeakReference\n    static class Entry extends WeakReference<ThreadLocal<?>> {\n        Object value;\n\n        Entry(ThreadLocal<?> k, Object v) {\n            super(k);\n            value = v;\n        }\n    }\n    private static final int INITIAL_CAPACITY = 16;\n    private Entry[] table;\n    private int size = 0;\n    private int threshold;\n\n    private void setThreshold(int len) {\n        threshold = len * 2 / 3;\n    }\n\n    private static int nextIndex(int i, int len) {\n        return ((i + 1 < len) ? i + 1 : 0);\n    }\n\n    private static int prevIndex(int i, int len) {\n        return ((i - 1 >= 0) ? i - 1 : len - 1);\n    }\n\n    private Entry getEntry(ThreadLocal<?> key) {\n        // 获取当前的key的存储地方\n        int i = key.threadLocalHashCode & (table.length - 1);\n        Entry e = table[i];\n\n        // 当前Entry的key存在，并且等于想要查找的值\n        if (e != null && e.get() == key)\n            return e;\n        else\n            return getEntryAfterMiss(key, i, e);\n    }\n\n    // 在指定位置没有查找到，使用线性探查法\n    private Entry getEntryAfterMiss(ThreadLocal<?> key, int i, Entry e) {\n        Entry[] tab = table;\n        int len = tab.length;\n\n        while (e != null) {\n            ThreadLocal<?> k = e.get();\n            if (k == key)\n                return e;\n            if (k == null)\n                // 清空无效Entry\n                expungeStaleEntry(i);\n            else\n                i = nextIndex(i, len);\n            e = tab[i];\n        }\n        return null;\n    }\n\n    // 将当前ThreadLocal对象放入到当前map中\n    private void set(ThreadLocal<?> key, Object value) {\n        Entry[] tab = table;\n        int len = tab.length;\n        int i = key.threadLocalHashCode & (len-1);\n\n        // 遍历当前不为空的entry，查找key是否存在\n        for (Entry e = tab[i];\n                e != null;\n                e = tab[i = nextIndex(i, len)]) {\n            ThreadLocal<?> k = e.get();\n\n            if (k == key) {\n                e.value = value;\n                return;\n            }\n\n            if (k == null) {\n                // 直接使用当前Entry\n                replaceStaleEntry(key, value, i);\n                return;\n            }\n        }\n\n        tab[i] = new Entry(key, value);\n        int sz = ++size;\n        if (!cleanSomeSlots(i, sz) && sz >= threshold)\n            rehash();\n    }\n\n    // 删除当前key\n    private void remove(ThreadLocal<?> key) {\n        Entry[] tab = table;\n        int len = tab.length;\n        int i = key.threadLocalHashCode & (len-1);\n\n        // 遍历当前Entry[]数组\n        for (Entry e = tab[i];\n                e != null;\n                e = tab[i = nextIndex(i, len)]) {\n            if (e.get() == key) {\n                e.clear();\n                expungeStaleEntry(i);\n                return;\n            }\n        }\n    }\n\n    // 这段代码的主要意思我可以猜一下\n    // 主要了为了保证在发生冲突的时候，Entry可以尽量离index近一些\n    // 里面如果查找到的第一个需要回收的Entry不是当前Entry\n    // 则会将两个交换值\n    private void replaceStaleEntry(ThreadLocal<?> key, Object value,\n                                    int staleSlot) {\n        Entry[] tab = table;\n        int len = tab.length;\n        Entry e;\n\n        // 从当前Slot开始查找最早的可删除Entry\n        int slotToExpunge = staleSlot;\n        for (int i = prevIndex(staleSlot, len);\n                (e = tab[i]) != null;\n                i = prevIndex(i, len))\n            if (e.get() == null)\n                slotToExpunge = i;\n\n        for (int i = nextIndex(staleSlot, len);\n                (e = tab[i]) != null;\n                i = nextIndex(i, len)) {\n            ThreadLocal<?> k = e.get();\n\n            if (k == key) {\n                e.value = value;\n\n                // 交换了位置\n                tab[i] = tab[staleSlot];\n                tab[staleSlot] = e;\n\n                if (slotToExpunge == staleSlot)\n                    slotToExpunge = i;\n                // 有一个清理操作\n                cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);\n                return;\n            }\n            // 如果\n            if (k == null && slotToExpunge == staleSlot)\n                slotToExpunge = i;\n        }\n\n        // for gc\n        tab[staleSlot].value = null;\n        tab[staleSlot] = new Entry(key, value);\n\n        // 继续回收内存\n        if (slotToExpunge != staleSlot)\n            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);\n    }\n\n    // 删除当前staleSlot的无效Entry，其中还涉及到一个交换过程\n    // 如果当前Entry是占用了其他Entry的位置的话，会将其他Entry交换回来\n    private int expungeStaleEntry(int staleSlot) {\n        Entry[] tab = table;\n        int len = tab.length;\n\n        // expunge entry at staleSlot\n        tab[staleSlot].value = null;\n        tab[staleSlot] = null;\n        size--;\n\n        Entry e;\n        int i;\n        for (i = nextIndex(staleSlot, len);\n                (e = tab[i]) != null;\n                i = nextIndex(i, len)) {\n            ThreadLocal<?> k = e.get();\n            if (k == null) {\n                e.value = null;\n                tab[i] = null;\n                size--;\n            } else {\n                int h = k.threadLocalHashCode & (len - 1);\n                if (h != i) {\n                    tab[i] = null;\n                    while (tab[h] != null)\n                        h = nextIndex(h, len);\n                    tab[h] = e;\n                }\n            }\n        }\n        return i;\n    }\n\n    // 清除一些无效的Entry\n    private boolean cleanSomeSlots(int i, int n) {\n        boolean removed = false;\n        Entry[] tab = table;\n        int len = tab.length;\n        do {\n            i = nextIndex(i, len);\n            Entry e = tab[i];\n            if (e != null && e.get() == null) {\n                n = len;\n                removed = true;\n                i = expungeStaleEntry(i);\n            }\n        } while ( (n >>>= 1) != 0);\n        return removed;\n    }\n    \n    // 执行整理Entry数组，以及扩容操作\n    private void rehash() {\n        expungeStaleEntries();\n\n        // Use lower threshold for doubling to avoid hysteresis\n        if (size >= threshold - threshold / 4)\n            resize();\n    }\n\n    // 扩容\n    private void resize() {\n        Entry[] oldTab = table;\n        int oldLen = oldTab.length;\n        int newLen = oldLen * 2;\n        Entry[] newTab = new Entry[newLen];\n        int count = 0;\n\n        for (int j = 0; j < oldLen; ++j) {\n            Entry e = oldTab[j];\n            if (e != null) {\n                ThreadLocal<?> k = e.get();\n                if (k == null) {\n                    e.value = null; // Help the GC\n                } else {\n                    int h = k.threadLocalHashCode & (newLen - 1);\n                    while (newTab[h] != null)\n                        h = nextIndex(h, newLen);\n                    newTab[h] = e;\n                    count++;\n                }\n            }\n        }\n\n        setThreshold(newLen);\n        size = count;\n        table = newTab;\n    }\n\n    private void expungeStaleEntries() {\n        Entry[] tab = table;\n        int len = tab.length;\n        for (int j = 0; j < len; j++) {\n            Entry e = tab[j];\n            if (e != null && e.get() == null)\n                expungeStaleEntry(j);\n        }\n    }\n}\n```\n# 内存泄漏\n大概率发生在一个情况下：   \n线程长时间存活，并且在使用过ThreadLocal之后，没有后续任何使用，并且也没有调用ThreadLocal.remove()方法，\n导致value对象内存泄漏。","source":"_posts/ThreadLocal分析.md","raw":"---\ntitle: ThreadLocal分析\ndate: 2018-06-23 18:10:59\ntags:\n- java\n- 多线程\n- 源码\ncategories: \n- java\n- 多线程\ntoc: true\n---\n# 原理\nThread对象中有一个[ThreadLocalMap](/2018/06/23/Thread%E5%88%86%E6%9E%90/)对象，ThreadLocal对象被存储在线程的ThreadLocalMap中，叫做threadLocals。\n<!-- more -->\n# 主要方法\n## get\n```java\nThreadLocalMap getMap(Thread t) {\n    return t.threadLocals;\n}\n\n// 设置初始的Map\nvoid createMap(Thread t, T firstValue) {\n    t.threadLocals = new ThreadLocalMap(this, firstValue);\n}\n\n// 初始化Map，或者设置当前的初始值\nprivate T setInitialValue() {\n    T value = initialValue();\n    Thread t = Thread.currentThread();\n    ThreadLocalMap map = getMap(t);\n\n    if (map != null)\n        map.set(this, value);\n    else\n        createMap(t, value);\n    \n    return value;\n}\n\npublic T get() {\n    // 获取当前线程\n    Thread t = Thread.currentThread();\n    // 获取当前线程的threadLocals\n    ThreadLocalMap map = getMap(t);\n\n    // 如果当前map不为空\n    if (map != null) {\n        ThreadLocalMap.Entry e = map.getEntry(this);\n        if (e != null) {\n            @SuppressWarnings(\"unchecked\")\n            T result = (T)e.value;\n            return result;\n        }\n    }\n    // 设置初始值\n    return setInitialValue();\n}\n```\n## set\n```java\npublic void set(T value) {\n    Thread t = Thread.currentThread();\n    ThreadLocalMap map = getMap(t);\n\n    if (map != null)\n        // 直接设置map的初始值\n        map.set(this, value);\n    else\n        createMap(t, value);\n}\n```\n## ThreadLocalMap\n```java\nstatic class ThreadLocalMap {\n    // 特别重要的一点，防止内存泄漏\n    // WeakReference\n    static class Entry extends WeakReference<ThreadLocal<?>> {\n        Object value;\n\n        Entry(ThreadLocal<?> k, Object v) {\n            super(k);\n            value = v;\n        }\n    }\n    private static final int INITIAL_CAPACITY = 16;\n    private Entry[] table;\n    private int size = 0;\n    private int threshold;\n\n    private void setThreshold(int len) {\n        threshold = len * 2 / 3;\n    }\n\n    private static int nextIndex(int i, int len) {\n        return ((i + 1 < len) ? i + 1 : 0);\n    }\n\n    private static int prevIndex(int i, int len) {\n        return ((i - 1 >= 0) ? i - 1 : len - 1);\n    }\n\n    private Entry getEntry(ThreadLocal<?> key) {\n        // 获取当前的key的存储地方\n        int i = key.threadLocalHashCode & (table.length - 1);\n        Entry e = table[i];\n\n        // 当前Entry的key存在，并且等于想要查找的值\n        if (e != null && e.get() == key)\n            return e;\n        else\n            return getEntryAfterMiss(key, i, e);\n    }\n\n    // 在指定位置没有查找到，使用线性探查法\n    private Entry getEntryAfterMiss(ThreadLocal<?> key, int i, Entry e) {\n        Entry[] tab = table;\n        int len = tab.length;\n\n        while (e != null) {\n            ThreadLocal<?> k = e.get();\n            if (k == key)\n                return e;\n            if (k == null)\n                // 清空无效Entry\n                expungeStaleEntry(i);\n            else\n                i = nextIndex(i, len);\n            e = tab[i];\n        }\n        return null;\n    }\n\n    // 将当前ThreadLocal对象放入到当前map中\n    private void set(ThreadLocal<?> key, Object value) {\n        Entry[] tab = table;\n        int len = tab.length;\n        int i = key.threadLocalHashCode & (len-1);\n\n        // 遍历当前不为空的entry，查找key是否存在\n        for (Entry e = tab[i];\n                e != null;\n                e = tab[i = nextIndex(i, len)]) {\n            ThreadLocal<?> k = e.get();\n\n            if (k == key) {\n                e.value = value;\n                return;\n            }\n\n            if (k == null) {\n                // 直接使用当前Entry\n                replaceStaleEntry(key, value, i);\n                return;\n            }\n        }\n\n        tab[i] = new Entry(key, value);\n        int sz = ++size;\n        if (!cleanSomeSlots(i, sz) && sz >= threshold)\n            rehash();\n    }\n\n    // 删除当前key\n    private void remove(ThreadLocal<?> key) {\n        Entry[] tab = table;\n        int len = tab.length;\n        int i = key.threadLocalHashCode & (len-1);\n\n        // 遍历当前Entry[]数组\n        for (Entry e = tab[i];\n                e != null;\n                e = tab[i = nextIndex(i, len)]) {\n            if (e.get() == key) {\n                e.clear();\n                expungeStaleEntry(i);\n                return;\n            }\n        }\n    }\n\n    // 这段代码的主要意思我可以猜一下\n    // 主要了为了保证在发生冲突的时候，Entry可以尽量离index近一些\n    // 里面如果查找到的第一个需要回收的Entry不是当前Entry\n    // 则会将两个交换值\n    private void replaceStaleEntry(ThreadLocal<?> key, Object value,\n                                    int staleSlot) {\n        Entry[] tab = table;\n        int len = tab.length;\n        Entry e;\n\n        // 从当前Slot开始查找最早的可删除Entry\n        int slotToExpunge = staleSlot;\n        for (int i = prevIndex(staleSlot, len);\n                (e = tab[i]) != null;\n                i = prevIndex(i, len))\n            if (e.get() == null)\n                slotToExpunge = i;\n\n        for (int i = nextIndex(staleSlot, len);\n                (e = tab[i]) != null;\n                i = nextIndex(i, len)) {\n            ThreadLocal<?> k = e.get();\n\n            if (k == key) {\n                e.value = value;\n\n                // 交换了位置\n                tab[i] = tab[staleSlot];\n                tab[staleSlot] = e;\n\n                if (slotToExpunge == staleSlot)\n                    slotToExpunge = i;\n                // 有一个清理操作\n                cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);\n                return;\n            }\n            // 如果\n            if (k == null && slotToExpunge == staleSlot)\n                slotToExpunge = i;\n        }\n\n        // for gc\n        tab[staleSlot].value = null;\n        tab[staleSlot] = new Entry(key, value);\n\n        // 继续回收内存\n        if (slotToExpunge != staleSlot)\n            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);\n    }\n\n    // 删除当前staleSlot的无效Entry，其中还涉及到一个交换过程\n    // 如果当前Entry是占用了其他Entry的位置的话，会将其他Entry交换回来\n    private int expungeStaleEntry(int staleSlot) {\n        Entry[] tab = table;\n        int len = tab.length;\n\n        // expunge entry at staleSlot\n        tab[staleSlot].value = null;\n        tab[staleSlot] = null;\n        size--;\n\n        Entry e;\n        int i;\n        for (i = nextIndex(staleSlot, len);\n                (e = tab[i]) != null;\n                i = nextIndex(i, len)) {\n            ThreadLocal<?> k = e.get();\n            if (k == null) {\n                e.value = null;\n                tab[i] = null;\n                size--;\n            } else {\n                int h = k.threadLocalHashCode & (len - 1);\n                if (h != i) {\n                    tab[i] = null;\n                    while (tab[h] != null)\n                        h = nextIndex(h, len);\n                    tab[h] = e;\n                }\n            }\n        }\n        return i;\n    }\n\n    // 清除一些无效的Entry\n    private boolean cleanSomeSlots(int i, int n) {\n        boolean removed = false;\n        Entry[] tab = table;\n        int len = tab.length;\n        do {\n            i = nextIndex(i, len);\n            Entry e = tab[i];\n            if (e != null && e.get() == null) {\n                n = len;\n                removed = true;\n                i = expungeStaleEntry(i);\n            }\n        } while ( (n >>>= 1) != 0);\n        return removed;\n    }\n    \n    // 执行整理Entry数组，以及扩容操作\n    private void rehash() {\n        expungeStaleEntries();\n\n        // Use lower threshold for doubling to avoid hysteresis\n        if (size >= threshold - threshold / 4)\n            resize();\n    }\n\n    // 扩容\n    private void resize() {\n        Entry[] oldTab = table;\n        int oldLen = oldTab.length;\n        int newLen = oldLen * 2;\n        Entry[] newTab = new Entry[newLen];\n        int count = 0;\n\n        for (int j = 0; j < oldLen; ++j) {\n            Entry e = oldTab[j];\n            if (e != null) {\n                ThreadLocal<?> k = e.get();\n                if (k == null) {\n                    e.value = null; // Help the GC\n                } else {\n                    int h = k.threadLocalHashCode & (newLen - 1);\n                    while (newTab[h] != null)\n                        h = nextIndex(h, newLen);\n                    newTab[h] = e;\n                    count++;\n                }\n            }\n        }\n\n        setThreshold(newLen);\n        size = count;\n        table = newTab;\n    }\n\n    private void expungeStaleEntries() {\n        Entry[] tab = table;\n        int len = tab.length;\n        for (int j = 0; j < len; j++) {\n            Entry e = tab[j];\n            if (e != null && e.get() == null)\n                expungeStaleEntry(j);\n        }\n    }\n}\n```\n# 内存泄漏\n大概率发生在一个情况下：   \n线程长时间存活，并且在使用过ThreadLocal之后，没有后续任何使用，并且也没有调用ThreadLocal.remove()方法，\n导致value对象内存泄漏。","slug":"ThreadLocal分析","published":1,"updated":"2018-06-23T10:23:38.091Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5u1tvc00131av8ot72cpf4","content":"<h1 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h1><p>Thread对象中有一个<a href=\"/2018/06/23/Thread%E5%88%86%E6%9E%90/\">ThreadLocalMap</a>对象，ThreadLocal对象被存储在线程的ThreadLocalMap中，叫做threadLocals。<br><a id=\"more\"></a></p>\n<h1 id=\"主要方法\"><a href=\"#主要方法\" class=\"headerlink\" title=\"主要方法\"></a>主要方法</h1><h2 id=\"get\"><a href=\"#get\" class=\"headerlink\" title=\"get\"></a>get</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ThreadLocalMap <span class=\"title\">getMap</span><span class=\"params\">(Thread t)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> t.threadLocals;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置初始的Map</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">createMap</span><span class=\"params\">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class=\"line\">    t.threadLocals = <span class=\"keyword\">new</span> ThreadLocalMap(<span class=\"keyword\">this</span>, firstValue);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 初始化Map，或者设置当前的初始值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> T <span class=\"title\">setInitialValue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    T value = initialValue();</span><br><span class=\"line\">    Thread t = Thread.currentThread();</span><br><span class=\"line\">    ThreadLocalMap map = getMap(t);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        map.set(<span class=\"keyword\">this</span>, value);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        createMap(t, value);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取当前线程</span></span><br><span class=\"line\">    Thread t = Thread.currentThread();</span><br><span class=\"line\">    <span class=\"comment\">// 获取当前线程的threadLocals</span></span><br><span class=\"line\">    ThreadLocalMap map = getMap(t);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果当前map不为空</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        ThreadLocalMap.Entry e = map.getEntry(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">            T result = (T)e.value;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 设置初始值</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> setInitialValue();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set\"></a>set</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(T value)</span> </span>&#123;</span><br><span class=\"line\">    Thread t = Thread.currentThread();</span><br><span class=\"line\">    ThreadLocalMap map = getMap(t);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"comment\">// 直接设置map的初始值</span></span><br><span class=\"line\">        map.set(<span class=\"keyword\">this</span>, value);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        createMap(t, value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"ThreadLocalMap\"><a href=\"#ThreadLocalMap\" class=\"headerlink\" title=\"ThreadLocalMap\"></a>ThreadLocalMap</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadLocalMap</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 特别重要的一点，防止内存泄漏</span></span><br><span class=\"line\">    <span class=\"comment\">// WeakReference</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Entry</span> <span class=\"keyword\">extends</span> <span class=\"title\">WeakReference</span>&lt;<span class=\"title\">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class=\"line\">        Object value;</span><br><span class=\"line\"></span><br><span class=\"line\">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>(k);</span><br><span class=\"line\">            value = v;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> INITIAL_CAPACITY = <span class=\"number\">16</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Entry[] table;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> size = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> threshold;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">setThreshold</span><span class=\"params\">(<span class=\"keyword\">int</span> len)</span> </span>&#123;</span><br><span class=\"line\">        threshold = len * <span class=\"number\">2</span> / <span class=\"number\">3</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">nextIndex</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> len)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ((i + <span class=\"number\">1</span> &lt; len) ? i + <span class=\"number\">1</span> : <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">prevIndex</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> len)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ((i - <span class=\"number\">1</span> &gt;= <span class=\"number\">0</span>) ? i - <span class=\"number\">1</span> : len - <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> Entry <span class=\"title\">getEntry</span><span class=\"params\">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取当前的key的存储地方</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class=\"number\">1</span>);</span><br><span class=\"line\">        Entry e = table[i];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 当前Entry的key存在，并且等于想要查找的值</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span> &amp;&amp; e.get() == key)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> getEntryAfterMiss(key, i, e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 在指定位置没有查找到，使用线性探查法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> Entry <span class=\"title\">getEntryAfterMiss</span><span class=\"params\">(ThreadLocal&lt;?&gt; key, <span class=\"keyword\">int</span> i, Entry e)</span> </span>&#123;</span><br><span class=\"line\">        Entry[] tab = table;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = tab.length;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (e != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (k == key)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (k == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                <span class=\"comment\">// 清空无效Entry</span></span><br><span class=\"line\">                expungeStaleEntry(i);</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                i = nextIndex(i, len);</span><br><span class=\"line\">            e = tab[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将当前ThreadLocal对象放入到当前map中</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class=\"line\">        Entry[] tab = table;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = tab.length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = key.threadLocalHashCode &amp; (len-<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 遍历当前不为空的entry，查找key是否存在</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Entry e = tab[i];</span><br><span class=\"line\">                e != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class=\"line\">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (k == key) &#123;</span><br><span class=\"line\">                e.value = value;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (k == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 直接使用当前Entry</span></span><br><span class=\"line\">                replaceStaleEntry(key, value, i);</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        tab[i] = <span class=\"keyword\">new</span> Entry(key, value);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sz = ++size;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class=\"line\">            rehash();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 删除当前key</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class=\"line\">        Entry[] tab = table;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = tab.length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = key.threadLocalHashCode &amp; (len-<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 遍历当前Entry[]数组</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Entry e = tab[i];</span><br><span class=\"line\">                e != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (e.get() == key) &#123;</span><br><span class=\"line\">                e.clear();</span><br><span class=\"line\">                expungeStaleEntry(i);</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 这段代码的主要意思我可以猜一下</span></span><br><span class=\"line\">    <span class=\"comment\">// 主要了为了保证在发生冲突的时候，Entry可以尽量离index近一些</span></span><br><span class=\"line\">    <span class=\"comment\">// 里面如果查找到的第一个需要回收的Entry不是当前Entry</span></span><br><span class=\"line\">    <span class=\"comment\">// 则会将两个交换值</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">replaceStaleEntry</span><span class=\"params\">(ThreadLocal&lt;?&gt; key, Object value,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                    <span class=\"keyword\">int</span> staleSlot)</span> </span>&#123;</span><br><span class=\"line\">        Entry[] tab = table;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = tab.length;</span><br><span class=\"line\">        Entry e;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 从当前Slot开始查找最早的可删除Entry</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> slotToExpunge = staleSlot;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = prevIndex(staleSlot, len);</span><br><span class=\"line\">                (e = tab[i]) != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                i = prevIndex(i, len))</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (e.get() == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                slotToExpunge = i;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = nextIndex(staleSlot, len);</span><br><span class=\"line\">                (e = tab[i]) != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                i = nextIndex(i, len)) &#123;</span><br><span class=\"line\">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (k == key) &#123;</span><br><span class=\"line\">                e.value = value;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 交换了位置</span></span><br><span class=\"line\">                tab[i] = tab[staleSlot];</span><br><span class=\"line\">                tab[staleSlot] = e;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (slotToExpunge == staleSlot)</span><br><span class=\"line\">                    slotToExpunge = i;</span><br><span class=\"line\">                <span class=\"comment\">// 有一个清理操作</span></span><br><span class=\"line\">                cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 如果</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (k == <span class=\"keyword\">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class=\"line\">                slotToExpunge = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// for gc</span></span><br><span class=\"line\">        tab[staleSlot].value = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        tab[staleSlot] = <span class=\"keyword\">new</span> Entry(key, value);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 继续回收内存</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (slotToExpunge != staleSlot)</span><br><span class=\"line\">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 删除当前staleSlot的无效Entry，其中还涉及到一个交换过程</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果当前Entry是占用了其他Entry的位置的话，会将其他Entry交换回来</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">expungeStaleEntry</span><span class=\"params\">(<span class=\"keyword\">int</span> staleSlot)</span> </span>&#123;</span><br><span class=\"line\">        Entry[] tab = table;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = tab.length;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// expunge entry at staleSlot</span></span><br><span class=\"line\">        tab[staleSlot].value = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        tab[staleSlot] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        size--;</span><br><span class=\"line\"></span><br><span class=\"line\">        Entry e;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = nextIndex(staleSlot, len);</span><br><span class=\"line\">                (e = tab[i]) != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                i = nextIndex(i, len)) &#123;</span><br><span class=\"line\">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (k == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                e.value = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                tab[i] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                size--;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> h = k.threadLocalHashCode &amp; (len - <span class=\"number\">1</span>);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (h != i) &#123;</span><br><span class=\"line\">                    tab[i] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (tab[h] != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                        h = nextIndex(h, len);</span><br><span class=\"line\">                    tab[h] = e;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 清除一些无效的Entry</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">cleanSomeSlots</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> removed = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        Entry[] tab = table;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = tab.length;</span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">            i = nextIndex(i, len);</span><br><span class=\"line\">            Entry e = tab[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span> &amp;&amp; e.get() == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                n = len;</span><br><span class=\"line\">                removed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                i = expungeStaleEntry(i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">while</span> ( (n &gt;&gt;&gt;= <span class=\"number\">1</span>) != <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> removed;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 执行整理Entry数组，以及扩容操作</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">rehash</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        expungeStaleEntries();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Use lower threshold for doubling to avoid hysteresis</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (size &gt;= threshold - threshold / <span class=\"number\">4</span>)</span><br><span class=\"line\">            resize();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 扩容</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">resize</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Entry[] oldTab = table;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> oldLen = oldTab.length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> newLen = oldLen * <span class=\"number\">2</span>;</span><br><span class=\"line\">        Entry[] newTab = <span class=\"keyword\">new</span> Entry[newLen];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; oldLen; ++j) &#123;</span><br><span class=\"line\">            Entry e = oldTab[j];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (k == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    e.value = <span class=\"keyword\">null</span>; <span class=\"comment\">// Help the GC</span></span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> h = k.threadLocalHashCode &amp; (newLen - <span class=\"number\">1</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (newTab[h] != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                        h = nextIndex(h, newLen);</span><br><span class=\"line\">                    newTab[h] = e;</span><br><span class=\"line\">                    count++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        setThreshold(newLen);</span><br><span class=\"line\">        size = count;</span><br><span class=\"line\">        table = newTab;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">expungeStaleEntries</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Entry[] tab = table;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = tab.length;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; len; j++) &#123;</span><br><span class=\"line\">            Entry e = tab[j];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span> &amp;&amp; e.get() == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                expungeStaleEntry(j);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"内存泄漏\"><a href=\"#内存泄漏\" class=\"headerlink\" title=\"内存泄漏\"></a>内存泄漏</h1><p>大概率发生在一个情况下：<br>线程长时间存活，并且在使用过ThreadLocal之后，没有后续任何使用，并且也没有调用ThreadLocal.remove()方法，<br>导致value对象内存泄漏。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h1><p>Thread对象中有一个<a href=\"/2018/06/23/Thread%E5%88%86%E6%9E%90/\">ThreadLocalMap</a>对象，ThreadLocal对象被存储在线程的ThreadLocalMap中，叫做threadLocals。<br>","more":"</p>\n<h1 id=\"主要方法\"><a href=\"#主要方法\" class=\"headerlink\" title=\"主要方法\"></a>主要方法</h1><h2 id=\"get\"><a href=\"#get\" class=\"headerlink\" title=\"get\"></a>get</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ThreadLocalMap <span class=\"title\">getMap</span><span class=\"params\">(Thread t)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> t.threadLocals;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置初始的Map</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">createMap</span><span class=\"params\">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class=\"line\">    t.threadLocals = <span class=\"keyword\">new</span> ThreadLocalMap(<span class=\"keyword\">this</span>, firstValue);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 初始化Map，或者设置当前的初始值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> T <span class=\"title\">setInitialValue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    T value = initialValue();</span><br><span class=\"line\">    Thread t = Thread.currentThread();</span><br><span class=\"line\">    ThreadLocalMap map = getMap(t);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        map.set(<span class=\"keyword\">this</span>, value);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        createMap(t, value);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取当前线程</span></span><br><span class=\"line\">    Thread t = Thread.currentThread();</span><br><span class=\"line\">    <span class=\"comment\">// 获取当前线程的threadLocals</span></span><br><span class=\"line\">    ThreadLocalMap map = getMap(t);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果当前map不为空</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        ThreadLocalMap.Entry e = map.getEntry(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">            T result = (T)e.value;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 设置初始值</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> setInitialValue();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set\"></a>set</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(T value)</span> </span>&#123;</span><br><span class=\"line\">    Thread t = Thread.currentThread();</span><br><span class=\"line\">    ThreadLocalMap map = getMap(t);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"comment\">// 直接设置map的初始值</span></span><br><span class=\"line\">        map.set(<span class=\"keyword\">this</span>, value);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        createMap(t, value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"ThreadLocalMap\"><a href=\"#ThreadLocalMap\" class=\"headerlink\" title=\"ThreadLocalMap\"></a>ThreadLocalMap</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadLocalMap</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 特别重要的一点，防止内存泄漏</span></span><br><span class=\"line\">    <span class=\"comment\">// WeakReference</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Entry</span> <span class=\"keyword\">extends</span> <span class=\"title\">WeakReference</span>&lt;<span class=\"title\">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class=\"line\">        Object value;</span><br><span class=\"line\"></span><br><span class=\"line\">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>(k);</span><br><span class=\"line\">            value = v;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> INITIAL_CAPACITY = <span class=\"number\">16</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Entry[] table;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> size = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> threshold;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">setThreshold</span><span class=\"params\">(<span class=\"keyword\">int</span> len)</span> </span>&#123;</span><br><span class=\"line\">        threshold = len * <span class=\"number\">2</span> / <span class=\"number\">3</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">nextIndex</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> len)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ((i + <span class=\"number\">1</span> &lt; len) ? i + <span class=\"number\">1</span> : <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">prevIndex</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> len)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ((i - <span class=\"number\">1</span> &gt;= <span class=\"number\">0</span>) ? i - <span class=\"number\">1</span> : len - <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> Entry <span class=\"title\">getEntry</span><span class=\"params\">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取当前的key的存储地方</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class=\"number\">1</span>);</span><br><span class=\"line\">        Entry e = table[i];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 当前Entry的key存在，并且等于想要查找的值</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span> &amp;&amp; e.get() == key)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> getEntryAfterMiss(key, i, e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 在指定位置没有查找到，使用线性探查法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> Entry <span class=\"title\">getEntryAfterMiss</span><span class=\"params\">(ThreadLocal&lt;?&gt; key, <span class=\"keyword\">int</span> i, Entry e)</span> </span>&#123;</span><br><span class=\"line\">        Entry[] tab = table;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = tab.length;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (e != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (k == key)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (k == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                <span class=\"comment\">// 清空无效Entry</span></span><br><span class=\"line\">                expungeStaleEntry(i);</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                i = nextIndex(i, len);</span><br><span class=\"line\">            e = tab[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将当前ThreadLocal对象放入到当前map中</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class=\"line\">        Entry[] tab = table;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = tab.length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = key.threadLocalHashCode &amp; (len-<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 遍历当前不为空的entry，查找key是否存在</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Entry e = tab[i];</span><br><span class=\"line\">                e != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class=\"line\">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (k == key) &#123;</span><br><span class=\"line\">                e.value = value;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (k == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 直接使用当前Entry</span></span><br><span class=\"line\">                replaceStaleEntry(key, value, i);</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        tab[i] = <span class=\"keyword\">new</span> Entry(key, value);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sz = ++size;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class=\"line\">            rehash();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 删除当前key</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class=\"line\">        Entry[] tab = table;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = tab.length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = key.threadLocalHashCode &amp; (len-<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 遍历当前Entry[]数组</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Entry e = tab[i];</span><br><span class=\"line\">                e != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (e.get() == key) &#123;</span><br><span class=\"line\">                e.clear();</span><br><span class=\"line\">                expungeStaleEntry(i);</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 这段代码的主要意思我可以猜一下</span></span><br><span class=\"line\">    <span class=\"comment\">// 主要了为了保证在发生冲突的时候，Entry可以尽量离index近一些</span></span><br><span class=\"line\">    <span class=\"comment\">// 里面如果查找到的第一个需要回收的Entry不是当前Entry</span></span><br><span class=\"line\">    <span class=\"comment\">// 则会将两个交换值</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">replaceStaleEntry</span><span class=\"params\">(ThreadLocal&lt;?&gt; key, Object value,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                    <span class=\"keyword\">int</span> staleSlot)</span> </span>&#123;</span><br><span class=\"line\">        Entry[] tab = table;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = tab.length;</span><br><span class=\"line\">        Entry e;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 从当前Slot开始查找最早的可删除Entry</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> slotToExpunge = staleSlot;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = prevIndex(staleSlot, len);</span><br><span class=\"line\">                (e = tab[i]) != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                i = prevIndex(i, len))</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (e.get() == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                slotToExpunge = i;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = nextIndex(staleSlot, len);</span><br><span class=\"line\">                (e = tab[i]) != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                i = nextIndex(i, len)) &#123;</span><br><span class=\"line\">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (k == key) &#123;</span><br><span class=\"line\">                e.value = value;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 交换了位置</span></span><br><span class=\"line\">                tab[i] = tab[staleSlot];</span><br><span class=\"line\">                tab[staleSlot] = e;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (slotToExpunge == staleSlot)</span><br><span class=\"line\">                    slotToExpunge = i;</span><br><span class=\"line\">                <span class=\"comment\">// 有一个清理操作</span></span><br><span class=\"line\">                cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 如果</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (k == <span class=\"keyword\">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class=\"line\">                slotToExpunge = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// for gc</span></span><br><span class=\"line\">        tab[staleSlot].value = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        tab[staleSlot] = <span class=\"keyword\">new</span> Entry(key, value);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 继续回收内存</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (slotToExpunge != staleSlot)</span><br><span class=\"line\">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 删除当前staleSlot的无效Entry，其中还涉及到一个交换过程</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果当前Entry是占用了其他Entry的位置的话，会将其他Entry交换回来</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">expungeStaleEntry</span><span class=\"params\">(<span class=\"keyword\">int</span> staleSlot)</span> </span>&#123;</span><br><span class=\"line\">        Entry[] tab = table;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = tab.length;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// expunge entry at staleSlot</span></span><br><span class=\"line\">        tab[staleSlot].value = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        tab[staleSlot] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        size--;</span><br><span class=\"line\"></span><br><span class=\"line\">        Entry e;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = nextIndex(staleSlot, len);</span><br><span class=\"line\">                (e = tab[i]) != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                i = nextIndex(i, len)) &#123;</span><br><span class=\"line\">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (k == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                e.value = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                tab[i] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                size--;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> h = k.threadLocalHashCode &amp; (len - <span class=\"number\">1</span>);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (h != i) &#123;</span><br><span class=\"line\">                    tab[i] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (tab[h] != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                        h = nextIndex(h, len);</span><br><span class=\"line\">                    tab[h] = e;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 清除一些无效的Entry</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">cleanSomeSlots</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> removed = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        Entry[] tab = table;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = tab.length;</span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">            i = nextIndex(i, len);</span><br><span class=\"line\">            Entry e = tab[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span> &amp;&amp; e.get() == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                n = len;</span><br><span class=\"line\">                removed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                i = expungeStaleEntry(i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">while</span> ( (n &gt;&gt;&gt;= <span class=\"number\">1</span>) != <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> removed;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 执行整理Entry数组，以及扩容操作</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">rehash</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        expungeStaleEntries();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Use lower threshold for doubling to avoid hysteresis</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (size &gt;= threshold - threshold / <span class=\"number\">4</span>)</span><br><span class=\"line\">            resize();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 扩容</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">resize</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Entry[] oldTab = table;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> oldLen = oldTab.length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> newLen = oldLen * <span class=\"number\">2</span>;</span><br><span class=\"line\">        Entry[] newTab = <span class=\"keyword\">new</span> Entry[newLen];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; oldLen; ++j) &#123;</span><br><span class=\"line\">            Entry e = oldTab[j];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (k == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    e.value = <span class=\"keyword\">null</span>; <span class=\"comment\">// Help the GC</span></span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> h = k.threadLocalHashCode &amp; (newLen - <span class=\"number\">1</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (newTab[h] != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                        h = nextIndex(h, newLen);</span><br><span class=\"line\">                    newTab[h] = e;</span><br><span class=\"line\">                    count++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        setThreshold(newLen);</span><br><span class=\"line\">        size = count;</span><br><span class=\"line\">        table = newTab;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">expungeStaleEntries</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Entry[] tab = table;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = tab.length;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; len; j++) &#123;</span><br><span class=\"line\">            Entry e = tab[j];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span> &amp;&amp; e.get() == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                expungeStaleEntry(j);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"内存泄漏\"><a href=\"#内存泄漏\" class=\"headerlink\" title=\"内存泄漏\"></a>内存泄漏</h1><p>大概率发生在一个情况下：<br>线程长时间存活，并且在使用过ThreadLocal之后，没有后续任何使用，并且也没有调用ThreadLocal.remove()方法，<br>导致value对象内存泄漏。</p>"},{"title":"Unsafe分析","date":"2018-06-23T10:26:15.000Z","toc":true,"_content":"Unsafe类是一个拥有大量native方法的一个类，里面都是比较底层的接口\n# get与put\n主要是操作一个无法访问的属性值。\n```java\n// 获取类内的属性值\npublic native int getInt(Object var1, long var2);\n// 将类偏移量为var2的地方值设置为var4\npublic native void putInt(Object var1, long var2, int var4);\n```\n<!-- more -->\n# memory\n主要是对直接内存的操作，被`DirectByteBuffer`调用\n```java\n// 分配内存\npublic native long allocateMemory(long var1);\n// 在原地址var1重新分配大小为var3的内存\npublic native long reallocateMemory(long var1, long var3);\n// 在var1对象的var2地址的长度为var4的一块内存的值初始化为var6\npublic native void setMemory(Object var1, long var2, long var4, byte var6);\npublic void setMemory(long var1, long var3, byte var5) {\n    this.setMemory((Object)null, var1, var3, var5);\n}\n// 复制内存\npublic native void copyMemory(Object var1, long var2, Object var4, long var5, long var7);\npublic void copyMemory(long var1, long var3, long var5) {\n    this.copyMemory((Object)null, var1, (Object)null, var3, var5);\n}\n// 释放内存\npublic native void freeMemory(long var1);\n```\n\n# offset\n获取了offset主要是为了cas操作\n```java\n// 用于获取各个不同类型属性的偏移量\npublic native long staticFieldOffset(Field var1);\npublic native long objectFieldOffset(Field var1);\npublic native Object staticFieldBase(Field var1);\npublic native int arrayBaseOffset(Class<?> var1);\npublic native int arrayIndexScale(Class<?> var1);\n```\n\n# CAS\n主要是为了无锁数据结构使用，以及atomic类使用，实现调用了处理器的**lock，cmpxchg指令**。\n```java\n// 第二个参数是偏移量\npublic final native boolean compareAndSwapObject(Object var1, long var2, Object var4, Object var5);\npublic final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);\npublic final native boolean compareAndSwapLong(Object var1, long var2, long var4, long var6);\n```\n```c\n// 用于添加lock指令\n// 说一下lock指令，1、确保对内存的读-改-写操作原子执行 2、禁止该指令与前后的读写指令重排序 3、把写缓冲区中的所有数据刷新到内存中\n// 在Pentium处理器之前，lock操作之间锁住内存总线的\n// 但是在Pentium4处理器之后，intel做了一个优化\n// 如果lock后面的指令需要访问的内存已经完整地在一个缓存行之中，则将转为锁住缓存行\n// 但是如果不在缓存行之中，则会锁住整个内存总线。\n#define LOCK_IF_MP(mp) __asm cmp mp, 0  \\\n                       __asm je L0      \\\n                       __asm _emit 0xF0 \\\n                       __asm L0:\ninline jint     Atomic::cmpxchg(jint     exchange_value, volatile jint*     dest, jint     compare_value) {\n  // 判断当前处理器是不是多核处理器\n  int mp = os::is_MP();\n  __asm {\n    mov edx, dest\n    mov ecx, exchange_value\n    mov eax, compare_value\n    // 将eax与原值作比较，如果相同则将ecx的值，写入edx指向的地址\n    // 多核处理器上，指令变成如此，lock cmpxchg dword ptr [edx], ecx \n    LOCK_IF_MP(mp)\n    cmpxchg dword ptr [edx], ecx \n  }\n}\n```\n\n# volatile, ordered\n**putOrderedInt的原理是使用了storeStore屏障（sfence），性能比\bstoreLoad快20%\b，但是不保证立马可见**\n```java\npublic native Object getObjectVolatile(Object var1, long var2);\npublic native void putObjectVolatile(Object var1, long var2, Object var4);\npublic native int getIntVolatile(Object var1, long var2);\npublic native void putIntVolatile(Object var1, long var2, int var4);\npublic native boolean getBooleanVolatile(Object var1, long var2);\npublic native void putBooleanVolatile(Object var1, long var2, boolean var4);\npublic native byte getByteVolatile(Object var1, long var2);\npublic native void putByteVolatile(Object var1, long var2, byte var4);\npublic native short getShortVolatile(Object var1, long var2);\npublic native void putShortVolatile(Object var1, long var2, short var4);\npublic native char getCharVolatile(Object var1, long var2);\npublic native void putCharVolatile(Object var1, long var2, char var4);\npublic native long getLongVolatile(Object var1, long var2);\npublic native void putLongVolatile(Object var1, long var2, long var4);\npublic native float getFloatVolatile(Object var1, long var2);\npublic native void putFloatVolatile(Object var1, long var2, float var4);\npublic native double getDoubleVolatile(Object var1, long var2);\npublic native void putDoubleVolatile(Object var1, long var2, double var4);\npublic native void putOrderedObject(Object var1, long var2, Object var4);\npublic native void putOrderedInt(Object var1, long var2, int var4);\npublic native void putOrderedLong(Object var1, long var2, long var4);\n```\n# park\n其实主要还是每个线程拥有一个Parker实例\n调用Unsafe.park的时候，会调用当前线程Parker实例的对应方法\n```java\npublic native void unpark(Object var1);\npublic native void park(boolean var1, long var2);\n\nclass Parker : public os::PlatformParker {\nprivate:\n  volatile int _counter ;\n  Parker * FreeNext ;\n  JavaThread * AssociatedWith ; // Current association\n\npublic:\n  Parker() : PlatformParker() {\n    _counter       = 0 ;\n    FreeNext       = NULL ;\n    AssociatedWith = NULL ;\n  }\nprotected:\n  ~Parker() { ShouldNotReachHere(); }\npublic:\n  // For simplicity of interface with Java, all forms of park (indefinite,\n  // relative, and absolute) are multiplexed into one call.\n  void park(bool isAbsolute, jlong time);\n  void unpark();\n\n  // Lifecycle operators\n  static Parker * Allocate (JavaThread * t) ;\n  static void Release (Parker * e) ;\nprivate:\n  static Parker * volatile FreeList ;\n  static volatile int ListLock ;\n\n};\n\nvoid Parker::park(bool isAbsolute, jlong time) {\n  // 代表被unpark过\n  if (Atomic::xchg(0, &_counter) > 0) return;\n\n  Thread* thread = Thread::current();\n  assert(thread->is_Java_thread(), \"Must be JavaThread\");\n  JavaThread *jt = (JavaThread *)thread;\n\n  if (Thread::is_interrupted(thread, false)) {\n    return;\n  }\n\n  timespec absTime;\n  if (time < 0 || (isAbsolute && time == 0) ) { // don't wait at all\n    return;\n  }\n  if (time > 0) {\n    unpackTime(&absTime, isAbsolute, time);\n  }\n\n  ThreadBlockInVM tbivm(jt);\n  if (Thread::is_interrupted(thread, false) || pthread_mutex_trylock(_mutex) != 0) {\n    return;\n  }\n\n  int status ;\n  if (_counter > 0)  { // no wait needed\n    _counter = 0;\n    status = pthread_mutex_unlock(_mutex);\n    assert (status == 0, \"invariant\") ;\n\n    // 插入一个完全的屏障\n    OrderAccess::fence();\n    return;\n  }\n\n  OSThreadWaitState osts(thread->osthread(), false /* not Object.wait() */);\n  jt->set_suspend_equivalent();\n  assert(_cur_index == -1, \"invariant\");\n\n  if (time == 0) {\n    _cur_index = REL_INDEX; // arbitrary choice when not timed\n    // 等待被释放，不知道为什么要使用这个不同的信号量\n    status = pthread_cond_wait (&_cond[_cur_index], _mutex) ;\n  } else {\n    _cur_index = isAbsolute ? ABS_INDEX : REL_INDEX;\n    // 等待被释放\n    status = os::Linux::safe_cond_timedwait (&_cond[_cur_index], _mutex, &absTime) ;\n    if (status != 0 && WorkAroundNPTLTimedWaitHang) {\n      pthread_cond_destroy (&_cond[_cur_index]) ;\n      pthread_cond_init    (&_cond[_cur_index], isAbsolute ? NULL : os::Linux::condAttr());\n    }\n  }\n  _cur_index = -1;\n  assert_status(status == 0 || status == EINTR ||\n                status == ETIME || status == ETIMEDOUT,\n                status, \"cond_timedwait\");\n\n#ifdef ASSERT\n  pthread_sigmask(SIG_SETMASK, &oldsigs, NULL);\n#endif\n\n  _counter = 0 ;\n  status = pthread_mutex_unlock(_mutex) ;\n  assert_status(status == 0, status, \"invariant\") ;\n  OrderAccess::fence();\n\n  if (jt->handle_special_suspend_equivalent_condition()) {\n    jt->java_suspend_self();\n  }\n}\n\nvoid Parker::unpark() {\n  int s, status ;\n  status = pthread_mutex_lock(_mutex);\n  assert (status == 0, \"invariant\") ;\n  s = _counter;\n  _counter = 1;\n  if (s < 1) {\n    // thread might be parked\n    if (_cur_index != -1) {\n      // thread is definitely parked\n      if (WorkAroundNPTLTimedWaitHang) {\n        status = pthread_cond_signal (&_cond[_cur_index]);\n        assert (status == 0, \"invariant\");\n        status = pthread_mutex_unlock(_mutex);\n        assert (status == 0, \"invariant\");\n      } else {\n        status = pthread_mutex_unlock(_mutex);\n        assert (status == 0, \"invariant\");\n        status = pthread_cond_signal (&_cond[_cur_index]);\n        assert (status == 0, \"invariant\");\n      }\n    } else {\n      pthread_mutex_unlock(_mutex);\n      assert (status == 0, \"invariant\") ;\n    }\n  } else {\n    pthread_mutex_unlock(_mutex);\n    assert (status == 0, \"invariant\") ;\n  }\n}\n```","source":"_posts/Unsafe分析.md","raw":"---\ntitle: Unsafe分析\ndate: 2018-06-23 18:26:15\ntags:\n- java\n- 并发\n- 源码\ncategories:\n- java\n- 并发\ntoc: true\n---\nUnsafe类是一个拥有大量native方法的一个类，里面都是比较底层的接口\n# get与put\n主要是操作一个无法访问的属性值。\n```java\n// 获取类内的属性值\npublic native int getInt(Object var1, long var2);\n// 将类偏移量为var2的地方值设置为var4\npublic native void putInt(Object var1, long var2, int var4);\n```\n<!-- more -->\n# memory\n主要是对直接内存的操作，被`DirectByteBuffer`调用\n```java\n// 分配内存\npublic native long allocateMemory(long var1);\n// 在原地址var1重新分配大小为var3的内存\npublic native long reallocateMemory(long var1, long var3);\n// 在var1对象的var2地址的长度为var4的一块内存的值初始化为var6\npublic native void setMemory(Object var1, long var2, long var4, byte var6);\npublic void setMemory(long var1, long var3, byte var5) {\n    this.setMemory((Object)null, var1, var3, var5);\n}\n// 复制内存\npublic native void copyMemory(Object var1, long var2, Object var4, long var5, long var7);\npublic void copyMemory(long var1, long var3, long var5) {\n    this.copyMemory((Object)null, var1, (Object)null, var3, var5);\n}\n// 释放内存\npublic native void freeMemory(long var1);\n```\n\n# offset\n获取了offset主要是为了cas操作\n```java\n// 用于获取各个不同类型属性的偏移量\npublic native long staticFieldOffset(Field var1);\npublic native long objectFieldOffset(Field var1);\npublic native Object staticFieldBase(Field var1);\npublic native int arrayBaseOffset(Class<?> var1);\npublic native int arrayIndexScale(Class<?> var1);\n```\n\n# CAS\n主要是为了无锁数据结构使用，以及atomic类使用，实现调用了处理器的**lock，cmpxchg指令**。\n```java\n// 第二个参数是偏移量\npublic final native boolean compareAndSwapObject(Object var1, long var2, Object var4, Object var5);\npublic final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);\npublic final native boolean compareAndSwapLong(Object var1, long var2, long var4, long var6);\n```\n```c\n// 用于添加lock指令\n// 说一下lock指令，1、确保对内存的读-改-写操作原子执行 2、禁止该指令与前后的读写指令重排序 3、把写缓冲区中的所有数据刷新到内存中\n// 在Pentium处理器之前，lock操作之间锁住内存总线的\n// 但是在Pentium4处理器之后，intel做了一个优化\n// 如果lock后面的指令需要访问的内存已经完整地在一个缓存行之中，则将转为锁住缓存行\n// 但是如果不在缓存行之中，则会锁住整个内存总线。\n#define LOCK_IF_MP(mp) __asm cmp mp, 0  \\\n                       __asm je L0      \\\n                       __asm _emit 0xF0 \\\n                       __asm L0:\ninline jint     Atomic::cmpxchg(jint     exchange_value, volatile jint*     dest, jint     compare_value) {\n  // 判断当前处理器是不是多核处理器\n  int mp = os::is_MP();\n  __asm {\n    mov edx, dest\n    mov ecx, exchange_value\n    mov eax, compare_value\n    // 将eax与原值作比较，如果相同则将ecx的值，写入edx指向的地址\n    // 多核处理器上，指令变成如此，lock cmpxchg dword ptr [edx], ecx \n    LOCK_IF_MP(mp)\n    cmpxchg dword ptr [edx], ecx \n  }\n}\n```\n\n# volatile, ordered\n**putOrderedInt的原理是使用了storeStore屏障（sfence），性能比\bstoreLoad快20%\b，但是不保证立马可见**\n```java\npublic native Object getObjectVolatile(Object var1, long var2);\npublic native void putObjectVolatile(Object var1, long var2, Object var4);\npublic native int getIntVolatile(Object var1, long var2);\npublic native void putIntVolatile(Object var1, long var2, int var4);\npublic native boolean getBooleanVolatile(Object var1, long var2);\npublic native void putBooleanVolatile(Object var1, long var2, boolean var4);\npublic native byte getByteVolatile(Object var1, long var2);\npublic native void putByteVolatile(Object var1, long var2, byte var4);\npublic native short getShortVolatile(Object var1, long var2);\npublic native void putShortVolatile(Object var1, long var2, short var4);\npublic native char getCharVolatile(Object var1, long var2);\npublic native void putCharVolatile(Object var1, long var2, char var4);\npublic native long getLongVolatile(Object var1, long var2);\npublic native void putLongVolatile(Object var1, long var2, long var4);\npublic native float getFloatVolatile(Object var1, long var2);\npublic native void putFloatVolatile(Object var1, long var2, float var4);\npublic native double getDoubleVolatile(Object var1, long var2);\npublic native void putDoubleVolatile(Object var1, long var2, double var4);\npublic native void putOrderedObject(Object var1, long var2, Object var4);\npublic native void putOrderedInt(Object var1, long var2, int var4);\npublic native void putOrderedLong(Object var1, long var2, long var4);\n```\n# park\n其实主要还是每个线程拥有一个Parker实例\n调用Unsafe.park的时候，会调用当前线程Parker实例的对应方法\n```java\npublic native void unpark(Object var1);\npublic native void park(boolean var1, long var2);\n\nclass Parker : public os::PlatformParker {\nprivate:\n  volatile int _counter ;\n  Parker * FreeNext ;\n  JavaThread * AssociatedWith ; // Current association\n\npublic:\n  Parker() : PlatformParker() {\n    _counter       = 0 ;\n    FreeNext       = NULL ;\n    AssociatedWith = NULL ;\n  }\nprotected:\n  ~Parker() { ShouldNotReachHere(); }\npublic:\n  // For simplicity of interface with Java, all forms of park (indefinite,\n  // relative, and absolute) are multiplexed into one call.\n  void park(bool isAbsolute, jlong time);\n  void unpark();\n\n  // Lifecycle operators\n  static Parker * Allocate (JavaThread * t) ;\n  static void Release (Parker * e) ;\nprivate:\n  static Parker * volatile FreeList ;\n  static volatile int ListLock ;\n\n};\n\nvoid Parker::park(bool isAbsolute, jlong time) {\n  // 代表被unpark过\n  if (Atomic::xchg(0, &_counter) > 0) return;\n\n  Thread* thread = Thread::current();\n  assert(thread->is_Java_thread(), \"Must be JavaThread\");\n  JavaThread *jt = (JavaThread *)thread;\n\n  if (Thread::is_interrupted(thread, false)) {\n    return;\n  }\n\n  timespec absTime;\n  if (time < 0 || (isAbsolute && time == 0) ) { // don't wait at all\n    return;\n  }\n  if (time > 0) {\n    unpackTime(&absTime, isAbsolute, time);\n  }\n\n  ThreadBlockInVM tbivm(jt);\n  if (Thread::is_interrupted(thread, false) || pthread_mutex_trylock(_mutex) != 0) {\n    return;\n  }\n\n  int status ;\n  if (_counter > 0)  { // no wait needed\n    _counter = 0;\n    status = pthread_mutex_unlock(_mutex);\n    assert (status == 0, \"invariant\") ;\n\n    // 插入一个完全的屏障\n    OrderAccess::fence();\n    return;\n  }\n\n  OSThreadWaitState osts(thread->osthread(), false /* not Object.wait() */);\n  jt->set_suspend_equivalent();\n  assert(_cur_index == -1, \"invariant\");\n\n  if (time == 0) {\n    _cur_index = REL_INDEX; // arbitrary choice when not timed\n    // 等待被释放，不知道为什么要使用这个不同的信号量\n    status = pthread_cond_wait (&_cond[_cur_index], _mutex) ;\n  } else {\n    _cur_index = isAbsolute ? ABS_INDEX : REL_INDEX;\n    // 等待被释放\n    status = os::Linux::safe_cond_timedwait (&_cond[_cur_index], _mutex, &absTime) ;\n    if (status != 0 && WorkAroundNPTLTimedWaitHang) {\n      pthread_cond_destroy (&_cond[_cur_index]) ;\n      pthread_cond_init    (&_cond[_cur_index], isAbsolute ? NULL : os::Linux::condAttr());\n    }\n  }\n  _cur_index = -1;\n  assert_status(status == 0 || status == EINTR ||\n                status == ETIME || status == ETIMEDOUT,\n                status, \"cond_timedwait\");\n\n#ifdef ASSERT\n  pthread_sigmask(SIG_SETMASK, &oldsigs, NULL);\n#endif\n\n  _counter = 0 ;\n  status = pthread_mutex_unlock(_mutex) ;\n  assert_status(status == 0, status, \"invariant\") ;\n  OrderAccess::fence();\n\n  if (jt->handle_special_suspend_equivalent_condition()) {\n    jt->java_suspend_self();\n  }\n}\n\nvoid Parker::unpark() {\n  int s, status ;\n  status = pthread_mutex_lock(_mutex);\n  assert (status == 0, \"invariant\") ;\n  s = _counter;\n  _counter = 1;\n  if (s < 1) {\n    // thread might be parked\n    if (_cur_index != -1) {\n      // thread is definitely parked\n      if (WorkAroundNPTLTimedWaitHang) {\n        status = pthread_cond_signal (&_cond[_cur_index]);\n        assert (status == 0, \"invariant\");\n        status = pthread_mutex_unlock(_mutex);\n        assert (status == 0, \"invariant\");\n      } else {\n        status = pthread_mutex_unlock(_mutex);\n        assert (status == 0, \"invariant\");\n        status = pthread_cond_signal (&_cond[_cur_index]);\n        assert (status == 0, \"invariant\");\n      }\n    } else {\n      pthread_mutex_unlock(_mutex);\n      assert (status == 0, \"invariant\") ;\n    }\n  } else {\n    pthread_mutex_unlock(_mutex);\n    assert (status == 0, \"invariant\") ;\n  }\n}\n```","slug":"Unsafe分析","published":1,"updated":"2018-06-23T10:31:19.548Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5u1tve00171av88ehgb92z","content":"<p>Unsafe类是一个拥有大量native方法的一个类，里面都是比较底层的接口</p>\n<h1 id=\"get与put\"><a href=\"#get与put\" class=\"headerlink\" title=\"get与put\"></a>get与put</h1><p>主要是操作一个无法访问的属性值。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取类内的属性值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">int</span> <span class=\"title\">getInt</span><span class=\"params\">(Object var1, <span class=\"keyword\">long</span> var2)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 将类偏移量为var2的地方值设置为var4</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title\">putInt</span><span class=\"params\">(Object var1, <span class=\"keyword\">long</span> var2, <span class=\"keyword\">int</span> var4)</span></span>;</span><br></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<h1 id=\"memory\"><a href=\"#memory\" class=\"headerlink\" title=\"memory\"></a>memory</h1><p>主要是对直接内存的操作，被<code>DirectByteBuffer</code>调用<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 分配内存</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">long</span> <span class=\"title\">allocateMemory</span><span class=\"params\">(<span class=\"keyword\">long</span> var1)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 在原地址var1重新分配大小为var3的内存</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">long</span> <span class=\"title\">reallocateMemory</span><span class=\"params\">(<span class=\"keyword\">long</span> var1, <span class=\"keyword\">long</span> var3)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 在var1对象的var2地址的长度为var4的一块内存的值初始化为var6</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title\">setMemory</span><span class=\"params\">(Object var1, <span class=\"keyword\">long</span> var2, <span class=\"keyword\">long</span> var4, <span class=\"keyword\">byte</span> var6)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setMemory</span><span class=\"params\">(<span class=\"keyword\">long</span> var1, <span class=\"keyword\">long</span> var3, <span class=\"keyword\">byte</span> var5)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setMemory((Object)<span class=\"keyword\">null</span>, var1, var3, var5);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 复制内存</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title\">copyMemory</span><span class=\"params\">(Object var1, <span class=\"keyword\">long</span> var2, Object var4, <span class=\"keyword\">long</span> var5, <span class=\"keyword\">long</span> var7)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">copyMemory</span><span class=\"params\">(<span class=\"keyword\">long</span> var1, <span class=\"keyword\">long</span> var3, <span class=\"keyword\">long</span> var5)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.copyMemory((Object)<span class=\"keyword\">null</span>, var1, (Object)<span class=\"keyword\">null</span>, var3, var5);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 释放内存</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title\">freeMemory</span><span class=\"params\">(<span class=\"keyword\">long</span> var1)</span></span>;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"offset\"><a href=\"#offset\" class=\"headerlink\" title=\"offset\"></a>offset</h1><p>获取了offset主要是为了cas操作<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 用于获取各个不同类型属性的偏移量</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">long</span> <span class=\"title\">staticFieldOffset</span><span class=\"params\">(Field var1)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">long</span> <span class=\"title\">objectFieldOffset</span><span class=\"params\">(Field var1)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> Object <span class=\"title\">staticFieldBase</span><span class=\"params\">(Field var1)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">int</span> <span class=\"title\">arrayBaseOffset</span><span class=\"params\">(Class&lt;?&gt; var1)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">int</span> <span class=\"title\">arrayIndexScale</span><span class=\"params\">(Class&lt;?&gt; var1)</span></span>;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"CAS\"><a href=\"#CAS\" class=\"headerlink\" title=\"CAS\"></a>CAS</h1><p>主要是为了无锁数据结构使用，以及atomic类使用，实现调用了处理器的<strong>lock，cmpxchg指令</strong>。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 第二个参数是偏移量</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">native</span> <span class=\"keyword\">boolean</span> <span class=\"title\">compareAndSwapObject</span><span class=\"params\">(Object var1, <span class=\"keyword\">long</span> var2, Object var4, Object var5)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">native</span> <span class=\"keyword\">boolean</span> <span class=\"title\">compareAndSwapInt</span><span class=\"params\">(Object var1, <span class=\"keyword\">long</span> var2, <span class=\"keyword\">int</span> var4, <span class=\"keyword\">int</span> var5)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">native</span> <span class=\"keyword\">boolean</span> <span class=\"title\">compareAndSwapLong</span><span class=\"params\">(Object var1, <span class=\"keyword\">long</span> var2, <span class=\"keyword\">long</span> var4, <span class=\"keyword\">long</span> var6)</span></span>;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 用于添加lock指令</span></span><br><span class=\"line\"><span class=\"comment\">// 说一下lock指令，1、确保对内存的读-改-写操作原子执行 2、禁止该指令与前后的读写指令重排序 3、把写缓冲区中的所有数据刷新到内存中</span></span><br><span class=\"line\"><span class=\"comment\">// 在Pentium处理器之前，lock操作之间锁住内存总线的</span></span><br><span class=\"line\"><span class=\"comment\">// 但是在Pentium4处理器之后，intel做了一个优化</span></span><br><span class=\"line\"><span class=\"comment\">// 如果lock后面的指令需要访问的内存已经完整地在一个缓存行之中，则将转为锁住缓存行</span></span><br><span class=\"line\"><span class=\"comment\">// 但是如果不在缓存行之中，则会锁住整个内存总线。</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> LOCK_IF_MP(mp) __asm cmp mp, 0  \\</span></span><br><span class=\"line\">                       __asm je L0      \\</span><br><span class=\"line\">                       __asm _emit <span class=\"number\">0xF0</span> \\</span><br><span class=\"line\">                       __asm L0:</span><br><span class=\"line\"><span class=\"keyword\">inline</span> jint     Atomic::cmpxchg(jint     exchange_value, <span class=\"keyword\">volatile</span> jint*     dest, jint     compare_value) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 判断当前处理器是不是多核处理器</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> mp = os::is_MP();</span><br><span class=\"line\">  __asm &#123;</span><br><span class=\"line\">    mov edx, dest</span><br><span class=\"line\">    mov ecx, exchange_value</span><br><span class=\"line\">    mov eax, compare_value</span><br><span class=\"line\">    <span class=\"comment\">// 将eax与原值作比较，如果相同则将ecx的值，写入edx指向的地址</span></span><br><span class=\"line\">    <span class=\"comment\">// 多核处理器上，指令变成如此，lock cmpxchg dword ptr [edx], ecx </span></span><br><span class=\"line\">    LOCK_IF_MP(mp)</span><br><span class=\"line\">    cmpxchg dword ptr [edx], ecx </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"volatile-ordered\"><a href=\"#volatile-ordered\" class=\"headerlink\" title=\"volatile, ordered\"></a>volatile, ordered</h1><p><strong>putOrderedInt的原理是使用了storeStore屏障（sfence），性能比\bstoreLoad快20%\b，但是不保证立马可见</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> Object <span class=\"title\">getObjectVolatile</span><span class=\"params\">(Object var1, <span class=\"keyword\">long</span> var2)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title\">putObjectVolatile</span><span class=\"params\">(Object var1, <span class=\"keyword\">long</span> var2, Object var4)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">int</span> <span class=\"title\">getIntVolatile</span><span class=\"params\">(Object var1, <span class=\"keyword\">long</span> var2)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title\">putIntVolatile</span><span class=\"params\">(Object var1, <span class=\"keyword\">long</span> var2, <span class=\"keyword\">int</span> var4)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">boolean</span> <span class=\"title\">getBooleanVolatile</span><span class=\"params\">(Object var1, <span class=\"keyword\">long</span> var2)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title\">putBooleanVolatile</span><span class=\"params\">(Object var1, <span class=\"keyword\">long</span> var2, <span class=\"keyword\">boolean</span> var4)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">byte</span> <span class=\"title\">getByteVolatile</span><span class=\"params\">(Object var1, <span class=\"keyword\">long</span> var2)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title\">putByteVolatile</span><span class=\"params\">(Object var1, <span class=\"keyword\">long</span> var2, <span class=\"keyword\">byte</span> var4)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">short</span> <span class=\"title\">getShortVolatile</span><span class=\"params\">(Object var1, <span class=\"keyword\">long</span> var2)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title\">putShortVolatile</span><span class=\"params\">(Object var1, <span class=\"keyword\">long</span> var2, <span class=\"keyword\">short</span> var4)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">char</span> <span class=\"title\">getCharVolatile</span><span class=\"params\">(Object var1, <span class=\"keyword\">long</span> var2)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title\">putCharVolatile</span><span class=\"params\">(Object var1, <span class=\"keyword\">long</span> var2, <span class=\"keyword\">char</span> var4)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">long</span> <span class=\"title\">getLongVolatile</span><span class=\"params\">(Object var1, <span class=\"keyword\">long</span> var2)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title\">putLongVolatile</span><span class=\"params\">(Object var1, <span class=\"keyword\">long</span> var2, <span class=\"keyword\">long</span> var4)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">float</span> <span class=\"title\">getFloatVolatile</span><span class=\"params\">(Object var1, <span class=\"keyword\">long</span> var2)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title\">putFloatVolatile</span><span class=\"params\">(Object var1, <span class=\"keyword\">long</span> var2, <span class=\"keyword\">float</span> var4)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">double</span> <span class=\"title\">getDoubleVolatile</span><span class=\"params\">(Object var1, <span class=\"keyword\">long</span> var2)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title\">putDoubleVolatile</span><span class=\"params\">(Object var1, <span class=\"keyword\">long</span> var2, <span class=\"keyword\">double</span> var4)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title\">putOrderedObject</span><span class=\"params\">(Object var1, <span class=\"keyword\">long</span> var2, Object var4)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title\">putOrderedInt</span><span class=\"params\">(Object var1, <span class=\"keyword\">long</span> var2, <span class=\"keyword\">int</span> var4)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title\">putOrderedLong</span><span class=\"params\">(Object var1, <span class=\"keyword\">long</span> var2, <span class=\"keyword\">long</span> var4)</span></span>;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"park\"><a href=\"#park\" class=\"headerlink\" title=\"park\"></a>park</h1><p>其实主要还是每个线程拥有一个Parker实例<br>调用Unsafe.park的时候，会调用当前线程Parker实例的对应方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title\">unpark</span><span class=\"params\">(Object var1)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title\">park</span><span class=\"params\">(<span class=\"keyword\">boolean</span> var1, <span class=\"keyword\">long</span> var2)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">class Parker : public os::PlatformParker &#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">  <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> _counter ;</span><br><span class=\"line\">  Parker * FreeNext ;</span><br><span class=\"line\">  JavaThread * AssociatedWith ; <span class=\"comment\">// Current association</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  Parker() : PlatformParker() &#123;</span><br><span class=\"line\">    _counter       = <span class=\"number\">0</span> ;</span><br><span class=\"line\">    FreeNext       = NULL ;</span><br><span class=\"line\">    AssociatedWith = NULL ;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">  ~Parker() &#123; ShouldNotReachHere(); &#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"comment\">// For simplicity of interface with Java, all forms of park (indefinite,</span></span><br><span class=\"line\">  <span class=\"comment\">// relative, and absolute) are multiplexed into one call.</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">park</span><span class=\"params\">(bool isAbsolute, jlong time)</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">unpark</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Lifecycle operators</span></span><br><span class=\"line\">  <span class=\"keyword\">static</span> Parker * Allocate (JavaThread * t) ;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Release</span> <span class=\"params\">(Parker * e)</span> </span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">  <span class=\"keyword\">static</span> Parker * <span class=\"keyword\">volatile</span> FreeList ;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> ListLock ;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> Parker::park(bool isAbsolute, jlong time) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 代表被unpark过</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (Atomic::xchg(<span class=\"number\">0</span>, &amp;_counter) &gt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  Thread* thread = Thread::current();</span><br><span class=\"line\">  <span class=\"keyword\">assert</span>(thread-&gt;is_Java_thread(), <span class=\"string\">\"Must be JavaThread\"</span>);</span><br><span class=\"line\">  JavaThread *jt = (JavaThread *)thread;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (Thread::is_interrupted(thread, <span class=\"keyword\">false</span>)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  timespec absTime;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (time &lt; <span class=\"number\">0</span> || (isAbsolute &amp;&amp; time == <span class=\"number\">0</span>) ) &#123; <span class=\"comment\">// don't wait at all</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (time &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    unpackTime(&amp;absTime, isAbsolute, time);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\">ThreadBlockInVM <span class=\"title\">tbivm</span><span class=\"params\">(jt)</span></span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (Thread::is_interrupted(thread, <span class=\"keyword\">false</span>) || pthread_mutex_trylock(_mutex) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">int</span> status ;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (_counter &gt; <span class=\"number\">0</span>)  &#123; <span class=\"comment\">// no wait needed</span></span><br><span class=\"line\">    _counter = <span class=\"number\">0</span>;</span><br><span class=\"line\">    status = pthread_mutex_unlock(_mutex);</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> (status == <span class=\"number\">0</span>, <span class=\"string\">\"invariant\"</span>) ;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 插入一个完全的屏障</span></span><br><span class=\"line\">    OrderAccess::fence();</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\">OSThreadWaitState <span class=\"title\">osts</span><span class=\"params\">(thread-&gt;osthread()</span>, <span class=\"keyword\">false</span> <span class=\"comment\">/* not Object.wait() */</span>)</span>;</span><br><span class=\"line\">  jt-&gt;set_suspend_equivalent();</span><br><span class=\"line\">  <span class=\"keyword\">assert</span>(_cur_index == -<span class=\"number\">1</span>, <span class=\"string\">\"invariant\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (time == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    _cur_index = REL_INDEX; <span class=\"comment\">// arbitrary choice when not timed</span></span><br><span class=\"line\">    <span class=\"comment\">// 等待被释放，不知道为什么要使用这个不同的信号量</span></span><br><span class=\"line\">    status = pthread_cond_wait (&amp;_cond[_cur_index], _mutex) ;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    _cur_index = isAbsolute ? ABS_INDEX : REL_INDEX;</span><br><span class=\"line\">    <span class=\"comment\">// 等待被释放</span></span><br><span class=\"line\">    status = os::Linux::safe_cond_timedwait (&amp;_cond[_cur_index], _mutex, &amp;absTime) ;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (status != <span class=\"number\">0</span> &amp;&amp; WorkAroundNPTLTimedWaitHang) &#123;</span><br><span class=\"line\">      pthread_cond_destroy (&amp;_cond[_cur_index]) ;</span><br><span class=\"line\">      pthread_cond_init    (&amp;_cond[_cur_index], isAbsolute ? NULL : os::Linux::condAttr());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  _cur_index = -<span class=\"number\">1</span>;</span><br><span class=\"line\">  assert_status(status == <span class=\"number\">0</span> || status == EINTR ||</span><br><span class=\"line\">                status == ETIME || status == ETIMEDOUT,</span><br><span class=\"line\">                status, <span class=\"string\">\"cond_timedwait\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">#ifdef ASSERT</span><br><span class=\"line\">  pthread_sigmask(SIG_SETMASK, &amp;oldsigs, NULL);</span><br><span class=\"line\">#endif</span><br><span class=\"line\"></span><br><span class=\"line\">  _counter = <span class=\"number\">0</span> ;</span><br><span class=\"line\">  status = pthread_mutex_unlock(_mutex) ;</span><br><span class=\"line\">  assert_status(status == <span class=\"number\">0</span>, status, <span class=\"string\">\"invariant\"</span>) ;</span><br><span class=\"line\">  OrderAccess::fence();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (jt-&gt;handle_special_suspend_equivalent_condition()) &#123;</span><br><span class=\"line\">    jt-&gt;java_suspend_self();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> Parker::unpark() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> s, status ;</span><br><span class=\"line\">  status = pthread_mutex_lock(_mutex);</span><br><span class=\"line\">  <span class=\"keyword\">assert</span> (status == <span class=\"number\">0</span>, <span class=\"string\">\"invariant\"</span>) ;</span><br><span class=\"line\">  s = _counter;</span><br><span class=\"line\">  _counter = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (s &lt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// thread might be parked</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_cur_index != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// thread is definitely parked</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (WorkAroundNPTLTimedWaitHang) &#123;</span><br><span class=\"line\">        status = pthread_cond_signal (&amp;_cond[_cur_index]);</span><br><span class=\"line\">        <span class=\"keyword\">assert</span> (status == <span class=\"number\">0</span>, <span class=\"string\">\"invariant\"</span>);</span><br><span class=\"line\">        status = pthread_mutex_unlock(_mutex);</span><br><span class=\"line\">        <span class=\"keyword\">assert</span> (status == <span class=\"number\">0</span>, <span class=\"string\">\"invariant\"</span>);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        status = pthread_mutex_unlock(_mutex);</span><br><span class=\"line\">        <span class=\"keyword\">assert</span> (status == <span class=\"number\">0</span>, <span class=\"string\">\"invariant\"</span>);</span><br><span class=\"line\">        status = pthread_cond_signal (&amp;_cond[_cur_index]);</span><br><span class=\"line\">        <span class=\"keyword\">assert</span> (status == <span class=\"number\">0</span>, <span class=\"string\">\"invariant\"</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      pthread_mutex_unlock(_mutex);</span><br><span class=\"line\">      <span class=\"keyword\">assert</span> (status == <span class=\"number\">0</span>, <span class=\"string\">\"invariant\"</span>) ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    pthread_mutex_unlock(_mutex);</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> (status == <span class=\"number\">0</span>, <span class=\"string\">\"invariant\"</span>) ;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>Unsafe类是一个拥有大量native方法的一个类，里面都是比较底层的接口</p>\n<h1 id=\"get与put\"><a href=\"#get与put\" class=\"headerlink\" title=\"get与put\"></a>get与put</h1><p>主要是操作一个无法访问的属性值。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取类内的属性值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">int</span> <span class=\"title\">getInt</span><span class=\"params\">(Object var1, <span class=\"keyword\">long</span> var2)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 将类偏移量为var2的地方值设置为var4</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title\">putInt</span><span class=\"params\">(Object var1, <span class=\"keyword\">long</span> var2, <span class=\"keyword\">int</span> var4)</span></span>;</span><br></pre></td></tr></table></figure></p>","more":"<h1 id=\"memory\"><a href=\"#memory\" class=\"headerlink\" title=\"memory\"></a>memory</h1><p>主要是对直接内存的操作，被<code>DirectByteBuffer</code>调用<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 分配内存</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">long</span> <span class=\"title\">allocateMemory</span><span class=\"params\">(<span class=\"keyword\">long</span> var1)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 在原地址var1重新分配大小为var3的内存</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">long</span> <span class=\"title\">reallocateMemory</span><span class=\"params\">(<span class=\"keyword\">long</span> var1, <span class=\"keyword\">long</span> var3)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 在var1对象的var2地址的长度为var4的一块内存的值初始化为var6</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title\">setMemory</span><span class=\"params\">(Object var1, <span class=\"keyword\">long</span> var2, <span class=\"keyword\">long</span> var4, <span class=\"keyword\">byte</span> var6)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setMemory</span><span class=\"params\">(<span class=\"keyword\">long</span> var1, <span class=\"keyword\">long</span> var3, <span class=\"keyword\">byte</span> var5)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setMemory((Object)<span class=\"keyword\">null</span>, var1, var3, var5);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 复制内存</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title\">copyMemory</span><span class=\"params\">(Object var1, <span class=\"keyword\">long</span> var2, Object var4, <span class=\"keyword\">long</span> var5, <span class=\"keyword\">long</span> var7)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">copyMemory</span><span class=\"params\">(<span class=\"keyword\">long</span> var1, <span class=\"keyword\">long</span> var3, <span class=\"keyword\">long</span> var5)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.copyMemory((Object)<span class=\"keyword\">null</span>, var1, (Object)<span class=\"keyword\">null</span>, var3, var5);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 释放内存</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title\">freeMemory</span><span class=\"params\">(<span class=\"keyword\">long</span> var1)</span></span>;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"offset\"><a href=\"#offset\" class=\"headerlink\" title=\"offset\"></a>offset</h1><p>获取了offset主要是为了cas操作<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 用于获取各个不同类型属性的偏移量</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">long</span> <span class=\"title\">staticFieldOffset</span><span class=\"params\">(Field var1)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">long</span> <span class=\"title\">objectFieldOffset</span><span class=\"params\">(Field var1)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> Object <span class=\"title\">staticFieldBase</span><span class=\"params\">(Field var1)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">int</span> <span class=\"title\">arrayBaseOffset</span><span class=\"params\">(Class&lt;?&gt; var1)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">int</span> <span class=\"title\">arrayIndexScale</span><span class=\"params\">(Class&lt;?&gt; var1)</span></span>;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"CAS\"><a href=\"#CAS\" class=\"headerlink\" title=\"CAS\"></a>CAS</h1><p>主要是为了无锁数据结构使用，以及atomic类使用，实现调用了处理器的<strong>lock，cmpxchg指令</strong>。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 第二个参数是偏移量</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">native</span> <span class=\"keyword\">boolean</span> <span class=\"title\">compareAndSwapObject</span><span class=\"params\">(Object var1, <span class=\"keyword\">long</span> var2, Object var4, Object var5)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">native</span> <span class=\"keyword\">boolean</span> <span class=\"title\">compareAndSwapInt</span><span class=\"params\">(Object var1, <span class=\"keyword\">long</span> var2, <span class=\"keyword\">int</span> var4, <span class=\"keyword\">int</span> var5)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">native</span> <span class=\"keyword\">boolean</span> <span class=\"title\">compareAndSwapLong</span><span class=\"params\">(Object var1, <span class=\"keyword\">long</span> var2, <span class=\"keyword\">long</span> var4, <span class=\"keyword\">long</span> var6)</span></span>;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 用于添加lock指令</span></span><br><span class=\"line\"><span class=\"comment\">// 说一下lock指令，1、确保对内存的读-改-写操作原子执行 2、禁止该指令与前后的读写指令重排序 3、把写缓冲区中的所有数据刷新到内存中</span></span><br><span class=\"line\"><span class=\"comment\">// 在Pentium处理器之前，lock操作之间锁住内存总线的</span></span><br><span class=\"line\"><span class=\"comment\">// 但是在Pentium4处理器之后，intel做了一个优化</span></span><br><span class=\"line\"><span class=\"comment\">// 如果lock后面的指令需要访问的内存已经完整地在一个缓存行之中，则将转为锁住缓存行</span></span><br><span class=\"line\"><span class=\"comment\">// 但是如果不在缓存行之中，则会锁住整个内存总线。</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> LOCK_IF_MP(mp) __asm cmp mp, 0  \\</span></span><br><span class=\"line\">                       __asm je L0      \\</span><br><span class=\"line\">                       __asm _emit <span class=\"number\">0xF0</span> \\</span><br><span class=\"line\">                       __asm L0:</span><br><span class=\"line\"><span class=\"keyword\">inline</span> jint     Atomic::cmpxchg(jint     exchange_value, <span class=\"keyword\">volatile</span> jint*     dest, jint     compare_value) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 判断当前处理器是不是多核处理器</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> mp = os::is_MP();</span><br><span class=\"line\">  __asm &#123;</span><br><span class=\"line\">    mov edx, dest</span><br><span class=\"line\">    mov ecx, exchange_value</span><br><span class=\"line\">    mov eax, compare_value</span><br><span class=\"line\">    <span class=\"comment\">// 将eax与原值作比较，如果相同则将ecx的值，写入edx指向的地址</span></span><br><span class=\"line\">    <span class=\"comment\">// 多核处理器上，指令变成如此，lock cmpxchg dword ptr [edx], ecx </span></span><br><span class=\"line\">    LOCK_IF_MP(mp)</span><br><span class=\"line\">    cmpxchg dword ptr [edx], ecx </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"volatile-ordered\"><a href=\"#volatile-ordered\" class=\"headerlink\" title=\"volatile, ordered\"></a>volatile, ordered</h1><p><strong>putOrderedInt的原理是使用了storeStore屏障（sfence），性能比\bstoreLoad快20%\b，但是不保证立马可见</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> Object <span class=\"title\">getObjectVolatile</span><span class=\"params\">(Object var1, <span class=\"keyword\">long</span> var2)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title\">putObjectVolatile</span><span class=\"params\">(Object var1, <span class=\"keyword\">long</span> var2, Object var4)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">int</span> <span class=\"title\">getIntVolatile</span><span class=\"params\">(Object var1, <span class=\"keyword\">long</span> var2)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title\">putIntVolatile</span><span class=\"params\">(Object var1, <span class=\"keyword\">long</span> var2, <span class=\"keyword\">int</span> var4)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">boolean</span> <span class=\"title\">getBooleanVolatile</span><span class=\"params\">(Object var1, <span class=\"keyword\">long</span> var2)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title\">putBooleanVolatile</span><span class=\"params\">(Object var1, <span class=\"keyword\">long</span> var2, <span class=\"keyword\">boolean</span> var4)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">byte</span> <span class=\"title\">getByteVolatile</span><span class=\"params\">(Object var1, <span class=\"keyword\">long</span> var2)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title\">putByteVolatile</span><span class=\"params\">(Object var1, <span class=\"keyword\">long</span> var2, <span class=\"keyword\">byte</span> var4)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">short</span> <span class=\"title\">getShortVolatile</span><span class=\"params\">(Object var1, <span class=\"keyword\">long</span> var2)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title\">putShortVolatile</span><span class=\"params\">(Object var1, <span class=\"keyword\">long</span> var2, <span class=\"keyword\">short</span> var4)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">char</span> <span class=\"title\">getCharVolatile</span><span class=\"params\">(Object var1, <span class=\"keyword\">long</span> var2)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title\">putCharVolatile</span><span class=\"params\">(Object var1, <span class=\"keyword\">long</span> var2, <span class=\"keyword\">char</span> var4)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">long</span> <span class=\"title\">getLongVolatile</span><span class=\"params\">(Object var1, <span class=\"keyword\">long</span> var2)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title\">putLongVolatile</span><span class=\"params\">(Object var1, <span class=\"keyword\">long</span> var2, <span class=\"keyword\">long</span> var4)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">float</span> <span class=\"title\">getFloatVolatile</span><span class=\"params\">(Object var1, <span class=\"keyword\">long</span> var2)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title\">putFloatVolatile</span><span class=\"params\">(Object var1, <span class=\"keyword\">long</span> var2, <span class=\"keyword\">float</span> var4)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">double</span> <span class=\"title\">getDoubleVolatile</span><span class=\"params\">(Object var1, <span class=\"keyword\">long</span> var2)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title\">putDoubleVolatile</span><span class=\"params\">(Object var1, <span class=\"keyword\">long</span> var2, <span class=\"keyword\">double</span> var4)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title\">putOrderedObject</span><span class=\"params\">(Object var1, <span class=\"keyword\">long</span> var2, Object var4)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title\">putOrderedInt</span><span class=\"params\">(Object var1, <span class=\"keyword\">long</span> var2, <span class=\"keyword\">int</span> var4)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title\">putOrderedLong</span><span class=\"params\">(Object var1, <span class=\"keyword\">long</span> var2, <span class=\"keyword\">long</span> var4)</span></span>;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"park\"><a href=\"#park\" class=\"headerlink\" title=\"park\"></a>park</h1><p>其实主要还是每个线程拥有一个Parker实例<br>调用Unsafe.park的时候，会调用当前线程Parker实例的对应方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title\">unpark</span><span class=\"params\">(Object var1)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title\">park</span><span class=\"params\">(<span class=\"keyword\">boolean</span> var1, <span class=\"keyword\">long</span> var2)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">class Parker : public os::PlatformParker &#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">  <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> _counter ;</span><br><span class=\"line\">  Parker * FreeNext ;</span><br><span class=\"line\">  JavaThread * AssociatedWith ; <span class=\"comment\">// Current association</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  Parker() : PlatformParker() &#123;</span><br><span class=\"line\">    _counter       = <span class=\"number\">0</span> ;</span><br><span class=\"line\">    FreeNext       = NULL ;</span><br><span class=\"line\">    AssociatedWith = NULL ;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">  ~Parker() &#123; ShouldNotReachHere(); &#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"comment\">// For simplicity of interface with Java, all forms of park (indefinite,</span></span><br><span class=\"line\">  <span class=\"comment\">// relative, and absolute) are multiplexed into one call.</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">park</span><span class=\"params\">(bool isAbsolute, jlong time)</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">unpark</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Lifecycle operators</span></span><br><span class=\"line\">  <span class=\"keyword\">static</span> Parker * Allocate (JavaThread * t) ;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Release</span> <span class=\"params\">(Parker * e)</span> </span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">  <span class=\"keyword\">static</span> Parker * <span class=\"keyword\">volatile</span> FreeList ;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> ListLock ;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> Parker::park(bool isAbsolute, jlong time) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 代表被unpark过</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (Atomic::xchg(<span class=\"number\">0</span>, &amp;_counter) &gt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  Thread* thread = Thread::current();</span><br><span class=\"line\">  <span class=\"keyword\">assert</span>(thread-&gt;is_Java_thread(), <span class=\"string\">\"Must be JavaThread\"</span>);</span><br><span class=\"line\">  JavaThread *jt = (JavaThread *)thread;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (Thread::is_interrupted(thread, <span class=\"keyword\">false</span>)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  timespec absTime;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (time &lt; <span class=\"number\">0</span> || (isAbsolute &amp;&amp; time == <span class=\"number\">0</span>) ) &#123; <span class=\"comment\">// don't wait at all</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (time &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    unpackTime(&amp;absTime, isAbsolute, time);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\">ThreadBlockInVM <span class=\"title\">tbivm</span><span class=\"params\">(jt)</span></span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (Thread::is_interrupted(thread, <span class=\"keyword\">false</span>) || pthread_mutex_trylock(_mutex) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">int</span> status ;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (_counter &gt; <span class=\"number\">0</span>)  &#123; <span class=\"comment\">// no wait needed</span></span><br><span class=\"line\">    _counter = <span class=\"number\">0</span>;</span><br><span class=\"line\">    status = pthread_mutex_unlock(_mutex);</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> (status == <span class=\"number\">0</span>, <span class=\"string\">\"invariant\"</span>) ;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 插入一个完全的屏障</span></span><br><span class=\"line\">    OrderAccess::fence();</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\">OSThreadWaitState <span class=\"title\">osts</span><span class=\"params\">(thread-&gt;osthread()</span>, <span class=\"keyword\">false</span> <span class=\"comment\">/* not Object.wait() */</span>)</span>;</span><br><span class=\"line\">  jt-&gt;set_suspend_equivalent();</span><br><span class=\"line\">  <span class=\"keyword\">assert</span>(_cur_index == -<span class=\"number\">1</span>, <span class=\"string\">\"invariant\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (time == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    _cur_index = REL_INDEX; <span class=\"comment\">// arbitrary choice when not timed</span></span><br><span class=\"line\">    <span class=\"comment\">// 等待被释放，不知道为什么要使用这个不同的信号量</span></span><br><span class=\"line\">    status = pthread_cond_wait (&amp;_cond[_cur_index], _mutex) ;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    _cur_index = isAbsolute ? ABS_INDEX : REL_INDEX;</span><br><span class=\"line\">    <span class=\"comment\">// 等待被释放</span></span><br><span class=\"line\">    status = os::Linux::safe_cond_timedwait (&amp;_cond[_cur_index], _mutex, &amp;absTime) ;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (status != <span class=\"number\">0</span> &amp;&amp; WorkAroundNPTLTimedWaitHang) &#123;</span><br><span class=\"line\">      pthread_cond_destroy (&amp;_cond[_cur_index]) ;</span><br><span class=\"line\">      pthread_cond_init    (&amp;_cond[_cur_index], isAbsolute ? NULL : os::Linux::condAttr());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  _cur_index = -<span class=\"number\">1</span>;</span><br><span class=\"line\">  assert_status(status == <span class=\"number\">0</span> || status == EINTR ||</span><br><span class=\"line\">                status == ETIME || status == ETIMEDOUT,</span><br><span class=\"line\">                status, <span class=\"string\">\"cond_timedwait\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">#ifdef ASSERT</span><br><span class=\"line\">  pthread_sigmask(SIG_SETMASK, &amp;oldsigs, NULL);</span><br><span class=\"line\">#endif</span><br><span class=\"line\"></span><br><span class=\"line\">  _counter = <span class=\"number\">0</span> ;</span><br><span class=\"line\">  status = pthread_mutex_unlock(_mutex) ;</span><br><span class=\"line\">  assert_status(status == <span class=\"number\">0</span>, status, <span class=\"string\">\"invariant\"</span>) ;</span><br><span class=\"line\">  OrderAccess::fence();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (jt-&gt;handle_special_suspend_equivalent_condition()) &#123;</span><br><span class=\"line\">    jt-&gt;java_suspend_self();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> Parker::unpark() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> s, status ;</span><br><span class=\"line\">  status = pthread_mutex_lock(_mutex);</span><br><span class=\"line\">  <span class=\"keyword\">assert</span> (status == <span class=\"number\">0</span>, <span class=\"string\">\"invariant\"</span>) ;</span><br><span class=\"line\">  s = _counter;</span><br><span class=\"line\">  _counter = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (s &lt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// thread might be parked</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_cur_index != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// thread is definitely parked</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (WorkAroundNPTLTimedWaitHang) &#123;</span><br><span class=\"line\">        status = pthread_cond_signal (&amp;_cond[_cur_index]);</span><br><span class=\"line\">        <span class=\"keyword\">assert</span> (status == <span class=\"number\">0</span>, <span class=\"string\">\"invariant\"</span>);</span><br><span class=\"line\">        status = pthread_mutex_unlock(_mutex);</span><br><span class=\"line\">        <span class=\"keyword\">assert</span> (status == <span class=\"number\">0</span>, <span class=\"string\">\"invariant\"</span>);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        status = pthread_mutex_unlock(_mutex);</span><br><span class=\"line\">        <span class=\"keyword\">assert</span> (status == <span class=\"number\">0</span>, <span class=\"string\">\"invariant\"</span>);</span><br><span class=\"line\">        status = pthread_cond_signal (&amp;_cond[_cur_index]);</span><br><span class=\"line\">        <span class=\"keyword\">assert</span> (status == <span class=\"number\">0</span>, <span class=\"string\">\"invariant\"</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      pthread_mutex_unlock(_mutex);</span><br><span class=\"line\">      <span class=\"keyword\">assert</span> (status == <span class=\"number\">0</span>, <span class=\"string\">\"invariant\"</span>) ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    pthread_mutex_unlock(_mutex);</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> (status == <span class=\"number\">0</span>, <span class=\"string\">\"invariant\"</span>) ;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>"},{"title":"ThreadPoolExecutor分析","date":"2018-06-23T10:18:15.000Z","toc":true,"_content":"先思考一个问题，为什么需要是使用线程池？\n1. 性能上，创建线程的开销挺大的，时间需要100us，空间也需要在1M左右。\n2. 开发上，有任务需要异步执行，但是不需要在当前线程立刻知道任务的执行结果。\n3. 系统上，系统可以创建的线程数量是比较固定的。\n\n<!-- more -->\n# 注意点\n1. 线程池的任务不一定是顺序执行：\n 当任务提交进去之后，如果当前核心线程池已满，队列已满，最大线程数未满的话，此时的任务会优先执行\n2. 使用线程池的时候，execute需要注意不要抛出异常：\n 抛出异常可能导致线程死亡，需要使用ThreadGroup中的异常处理机器\n\n# 成员属性\n1. `BlockingQueue<Runnable> workQueue`，任务存储的阻塞队列\n2. `ReentrantLock mainLock`，用于控制对worker的操作（创建，删除等等）\n3. `HashSet<Worker> workers`，存储Worker的地方，访问被mainLock保护\n4. `Condition termination`，关闭线程池时，会唤醒这个信号量\n5. `int largestPoolSize`，线程池的线程数量的最大值（没什么用）\n6. `long completedTaskCount`，已经完成的任务的数量\n7. `ThreadFactory threadFactory`，创建线程的工厂\n8. `RejectedExecutionHandler handler`，任务队列满时候的处理策略\n9. `long keepAliveTime`，Worker最大空闲存活时间，\n10. `boolean allowCoreThreadTimeOut`，控制核心线程在空闲时是否关闭\n11. `int corePoolSize`，核心线程数量\n12. `int maximumPoolSize`，最大线程数量（≥largestPoolSize）\n13. `AtomicInteger ctl`，当前线程池的状态，以及线程数量，低29位是线程数量，高3位是状态\n    RUNNING    = -1 << COUNT_BITS(29);\n    SHUTDOWN   =  0 << COUNT_BITS;\n    STOP       =  1 << COUNT_BITS;\n    TIDYING    =  2 << COUNT_BITS;\n    TERMINATED =  3 << COUNT_BITS;\n\n# 主要方法\n## 丢弃策略\n1. Abort，抛出异常，RejectedExecutionException\n2. Discard，直接被丢弃\n3. DiscardOldest，丢弃提交最早的那个\n4. CallerRun，提交者运行\n\n## 线程池状态\n主要过程是RUNNING --> SHUTDOWN --> STOP --> TIDYING --> TERMINATED\n1. RUNNING -> SHUTDOWN\n调用shutdown()\n2. (RUNNING or SHUTDOWN) -> STOP\n调用shutdownNow()\n3. SHUTDOWN -> TIDYING\n线程池和执行队列都空的时候\n4. STOP -> TIDYING\n当队列为空\n5. TIDYING -> TERMINATED\n执行完terminated()方法\n\n## allowsCoreThreadTimeOut\n这个方法是jdk**1.6**之后加的，可以让核心线程永久存活。\n\n## shutdown，shutdownNow，tryTerminate，awaitTermination\n1. shutdown: RUNNING --> SHUTDOWN, **中断所有空闲线程**，但是会等待所有已提交任务执行完成\n2. shutdownNow: RUNNING --> STOP，**中断所有线程**，并且返回未执行的任务\n3. tryTerminate: 尝试设置Terminate状态，\n    如果暂时不需要Terminate的话，则尽快返回。\n    如果所有的队列都已空，并且没有存活线程，则触发信号量。\n4. shutdown, shutwdownNow，都不会等待线程结束的。**awaitTermination才是具体的等待操作**    \n```java\nprivate void interruptWorkers() {\n    final ReentrantLock mainLock = this.mainLock;\n    mainLock.lock();\n    try {\n        for (Worker w : workers)\n            // 主要就是中断线程\n            w.interruptIfStarted();\n    } finally {\n        mainLock.unlock();\n    }\n}\n\npublic void shutdown() {\n    final ReentrantLock mainLock = this.mainLock;\n    mainLock.lock();\n    try {\n        checkShutdownAccess();\n        // 状态更改为SHUTDOWN\n        advanceRunState(SHUTDOWN);\n        // 中断所有空闲的Worker线程\n        interruptIdleWorkers();\n        onShutdown(); // 空方法\n    } finally {\n        mainLock.unlock();\n    }\n    tryTerminate();\n}\n\npublic List<Runnable> shutdownNow() {\n    List<Runnable> tasks;\n    final ReentrantLock mainLock = this.mainLock;\n    mainLock.lock();\n    try {\n        checkShutdownAccess();\n        // 状态更改成STOP\n        advanceRunState(STOP);\n        // 中断所有Worker线程\n        interruptWorkers();\n        // 会把当前正在等待的任务都取出来\n        tasks = drainQueue();\n    } finally {\n        mainLock.unlock();\n    }\n    tryTerminate();\n    return tasks;\n}\n\n// tryTerminate会在很多地方被调用\n// 1. shutdown\n// 2. shutdownNow\n// 3. addWorkerFailed\n// 4. worker执行过程中发生异常\nfinal void tryTerminate() {\n    for (;;) {\n        int c = ctl.get();\n        // 如果正在运行\n        // 不处于TIDYING状态\n        // 处于SHUTDOWN，但是任务队列还有数据\n        if (isRunning(c) ||\n            runStateAtLeast(c, TIDYING) ||\n            (runStateOf(c) == SHUTDOWN && !workQueue.isEmpty()))\n            return;\n        // 只有Worker当中正在执行任务，但是Worker队列中也不存在数据了\n        // 这边采用链式触发的感觉，让Worker逐步一个一个退出\n        if (workerCountOf(c) != 0) { // Eligible to terminate\n            interruptIdleWorkers(ONLY_ONE);\n            return;\n        }\n\n        final ReentrantLock mainLock = this.mainLock;\n        mainLock.lock();\n        try {\n            // 这边只有在状态为STOP的情况下才会进来，或者等到所有任务执行完后\n            if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) {\n                try {\n                    terminated();\n                } finally {\n                    ctl.set(ctlOf(TERMINATED, 0));\n                    termination.signalAll();\n                }\n                return;\n            }\n        } finally {\n            mainLock.unlock();\n        }\n    }\n}\n\n// 很简单的一个操作，等待终止信号量的完成\npublic boolean awaitTermination(long timeout, TimeUnit unit)\n    throws InterruptedException {\n    long nanos = unit.toNanos(timeout);\n    final ReentrantLock mainLock = this.mainLock;\n    mainLock.lock();\n\n    try {\n        for (;;) {\n            if (runStateAtLeast(ctl.get(), TERMINATED))\n                return true;\n            if (nanos <= 0)\n                return false;\n            nanos = termination.awaitNanos(nanos);\n        }\n    } finally {\n        mainLock.unlock();\n    }\n}\n```\n## execute和submit\n两者主要的区别是submit提交的任务都是包装过的，基于FutureTask的封装。\n1. 如果核心线程池未满，则直接新增核心线程，并且执行当前任务\n2. 如果工作队列未满，则添加进入工作队列，并且再次检查需要新增Worker（因为可能有Worker刚执行异常退出了）\n3. 如果工作队列已满，则尝试新增一个Worker去执行当前任务\n4. 如果在添加的过程当中线程池被关闭，则会尝试移除当前任务\n```java\npublic void execute(Runnable command) {\n    if (command == null)\n        throw new NullPointerException();\n        \n    int c = ctl.get();\n    if (workerCountOf(c) < corePoolSize) {\n        if (addWorker(command, true))\n            return;\n        c = ctl.get();\n    }\n    // 工作队列未满\n    if (isRunning(c) && workQueue.offer(command)) {\n        int recheck = ctl.get();\n        // 如果不在运行，则从队列中移除成功。\n        if (! isRunning(recheck) && remove(command))\n            reject(command);\n        // 进入这边代表正在运行，工作队列未满，需要添加新的Worker\n        else if (workerCountOf(recheck) == 0)\n            addWorker(null, false);\n    }\n    // 工作队列已满，则增加线程数量\n    // 如果已经达到最大线程数量，则拒绝当前任务。\n    else if (!addWorker(command, false))\n        reject(command);\n}\n\n// 都是通过FutureTask去封装的\nprotected <T> RunnableFuture<T> newTaskFor(Callable<T> callable) {\n    return new FutureTask<T>(callable);\n}\n\npublic Future<?> submit(Runnable task) {\n    if (task == null) throw new NullPointerException();\n    RunnableFuture<Void> ftask = newTaskFor(task, null);\n    execute(ftask);\n    return ftask;\n}\n\npublic <T> Future<T> submit(Runnable task, T result) {\n    if (task == null) throw new NullPointerException();\n    RunnableFuture<T> ftask = newTaskFor(task, result);\n    execute(ftask);\n    return ftask;\n}\n\npublic <T> Future<T> submit(Callable<T> task) {\n    if (task == null) throw new NullPointerException();\n    RunnableFuture<T> ftask = newTaskFor(task);\n    execute(ftask);\n    return ftask;\n}\n```\n## 构造函数解析\n```java\npublic ThreadPoolExecutor(int corePoolSize,\n                        int maximumPoolSize,\n                        long keepAliveTime,\n                        TimeUnit unit,\n                        BlockingQueue<Runnable> workQueue,\n                        ThreadFactory threadFactory,\n                        RejectedExecutionHandler handler) { \n}\n```\n1. corePoolSize \n  核心线程数量，当任务队列未满时，线程数量一直为corePoolSize\n2. maximumPoolSize\n  最大线程数量，当任务队列已满的时候，线程数量会增加到maximumPoolSize\b\n3. keepAliveTime, unit\n  线程最大空闲等待时间，用于从任务队列中poll任务的参数\n4. workQueue\n  任务队列，任务都是提交到任务队列里面去的。\n5. threadFactory\n  线程工厂，用来创建线程的\n6. handler\n  任务队列已满，线程数量达到最大，任务提交失败的时候执行的handler\n\n## Worker的高可用保障\n1. 通过runWorker内部的trycatch和completedAbruptly来\n```java\nfinal void runWorker(Worker w) {\n    Thread wt = Thread.currentThread();\n    Runnable task = w.firstTask;\n    w.firstTask = null;\n    w.unlock(); // allow interrupts\n    boolean completedAbruptly = true;\n    try {\n        while (task != null || (task = getTask()) != null) {\n            w.lock();\n            // If pool is stopping, ensure thread is interrupted;\n            // if not, ensure thread is not interrupted.  This\n            // requires a recheck in second case to deal with\n            // shutdownNow race while clearing interrupt\n            if ((runStateAtLeast(ctl.get(), STOP) ||\n                    (Thread.interrupted() &&\n                    runStateAtLeast(ctl.get(), STOP))) &&\n                !wt.isInterrupted())\n                wt.interrupt();\n            try {\n                beforeExecute(wt, task);\n                Throwable thrown = null;\n                try {\n                    task.run();\n                } catch (RuntimeException x) {\n                    thrown = x; throw x;\n                } catch (Error x) {\n                    thrown = x; throw x;\n                } catch (Throwable x) {\n                    thrown = x; throw new Error(x);\n                } finally {\n                    afterExecute(task, thrown);\n                }\n            } finally {\n                task = null;\n                w.completedTasks++;\n                w.unlock();\n            }\n        }\n        completedAbruptly = false;\n    } finally {\n        processWorkerExit(w, completedAbruptly);\n    }\n}\n```\n2. 通过ProcessWorkerExit函数来保证Worker不能被非正常的减少\n```java\nprivate void processWorkerExit(Worker w, boolean completedAbruptly) {\n    if (completedAbruptly) // If abrupt, then workerCount wasn't adjusted\n        decrementWorkerCount();\n\n    final ReentrantLock mainLock = this.mainLock;\n    mainLock.lock();\n    try {\n        completedTaskCount += w.completedTasks;\n        workers.remove(w);\n    } finally {\n        mainLock.unlock();\n    }\n\n    tryTerminate();\n\n    int c = ctl.get();\n    if (runStateLessThan(c, STOP)) {\n        if (!completedAbruptly) {\n            int min = allowCoreThreadTimeOut ? 0 : corePoolSize;\n            if (min == 0 && ! workQueue.isEmpty())\n                min = 1;\n            if (workerCountOf(c) >= min)\n                return; // replacement not needed\n        }\n        addWorker(null, false);\n    }\n}\n```\n3. 通过FutureTask内部的try-catch来保证\n```java\npublic void run() {\n    if (state != NEW ||\n        !UNSAFE.compareAndSwapObject(this, runnerOffset,\n                                        null, Thread.currentThread()))\n        return;\n    try {\n        Callable<V> c = callable;\n        if (c != null && state == NEW) {\n            V result;\n            boolean ran;\n            try {\n                result = c.call();\n                ran = true;\n            } catch (Throwable ex) {\n                result = null;\n                ran = false;\n                setException(ex);\n            }\n            if (ran)\n                set(result);\n        }\n    } finally {\n        // runner must be non-null until state is settled to\n        // prevent concurrent calls to run()\n        runner = null;\n        // state must be re-read after nulling runner to prevent\n        // leaked interrupts\n        int s = state;\n        if (s >= INTERRUPTING)\n            handlePossibleCancellationInterrupt(s);\n    }\n}\n```\n\n## Worker\n这个设计有些操蛋。\n```java\nprivate final class Worker extends AbstractQueuedSynchronizer\n    implements Runnable {\n    private static final long serialVersionUID = 6138294804551838833L;\n    final Thread thread;\n    Runnable firstTask;\n    volatile long completedTasks;\n\n    Worker(Runnable firstTask) {\n        setState(-1); \n        this.firstTask = firstTask;\n        this.thread = getThreadFactory().newThread(this);\n    }\n\n    public void run() {\n        runWorker(this);\n    }\n\n    protected boolean isHeldExclusively() {\n        return getState() != 0;\n    }\n\n    protected boolean tryAcquire(int unused) {\n        if (compareAndSetState(0, 1)) {\n            setExclusiveOwnerThread(Thread.currentThread());\n            return true;\n        }\n        return false;\n    }\n\n    protected boolean tryRelease(int unused) {\n        setExclusiveOwnerThread(null);\n        setState(0);\n        return true;\n    }\n\n    public void lock()        { acquire(1); }\n    public boolean tryLock()  { return tryAcquire(1); }\n    public void unlock()      { release(1); }\n    public boolean isLocked() { return isHeldExclusively(); }\n\n    void interruptIfStarted() {\n        Thread t;\n        if (getState() >= 0 && (t = thread) != null && !t.isInterrupted()) {\n            try {\n                t.interrupt();\n            } catch (SecurityException ignore) {\n            }\n        }\n    }\n}\n\nfinal void runWorker(Worker w) {\n    Thread wt = Thread.currentThread();\n    Runnable task = w.firstTask;\n    w.firstTask = null;\n    // 释放1个许可，此时当前线程线程可以被中断\n    // @see Worker构造函数\n    w.unlock();\n    // 代表当前线程是否正常退出\n    // true代表异常\n    boolean completedAbruptly = true;\n\n    try {\n        while (task != null || (task = getTask()) != null) {\n            // 这个就更操蛋了，单线程中自己对自己加锁。\n            // 为什么这么做的原因是防止在执行过程中被其他的线程调用interruptIfStarted()\n            w.lock();\n            // 如果线程池正在推出，保证线程被中断\n            // 否则，消除任何其他中断\n            if ((runStateAtLeast(ctl.get(), STOP) ||\n                    (Thread.interrupted() && runStateAtLeast(ctl.get(), STOP))) && !wt.isInterrupted())\n                wt.interrupt();\n            try {\n                // 回调\n                beforeExecute(wt, task);\n                Throwable thrown = null;\n                try {\n                    task.run();\n                } catch (RuntimeException x) {\n                    thrown = x; throw x;\n                } catch (Error x) {\n                    thrown = x; throw x;\n                } catch (Throwable x) {\n                    thrown = x; throw new Error(x);\n                } finally {\n                    // 回调\n                    afterExecute(task, thrown);\n                }\n            } finally {\n                task = null;\n                w.completedTasks++;\n                w.unlock();\n            }\n        }\n        completedAbruptly = false;\n    } finally {\n        processWorkerExit(w, completedAbruptly);\n    }\n}\n\nprivate void processWorkerExit(Worker w, boolean completedAbruptly) {\n    // 如果异常退出，会重新添加新的线程\n    if (completedAbruptly) // If abrupt, then workerCount wasn't adjusted\n        decrementWorkerCount();\n\n    final ReentrantLock mainLock = this.mainLock;\n    mainLock.lock();\n    try {\n        completedTaskCount += w.completedTasks;\n        workers.remove(w);\n    } finally {\n        mainLock.unlock();\n    }\n\n    tryTerminate();\n\n    int c = ctl.get();\n    // 没有停止\n    if (runStateLessThan(c, STOP)) {\n        // 正常退出\n        if (!completedAbruptly) {\n            // 这段代码又让人看不懂了\n            // 主要意思是：\n            // 如果设置了allowCoreTimeOut，则重新添加新的线程\n            // 如果没有设置，但是队列还有任务，重新添加新线程\n            int min = allowCoreThreadTimeOut ? 0 : corePoolSize;\n            if (min == 0 && ! workQueue.isEmpty())\n                min = 1;\n            if (workerCountOf(c) >= min)\n                return; // replacement not needed\n        }\n        addWorker(null, false);\n    }\n}\n```\n\n## addWorker\n主要是根据不同的情况添加新的线程\n1. 如果当前已经终止，任务队列为空，不添加，不为空添加\n2. 如果当前未终止，但是任务队列为空\n3. 添加时还需要注意是否刚更改Worker计数，然后整个线程池就被Shutdown或者STOP了，需要再次检测\n```java\nprivate boolean addWorker(Runnable firstTask, boolean core) {\n    retry:\n    for (;;) {\n        int c = ctl.get();\n        int rs = runStateOf(c);\n\n        // 当前线程池已经在终止，并且没有需要执行的任务\n        if (rs >= SHUTDOWN &&\n            ! (rs == SHUTDOWN &&\n                firstTask == null &&\n                ! workQueue.isEmpty()))\n            return false;\n\n        for (;;) {\n            int wc = workerCountOf(c);\n            if (wc >= CAPACITY ||\n                wc >= (core ? corePoolSize : maximumPoolSize))\n                return false;\n            if (compareAndIncrementWorkerCount(c))\n                break retry;\n            c = ctl.get();  // Re-read ctl\n            if (runStateOf(c) != rs)\n                continue retry;\n            // else CAS failed due to workerCount change; retry inner loop\n        }\n    }\n\n    boolean workerStarted = false;\n    boolean workerAdded = false;\n    Worker w = null;\n    try {\n        w = new Worker(firstTask);\n        final Thread t = w.thread;\n        if (t != null) {\n            final ReentrantLock mainLock = this.mainLock;\n            mainLock.lock();\n            try {\n                int rs = runStateOf(ctl.get());\n\n                if (rs < SHUTDOWN ||\n                    (rs == SHUTDOWN && firstTask == null)) {\n                    if (t.isAlive()) // precheck that t is startable\n                        throw new IllegalThreadStateException();\n                    workers.add(w);\n                    int s = workers.size();\n                    if (s > largestPoolSize)\n                        largestPoolSize = s;\n                    workerAdded = true;\n                }\n            } finally {\n                mainLock.unlock();\n            }\n            if (workerAdded) {\n                t.start();\n                workerStarted = true;\n            }\n        }\n    } finally {\n        if (! workerStarted)\n            addWorkerFailed(w);\n    }\n    return workerStarted;\n}\n\n// 线程数可能已满，无法再添加等等\n// 或者添加过程中线程被终止\nprivate void addWorkerFailed(Worker w) {\n    final ReentrantLock mainLock = this.mainLock;\n    mainLock.lock();\n    try {\n        if (w != null)\n            workers.remove(w);\n        decrementWorkerCount();\n        tryTerminate();\n    } finally {\n        mainLock.unlock();\n    }\n}\n```","source":"_posts/ThreadPoolExecutor分析.md","raw":"---\ntitle: ThreadPoolExecutor分析\ndate: 2018-06-23 18:18:15\ntags:\n- java\n- 多线程\n- 源码\ncategories: \n- java\n- 多线程\ntoc: true\n---\n先思考一个问题，为什么需要是使用线程池？\n1. 性能上，创建线程的开销挺大的，时间需要100us，空间也需要在1M左右。\n2. 开发上，有任务需要异步执行，但是不需要在当前线程立刻知道任务的执行结果。\n3. 系统上，系统可以创建的线程数量是比较固定的。\n\n<!-- more -->\n# 注意点\n1. 线程池的任务不一定是顺序执行：\n 当任务提交进去之后，如果当前核心线程池已满，队列已满，最大线程数未满的话，此时的任务会优先执行\n2. 使用线程池的时候，execute需要注意不要抛出异常：\n 抛出异常可能导致线程死亡，需要使用ThreadGroup中的异常处理机器\n\n# 成员属性\n1. `BlockingQueue<Runnable> workQueue`，任务存储的阻塞队列\n2. `ReentrantLock mainLock`，用于控制对worker的操作（创建，删除等等）\n3. `HashSet<Worker> workers`，存储Worker的地方，访问被mainLock保护\n4. `Condition termination`，关闭线程池时，会唤醒这个信号量\n5. `int largestPoolSize`，线程池的线程数量的最大值（没什么用）\n6. `long completedTaskCount`，已经完成的任务的数量\n7. `ThreadFactory threadFactory`，创建线程的工厂\n8. `RejectedExecutionHandler handler`，任务队列满时候的处理策略\n9. `long keepAliveTime`，Worker最大空闲存活时间，\n10. `boolean allowCoreThreadTimeOut`，控制核心线程在空闲时是否关闭\n11. `int corePoolSize`，核心线程数量\n12. `int maximumPoolSize`，最大线程数量（≥largestPoolSize）\n13. `AtomicInteger ctl`，当前线程池的状态，以及线程数量，低29位是线程数量，高3位是状态\n    RUNNING    = -1 << COUNT_BITS(29);\n    SHUTDOWN   =  0 << COUNT_BITS;\n    STOP       =  1 << COUNT_BITS;\n    TIDYING    =  2 << COUNT_BITS;\n    TERMINATED =  3 << COUNT_BITS;\n\n# 主要方法\n## 丢弃策略\n1. Abort，抛出异常，RejectedExecutionException\n2. Discard，直接被丢弃\n3. DiscardOldest，丢弃提交最早的那个\n4. CallerRun，提交者运行\n\n## 线程池状态\n主要过程是RUNNING --> SHUTDOWN --> STOP --> TIDYING --> TERMINATED\n1. RUNNING -> SHUTDOWN\n调用shutdown()\n2. (RUNNING or SHUTDOWN) -> STOP\n调用shutdownNow()\n3. SHUTDOWN -> TIDYING\n线程池和执行队列都空的时候\n4. STOP -> TIDYING\n当队列为空\n5. TIDYING -> TERMINATED\n执行完terminated()方法\n\n## allowsCoreThreadTimeOut\n这个方法是jdk**1.6**之后加的，可以让核心线程永久存活。\n\n## shutdown，shutdownNow，tryTerminate，awaitTermination\n1. shutdown: RUNNING --> SHUTDOWN, **中断所有空闲线程**，但是会等待所有已提交任务执行完成\n2. shutdownNow: RUNNING --> STOP，**中断所有线程**，并且返回未执行的任务\n3. tryTerminate: 尝试设置Terminate状态，\n    如果暂时不需要Terminate的话，则尽快返回。\n    如果所有的队列都已空，并且没有存活线程，则触发信号量。\n4. shutdown, shutwdownNow，都不会等待线程结束的。**awaitTermination才是具体的等待操作**    \n```java\nprivate void interruptWorkers() {\n    final ReentrantLock mainLock = this.mainLock;\n    mainLock.lock();\n    try {\n        for (Worker w : workers)\n            // 主要就是中断线程\n            w.interruptIfStarted();\n    } finally {\n        mainLock.unlock();\n    }\n}\n\npublic void shutdown() {\n    final ReentrantLock mainLock = this.mainLock;\n    mainLock.lock();\n    try {\n        checkShutdownAccess();\n        // 状态更改为SHUTDOWN\n        advanceRunState(SHUTDOWN);\n        // 中断所有空闲的Worker线程\n        interruptIdleWorkers();\n        onShutdown(); // 空方法\n    } finally {\n        mainLock.unlock();\n    }\n    tryTerminate();\n}\n\npublic List<Runnable> shutdownNow() {\n    List<Runnable> tasks;\n    final ReentrantLock mainLock = this.mainLock;\n    mainLock.lock();\n    try {\n        checkShutdownAccess();\n        // 状态更改成STOP\n        advanceRunState(STOP);\n        // 中断所有Worker线程\n        interruptWorkers();\n        // 会把当前正在等待的任务都取出来\n        tasks = drainQueue();\n    } finally {\n        mainLock.unlock();\n    }\n    tryTerminate();\n    return tasks;\n}\n\n// tryTerminate会在很多地方被调用\n// 1. shutdown\n// 2. shutdownNow\n// 3. addWorkerFailed\n// 4. worker执行过程中发生异常\nfinal void tryTerminate() {\n    for (;;) {\n        int c = ctl.get();\n        // 如果正在运行\n        // 不处于TIDYING状态\n        // 处于SHUTDOWN，但是任务队列还有数据\n        if (isRunning(c) ||\n            runStateAtLeast(c, TIDYING) ||\n            (runStateOf(c) == SHUTDOWN && !workQueue.isEmpty()))\n            return;\n        // 只有Worker当中正在执行任务，但是Worker队列中也不存在数据了\n        // 这边采用链式触发的感觉，让Worker逐步一个一个退出\n        if (workerCountOf(c) != 0) { // Eligible to terminate\n            interruptIdleWorkers(ONLY_ONE);\n            return;\n        }\n\n        final ReentrantLock mainLock = this.mainLock;\n        mainLock.lock();\n        try {\n            // 这边只有在状态为STOP的情况下才会进来，或者等到所有任务执行完后\n            if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) {\n                try {\n                    terminated();\n                } finally {\n                    ctl.set(ctlOf(TERMINATED, 0));\n                    termination.signalAll();\n                }\n                return;\n            }\n        } finally {\n            mainLock.unlock();\n        }\n    }\n}\n\n// 很简单的一个操作，等待终止信号量的完成\npublic boolean awaitTermination(long timeout, TimeUnit unit)\n    throws InterruptedException {\n    long nanos = unit.toNanos(timeout);\n    final ReentrantLock mainLock = this.mainLock;\n    mainLock.lock();\n\n    try {\n        for (;;) {\n            if (runStateAtLeast(ctl.get(), TERMINATED))\n                return true;\n            if (nanos <= 0)\n                return false;\n            nanos = termination.awaitNanos(nanos);\n        }\n    } finally {\n        mainLock.unlock();\n    }\n}\n```\n## execute和submit\n两者主要的区别是submit提交的任务都是包装过的，基于FutureTask的封装。\n1. 如果核心线程池未满，则直接新增核心线程，并且执行当前任务\n2. 如果工作队列未满，则添加进入工作队列，并且再次检查需要新增Worker（因为可能有Worker刚执行异常退出了）\n3. 如果工作队列已满，则尝试新增一个Worker去执行当前任务\n4. 如果在添加的过程当中线程池被关闭，则会尝试移除当前任务\n```java\npublic void execute(Runnable command) {\n    if (command == null)\n        throw new NullPointerException();\n        \n    int c = ctl.get();\n    if (workerCountOf(c) < corePoolSize) {\n        if (addWorker(command, true))\n            return;\n        c = ctl.get();\n    }\n    // 工作队列未满\n    if (isRunning(c) && workQueue.offer(command)) {\n        int recheck = ctl.get();\n        // 如果不在运行，则从队列中移除成功。\n        if (! isRunning(recheck) && remove(command))\n            reject(command);\n        // 进入这边代表正在运行，工作队列未满，需要添加新的Worker\n        else if (workerCountOf(recheck) == 0)\n            addWorker(null, false);\n    }\n    // 工作队列已满，则增加线程数量\n    // 如果已经达到最大线程数量，则拒绝当前任务。\n    else if (!addWorker(command, false))\n        reject(command);\n}\n\n// 都是通过FutureTask去封装的\nprotected <T> RunnableFuture<T> newTaskFor(Callable<T> callable) {\n    return new FutureTask<T>(callable);\n}\n\npublic Future<?> submit(Runnable task) {\n    if (task == null) throw new NullPointerException();\n    RunnableFuture<Void> ftask = newTaskFor(task, null);\n    execute(ftask);\n    return ftask;\n}\n\npublic <T> Future<T> submit(Runnable task, T result) {\n    if (task == null) throw new NullPointerException();\n    RunnableFuture<T> ftask = newTaskFor(task, result);\n    execute(ftask);\n    return ftask;\n}\n\npublic <T> Future<T> submit(Callable<T> task) {\n    if (task == null) throw new NullPointerException();\n    RunnableFuture<T> ftask = newTaskFor(task);\n    execute(ftask);\n    return ftask;\n}\n```\n## 构造函数解析\n```java\npublic ThreadPoolExecutor(int corePoolSize,\n                        int maximumPoolSize,\n                        long keepAliveTime,\n                        TimeUnit unit,\n                        BlockingQueue<Runnable> workQueue,\n                        ThreadFactory threadFactory,\n                        RejectedExecutionHandler handler) { \n}\n```\n1. corePoolSize \n  核心线程数量，当任务队列未满时，线程数量一直为corePoolSize\n2. maximumPoolSize\n  最大线程数量，当任务队列已满的时候，线程数量会增加到maximumPoolSize\b\n3. keepAliveTime, unit\n  线程最大空闲等待时间，用于从任务队列中poll任务的参数\n4. workQueue\n  任务队列，任务都是提交到任务队列里面去的。\n5. threadFactory\n  线程工厂，用来创建线程的\n6. handler\n  任务队列已满，线程数量达到最大，任务提交失败的时候执行的handler\n\n## Worker的高可用保障\n1. 通过runWorker内部的trycatch和completedAbruptly来\n```java\nfinal void runWorker(Worker w) {\n    Thread wt = Thread.currentThread();\n    Runnable task = w.firstTask;\n    w.firstTask = null;\n    w.unlock(); // allow interrupts\n    boolean completedAbruptly = true;\n    try {\n        while (task != null || (task = getTask()) != null) {\n            w.lock();\n            // If pool is stopping, ensure thread is interrupted;\n            // if not, ensure thread is not interrupted.  This\n            // requires a recheck in second case to deal with\n            // shutdownNow race while clearing interrupt\n            if ((runStateAtLeast(ctl.get(), STOP) ||\n                    (Thread.interrupted() &&\n                    runStateAtLeast(ctl.get(), STOP))) &&\n                !wt.isInterrupted())\n                wt.interrupt();\n            try {\n                beforeExecute(wt, task);\n                Throwable thrown = null;\n                try {\n                    task.run();\n                } catch (RuntimeException x) {\n                    thrown = x; throw x;\n                } catch (Error x) {\n                    thrown = x; throw x;\n                } catch (Throwable x) {\n                    thrown = x; throw new Error(x);\n                } finally {\n                    afterExecute(task, thrown);\n                }\n            } finally {\n                task = null;\n                w.completedTasks++;\n                w.unlock();\n            }\n        }\n        completedAbruptly = false;\n    } finally {\n        processWorkerExit(w, completedAbruptly);\n    }\n}\n```\n2. 通过ProcessWorkerExit函数来保证Worker不能被非正常的减少\n```java\nprivate void processWorkerExit(Worker w, boolean completedAbruptly) {\n    if (completedAbruptly) // If abrupt, then workerCount wasn't adjusted\n        decrementWorkerCount();\n\n    final ReentrantLock mainLock = this.mainLock;\n    mainLock.lock();\n    try {\n        completedTaskCount += w.completedTasks;\n        workers.remove(w);\n    } finally {\n        mainLock.unlock();\n    }\n\n    tryTerminate();\n\n    int c = ctl.get();\n    if (runStateLessThan(c, STOP)) {\n        if (!completedAbruptly) {\n            int min = allowCoreThreadTimeOut ? 0 : corePoolSize;\n            if (min == 0 && ! workQueue.isEmpty())\n                min = 1;\n            if (workerCountOf(c) >= min)\n                return; // replacement not needed\n        }\n        addWorker(null, false);\n    }\n}\n```\n3. 通过FutureTask内部的try-catch来保证\n```java\npublic void run() {\n    if (state != NEW ||\n        !UNSAFE.compareAndSwapObject(this, runnerOffset,\n                                        null, Thread.currentThread()))\n        return;\n    try {\n        Callable<V> c = callable;\n        if (c != null && state == NEW) {\n            V result;\n            boolean ran;\n            try {\n                result = c.call();\n                ran = true;\n            } catch (Throwable ex) {\n                result = null;\n                ran = false;\n                setException(ex);\n            }\n            if (ran)\n                set(result);\n        }\n    } finally {\n        // runner must be non-null until state is settled to\n        // prevent concurrent calls to run()\n        runner = null;\n        // state must be re-read after nulling runner to prevent\n        // leaked interrupts\n        int s = state;\n        if (s >= INTERRUPTING)\n            handlePossibleCancellationInterrupt(s);\n    }\n}\n```\n\n## Worker\n这个设计有些操蛋。\n```java\nprivate final class Worker extends AbstractQueuedSynchronizer\n    implements Runnable {\n    private static final long serialVersionUID = 6138294804551838833L;\n    final Thread thread;\n    Runnable firstTask;\n    volatile long completedTasks;\n\n    Worker(Runnable firstTask) {\n        setState(-1); \n        this.firstTask = firstTask;\n        this.thread = getThreadFactory().newThread(this);\n    }\n\n    public void run() {\n        runWorker(this);\n    }\n\n    protected boolean isHeldExclusively() {\n        return getState() != 0;\n    }\n\n    protected boolean tryAcquire(int unused) {\n        if (compareAndSetState(0, 1)) {\n            setExclusiveOwnerThread(Thread.currentThread());\n            return true;\n        }\n        return false;\n    }\n\n    protected boolean tryRelease(int unused) {\n        setExclusiveOwnerThread(null);\n        setState(0);\n        return true;\n    }\n\n    public void lock()        { acquire(1); }\n    public boolean tryLock()  { return tryAcquire(1); }\n    public void unlock()      { release(1); }\n    public boolean isLocked() { return isHeldExclusively(); }\n\n    void interruptIfStarted() {\n        Thread t;\n        if (getState() >= 0 && (t = thread) != null && !t.isInterrupted()) {\n            try {\n                t.interrupt();\n            } catch (SecurityException ignore) {\n            }\n        }\n    }\n}\n\nfinal void runWorker(Worker w) {\n    Thread wt = Thread.currentThread();\n    Runnable task = w.firstTask;\n    w.firstTask = null;\n    // 释放1个许可，此时当前线程线程可以被中断\n    // @see Worker构造函数\n    w.unlock();\n    // 代表当前线程是否正常退出\n    // true代表异常\n    boolean completedAbruptly = true;\n\n    try {\n        while (task != null || (task = getTask()) != null) {\n            // 这个就更操蛋了，单线程中自己对自己加锁。\n            // 为什么这么做的原因是防止在执行过程中被其他的线程调用interruptIfStarted()\n            w.lock();\n            // 如果线程池正在推出，保证线程被中断\n            // 否则，消除任何其他中断\n            if ((runStateAtLeast(ctl.get(), STOP) ||\n                    (Thread.interrupted() && runStateAtLeast(ctl.get(), STOP))) && !wt.isInterrupted())\n                wt.interrupt();\n            try {\n                // 回调\n                beforeExecute(wt, task);\n                Throwable thrown = null;\n                try {\n                    task.run();\n                } catch (RuntimeException x) {\n                    thrown = x; throw x;\n                } catch (Error x) {\n                    thrown = x; throw x;\n                } catch (Throwable x) {\n                    thrown = x; throw new Error(x);\n                } finally {\n                    // 回调\n                    afterExecute(task, thrown);\n                }\n            } finally {\n                task = null;\n                w.completedTasks++;\n                w.unlock();\n            }\n        }\n        completedAbruptly = false;\n    } finally {\n        processWorkerExit(w, completedAbruptly);\n    }\n}\n\nprivate void processWorkerExit(Worker w, boolean completedAbruptly) {\n    // 如果异常退出，会重新添加新的线程\n    if (completedAbruptly) // If abrupt, then workerCount wasn't adjusted\n        decrementWorkerCount();\n\n    final ReentrantLock mainLock = this.mainLock;\n    mainLock.lock();\n    try {\n        completedTaskCount += w.completedTasks;\n        workers.remove(w);\n    } finally {\n        mainLock.unlock();\n    }\n\n    tryTerminate();\n\n    int c = ctl.get();\n    // 没有停止\n    if (runStateLessThan(c, STOP)) {\n        // 正常退出\n        if (!completedAbruptly) {\n            // 这段代码又让人看不懂了\n            // 主要意思是：\n            // 如果设置了allowCoreTimeOut，则重新添加新的线程\n            // 如果没有设置，但是队列还有任务，重新添加新线程\n            int min = allowCoreThreadTimeOut ? 0 : corePoolSize;\n            if (min == 0 && ! workQueue.isEmpty())\n                min = 1;\n            if (workerCountOf(c) >= min)\n                return; // replacement not needed\n        }\n        addWorker(null, false);\n    }\n}\n```\n\n## addWorker\n主要是根据不同的情况添加新的线程\n1. 如果当前已经终止，任务队列为空，不添加，不为空添加\n2. 如果当前未终止，但是任务队列为空\n3. 添加时还需要注意是否刚更改Worker计数，然后整个线程池就被Shutdown或者STOP了，需要再次检测\n```java\nprivate boolean addWorker(Runnable firstTask, boolean core) {\n    retry:\n    for (;;) {\n        int c = ctl.get();\n        int rs = runStateOf(c);\n\n        // 当前线程池已经在终止，并且没有需要执行的任务\n        if (rs >= SHUTDOWN &&\n            ! (rs == SHUTDOWN &&\n                firstTask == null &&\n                ! workQueue.isEmpty()))\n            return false;\n\n        for (;;) {\n            int wc = workerCountOf(c);\n            if (wc >= CAPACITY ||\n                wc >= (core ? corePoolSize : maximumPoolSize))\n                return false;\n            if (compareAndIncrementWorkerCount(c))\n                break retry;\n            c = ctl.get();  // Re-read ctl\n            if (runStateOf(c) != rs)\n                continue retry;\n            // else CAS failed due to workerCount change; retry inner loop\n        }\n    }\n\n    boolean workerStarted = false;\n    boolean workerAdded = false;\n    Worker w = null;\n    try {\n        w = new Worker(firstTask);\n        final Thread t = w.thread;\n        if (t != null) {\n            final ReentrantLock mainLock = this.mainLock;\n            mainLock.lock();\n            try {\n                int rs = runStateOf(ctl.get());\n\n                if (rs < SHUTDOWN ||\n                    (rs == SHUTDOWN && firstTask == null)) {\n                    if (t.isAlive()) // precheck that t is startable\n                        throw new IllegalThreadStateException();\n                    workers.add(w);\n                    int s = workers.size();\n                    if (s > largestPoolSize)\n                        largestPoolSize = s;\n                    workerAdded = true;\n                }\n            } finally {\n                mainLock.unlock();\n            }\n            if (workerAdded) {\n                t.start();\n                workerStarted = true;\n            }\n        }\n    } finally {\n        if (! workerStarted)\n            addWorkerFailed(w);\n    }\n    return workerStarted;\n}\n\n// 线程数可能已满，无法再添加等等\n// 或者添加过程中线程被终止\nprivate void addWorkerFailed(Worker w) {\n    final ReentrantLock mainLock = this.mainLock;\n    mainLock.lock();\n    try {\n        if (w != null)\n            workers.remove(w);\n        decrementWorkerCount();\n        tryTerminate();\n    } finally {\n        mainLock.unlock();\n    }\n}\n```","slug":"ThreadPoolExecutor分析","published":1,"updated":"2018-06-23T10:59:26.313Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5u1tvf001b1av8ql775z3o","content":"<p>先思考一个问题，为什么需要是使用线程池？</p>\n<ol>\n<li>性能上，创建线程的开销挺大的，时间需要100us，空间也需要在1M左右。</li>\n<li>开发上，有任务需要异步执行，但是不需要在当前线程立刻知道任务的执行结果。</li>\n<li>系统上，系统可以创建的线程数量是比较固定的。</li>\n</ol>\n<a id=\"more\"></a>\n<h1 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h1><ol>\n<li>线程池的任务不一定是顺序执行：<br>当任务提交进去之后，如果当前核心线程池已满，队列已满，最大线程数未满的话，此时的任务会优先执行</li>\n<li>使用线程池的时候，execute需要注意不要抛出异常：<br>抛出异常可能导致线程死亡，需要使用ThreadGroup中的异常处理机器</li>\n</ol>\n<h1 id=\"成员属性\"><a href=\"#成员属性\" class=\"headerlink\" title=\"成员属性\"></a>成员属性</h1><ol>\n<li><code>BlockingQueue&lt;Runnable&gt; workQueue</code>，任务存储的阻塞队列</li>\n<li><code>ReentrantLock mainLock</code>，用于控制对worker的操作（创建，删除等等）</li>\n<li><code>HashSet&lt;Worker&gt; workers</code>，存储Worker的地方，访问被mainLock保护</li>\n<li><code>Condition termination</code>，关闭线程池时，会唤醒这个信号量</li>\n<li><code>int largestPoolSize</code>，线程池的线程数量的最大值（没什么用）</li>\n<li><code>long completedTaskCount</code>，已经完成的任务的数量</li>\n<li><code>ThreadFactory threadFactory</code>，创建线程的工厂</li>\n<li><code>RejectedExecutionHandler handler</code>，任务队列满时候的处理策略</li>\n<li><code>long keepAliveTime</code>，Worker最大空闲存活时间，</li>\n<li><code>boolean allowCoreThreadTimeOut</code>，控制核心线程在空闲时是否关闭</li>\n<li><code>int corePoolSize</code>，核心线程数量</li>\n<li><code>int maximumPoolSize</code>，最大线程数量（≥largestPoolSize）</li>\n<li><code>AtomicInteger ctl</code>，当前线程池的状态，以及线程数量，低29位是线程数量，高3位是状态<br>RUNNING    = -1 &lt;&lt; COUNT_BITS(29);<br>SHUTDOWN   =  0 &lt;&lt; COUNT_BITS;<br>STOP       =  1 &lt;&lt; COUNT_BITS;<br>TIDYING    =  2 &lt;&lt; COUNT_BITS;<br>TERMINATED =  3 &lt;&lt; COUNT_BITS;</li>\n</ol>\n<h1 id=\"主要方法\"><a href=\"#主要方法\" class=\"headerlink\" title=\"主要方法\"></a>主要方法</h1><h2 id=\"丢弃策略\"><a href=\"#丢弃策略\" class=\"headerlink\" title=\"丢弃策略\"></a>丢弃策略</h2><ol>\n<li>Abort，抛出异常，RejectedExecutionException</li>\n<li>Discard，直接被丢弃</li>\n<li>DiscardOldest，丢弃提交最早的那个</li>\n<li>CallerRun，提交者运行</li>\n</ol>\n<h2 id=\"线程池状态\"><a href=\"#线程池状态\" class=\"headerlink\" title=\"线程池状态\"></a>线程池状态</h2><p>主要过程是RUNNING –&gt; SHUTDOWN –&gt; STOP –&gt; TIDYING –&gt; TERMINATED</p>\n<ol>\n<li>RUNNING -&gt; SHUTDOWN<br>调用shutdown()</li>\n<li>(RUNNING or SHUTDOWN) -&gt; STOP<br>调用shutdownNow()</li>\n<li>SHUTDOWN -&gt; TIDYING<br>线程池和执行队列都空的时候</li>\n<li>STOP -&gt; TIDYING<br>当队列为空</li>\n<li>TIDYING -&gt; TERMINATED<br>执行完terminated()方法</li>\n</ol>\n<h2 id=\"allowsCoreThreadTimeOut\"><a href=\"#allowsCoreThreadTimeOut\" class=\"headerlink\" title=\"allowsCoreThreadTimeOut\"></a>allowsCoreThreadTimeOut</h2><p>这个方法是jdk<strong>1.6</strong>之后加的，可以让核心线程永久存活。</p>\n<h2 id=\"shutdown，shutdownNow，tryTerminate，awaitTermination\"><a href=\"#shutdown，shutdownNow，tryTerminate，awaitTermination\" class=\"headerlink\" title=\"shutdown，shutdownNow，tryTerminate，awaitTermination\"></a>shutdown，shutdownNow，tryTerminate，awaitTermination</h2><ol>\n<li>shutdown: RUNNING –&gt; SHUTDOWN, <strong>中断所有空闲线程</strong>，但是会等待所有已提交任务执行完成</li>\n<li>shutdownNow: RUNNING –&gt; STOP，<strong>中断所有线程</strong>，并且返回未执行的任务</li>\n<li>tryTerminate: 尝试设置Terminate状态，<br> 如果暂时不需要Terminate的话，则尽快返回。<br> 如果所有的队列都已空，并且没有存活线程，则触发信号量。</li>\n<li>shutdown, shutwdownNow，都不会等待线程结束的。<strong>awaitTermination才是具体的等待操作</strong>    <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">interruptWorkers</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ReentrantLock mainLock = <span class=\"keyword\">this</span>.mainLock;</span><br><span class=\"line\">    mainLock.lock();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Worker w : workers)</span><br><span class=\"line\">            <span class=\"comment\">// 主要就是中断线程</span></span><br><span class=\"line\">            w.interruptIfStarted();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        mainLock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">shutdown</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ReentrantLock mainLock = <span class=\"keyword\">this</span>.mainLock;</span><br><span class=\"line\">    mainLock.lock();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        checkShutdownAccess();</span><br><span class=\"line\">        <span class=\"comment\">// 状态更改为SHUTDOWN</span></span><br><span class=\"line\">        advanceRunState(SHUTDOWN);</span><br><span class=\"line\">        <span class=\"comment\">// 中断所有空闲的Worker线程</span></span><br><span class=\"line\">        interruptIdleWorkers();</span><br><span class=\"line\">        onShutdown(); <span class=\"comment\">// 空方法</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        mainLock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    tryTerminate();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> List&lt;Runnable&gt; <span class=\"title\">shutdownNow</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    List&lt;Runnable&gt; tasks;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ReentrantLock mainLock = <span class=\"keyword\">this</span>.mainLock;</span><br><span class=\"line\">    mainLock.lock();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        checkShutdownAccess();</span><br><span class=\"line\">        <span class=\"comment\">// 状态更改成STOP</span></span><br><span class=\"line\">        advanceRunState(STOP);</span><br><span class=\"line\">        <span class=\"comment\">// 中断所有Worker线程</span></span><br><span class=\"line\">        interruptWorkers();</span><br><span class=\"line\">        <span class=\"comment\">// 会把当前正在等待的任务都取出来</span></span><br><span class=\"line\">        tasks = drainQueue();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        mainLock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    tryTerminate();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tasks;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// tryTerminate会在很多地方被调用</span></span><br><span class=\"line\"><span class=\"comment\">// 1. shutdown</span></span><br><span class=\"line\"><span class=\"comment\">// 2. shutdownNow</span></span><br><span class=\"line\"><span class=\"comment\">// 3. addWorkerFailed</span></span><br><span class=\"line\"><span class=\"comment\">// 4. worker执行过程中发生异常</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">tryTerminate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> c = ctl.get();</span><br><span class=\"line\">        <span class=\"comment\">// 如果正在运行</span></span><br><span class=\"line\">        <span class=\"comment\">// 不处于TIDYING状态</span></span><br><span class=\"line\">        <span class=\"comment\">// 处于SHUTDOWN，但是任务队列还有数据</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isRunning(c) ||</span><br><span class=\"line\">            runStateAtLeast(c, TIDYING) ||</span><br><span class=\"line\">            (runStateOf(c) == SHUTDOWN &amp;&amp; !workQueue.isEmpty()))</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 只有Worker当中正在执行任务，但是Worker队列中也不存在数据了</span></span><br><span class=\"line\">        <span class=\"comment\">// 这边采用链式触发的感觉，让Worker逐步一个一个退出</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (workerCountOf(c) != <span class=\"number\">0</span>) &#123; <span class=\"comment\">// Eligible to terminate</span></span><br><span class=\"line\">            interruptIdleWorkers(ONLY_ONE);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> ReentrantLock mainLock = <span class=\"keyword\">this</span>.mainLock;</span><br><span class=\"line\">        mainLock.lock();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 这边只有在状态为STOP的情况下才会进来，或者等到所有任务执行完后</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class=\"number\">0</span>))) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    terminated();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    ctl.set(ctlOf(TERMINATED, <span class=\"number\">0</span>));</span><br><span class=\"line\">                    termination.signalAll();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            mainLock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 很简单的一个操作，等待终止信号量的完成</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">awaitTermination</span><span class=\"params\">(<span class=\"keyword\">long</span> timeout, TimeUnit unit)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> nanos = unit.toNanos(timeout);</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ReentrantLock mainLock = <span class=\"keyword\">this</span>.mainLock;</span><br><span class=\"line\">    mainLock.lock();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (runStateAtLeast(ctl.get(), TERMINATED))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nanos &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            nanos = termination.awaitNanos(nanos);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        mainLock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"execute和submit\"><a href=\"#execute和submit\" class=\"headerlink\" title=\"execute和submit\"></a>execute和submit</h2><p>两者主要的区别是submit提交的任务都是包装过的，基于FutureTask的封装。</p>\n<ol>\n<li>如果核心线程池未满，则直接新增核心线程，并且执行当前任务</li>\n<li>如果工作队列未满，则添加进入工作队列，并且再次检查需要新增Worker（因为可能有Worker刚执行异常退出了）</li>\n<li>如果工作队列已满，则尝试新增一个Worker去执行当前任务</li>\n<li>如果在添加的过程当中线程池被关闭，则会尝试移除当前任务<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Runnable command)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (command == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = ctl.get();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (addWorker(command, <span class=\"keyword\">true</span>))</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        c = ctl.get();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 工作队列未满</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> recheck = ctl.get();</span><br><span class=\"line\">        <span class=\"comment\">// 如果不在运行，则从队列中移除成功。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class=\"line\">            reject(command);</span><br><span class=\"line\">        <span class=\"comment\">// 进入这边代表正在运行，工作队列未满，需要添加新的Worker</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (workerCountOf(recheck) == <span class=\"number\">0</span>)</span><br><span class=\"line\">            addWorker(<span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 工作队列已满，则增加线程数量</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果已经达到最大线程数量，则拒绝当前任务。</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!addWorker(command, <span class=\"keyword\">false</span>))</span><br><span class=\"line\">        reject(command);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 都是通过FutureTask去封装的</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> &lt;T&gt; <span class=\"function\">RunnableFuture&lt;T&gt; <span class=\"title\">newTaskFor</span><span class=\"params\">(Callable&lt;T&gt; callable)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> FutureTask&lt;T&gt;(callable);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (task == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    execute(ftask);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ftask;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">Future&lt;T&gt; <span class=\"title\">submit</span><span class=\"params\">(Runnable task, T result)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (task == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);</span><br><span class=\"line\">    execute(ftask);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ftask;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">Future&lt;T&gt; <span class=\"title\">submit</span><span class=\"params\">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (task == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class=\"line\">    execute(ftask);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ftask;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"构造函数解析\"><a href=\"#构造函数解析\" class=\"headerlink\" title=\"构造函数解析\"></a>构造函数解析</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ThreadPoolExecutor</span><span class=\"params\">(<span class=\"keyword\">int</span> corePoolSize,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                        <span class=\"keyword\">int</span> maximumPoolSize,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                        <span class=\"keyword\">long</span> keepAliveTime,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                        TimeUnit unit,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                        BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                        ThreadFactory threadFactory,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                        RejectedExecutionHandler handler)</span> </span>&#123; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>corePoolSize<br>核心线程数量，当任务队列未满时，线程数量一直为corePoolSize</li>\n<li>maximumPoolSize<br>最大线程数量，当任务队列已满的时候，线程数量会增加到maximumPoolSize\b</li>\n<li>keepAliveTime, unit<br>线程最大空闲等待时间，用于从任务队列中poll任务的参数</li>\n<li>workQueue<br>任务队列，任务都是提交到任务队列里面去的。</li>\n<li>threadFactory<br>线程工厂，用来创建线程的</li>\n<li>handler<br>任务队列已满，线程数量达到最大，任务提交失败的时候执行的handler</li>\n</ol>\n<h2 id=\"Worker的高可用保障\"><a href=\"#Worker的高可用保障\" class=\"headerlink\" title=\"Worker的高可用保障\"></a>Worker的高可用保障</h2><ol>\n<li><p>通过runWorker内部的trycatch和completedAbruptly来</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">runWorker</span><span class=\"params\">(Worker w)</span> </span>&#123;</span><br><span class=\"line\">    Thread wt = Thread.currentThread();</span><br><span class=\"line\">    Runnable task = w.firstTask;</span><br><span class=\"line\">    w.firstTask = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    w.unlock(); <span class=\"comment\">// allow interrupts</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> completedAbruptly = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (task != <span class=\"keyword\">null</span> || (task = getTask()) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            w.lock();</span><br><span class=\"line\">            <span class=\"comment\">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class=\"line\">            <span class=\"comment\">// if not, ensure thread is not interrupted.  This</span></span><br><span class=\"line\">            <span class=\"comment\">// requires a recheck in second case to deal with</span></span><br><span class=\"line\">            <span class=\"comment\">// shutdownNow race while clearing interrupt</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class=\"line\">                    (Thread.interrupted() &amp;&amp;</span><br><span class=\"line\">                    runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class=\"line\">                !wt.isInterrupted())</span><br><span class=\"line\">                wt.interrupt();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                beforeExecute(wt, task);</span><br><span class=\"line\">                Throwable thrown = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    task.run();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (RuntimeException x) &#123;</span><br><span class=\"line\">                    thrown = x; <span class=\"keyword\">throw</span> x;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Error x) &#123;</span><br><span class=\"line\">                    thrown = x; <span class=\"keyword\">throw</span> x;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Throwable x) &#123;</span><br><span class=\"line\">                    thrown = x; <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(x);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    afterExecute(task, thrown);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                task = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                w.completedTasks++;</span><br><span class=\"line\">                w.unlock();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        completedAbruptly = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        processWorkerExit(w, completedAbruptly);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>通过ProcessWorkerExit函数来保证Worker不能被非正常的减少</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">processWorkerExit</span><span class=\"params\">(Worker w, <span class=\"keyword\">boolean</span> completedAbruptly)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (completedAbruptly) <span class=\"comment\">// If abrupt, then workerCount wasn't adjusted</span></span><br><span class=\"line\">        decrementWorkerCount();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> ReentrantLock mainLock = <span class=\"keyword\">this</span>.mainLock;</span><br><span class=\"line\">    mainLock.lock();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        completedTaskCount += w.completedTasks;</span><br><span class=\"line\">        workers.remove(w);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        mainLock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    tryTerminate();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = ctl.get();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!completedAbruptly) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> min = allowCoreThreadTimeOut ? <span class=\"number\">0</span> : corePoolSize;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (min == <span class=\"number\">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class=\"line\">                min = <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (workerCountOf(c) &gt;= min)</span><br><span class=\"line\">                <span class=\"keyword\">return</span>; <span class=\"comment\">// replacement not needed</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        addWorker(<span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>通过FutureTask内部的try-catch来保证</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state != NEW ||</span><br><span class=\"line\">        !UNSAFE.compareAndSwapObject(<span class=\"keyword\">this</span>, runnerOffset,</span><br><span class=\"line\">                                        <span class=\"keyword\">null</span>, Thread.currentThread()))</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        Callable&lt;V&gt; c = callable;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (c != <span class=\"keyword\">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class=\"line\">            V result;</span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> ran;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                result = c.call();</span><br><span class=\"line\">                ran = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Throwable ex) &#123;</span><br><span class=\"line\">                result = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                ran = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                setException(ex);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ran)</span><br><span class=\"line\">                set(result);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// runner must be non-null until state is settled to</span></span><br><span class=\"line\">        <span class=\"comment\">// prevent concurrent calls to run()</span></span><br><span class=\"line\">        runner = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"comment\">// state must be re-read after nulling runner to prevent</span></span><br><span class=\"line\">        <span class=\"comment\">// leaked interrupts</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> s = state;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s &gt;= INTERRUPTING)</span><br><span class=\"line\">            handlePossibleCancellationInterrupt(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"Worker\"><a href=\"#Worker\" class=\"headerlink\" title=\"Worker\"></a>Worker</h2><p>这个设计有些操蛋。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Worker</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractQueuedSynchronizer</span></span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">6138294804551838833L</span>;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Thread thread;</span><br><span class=\"line\">    Runnable firstTask;</span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> <span class=\"keyword\">long</span> completedTasks;</span><br><span class=\"line\"></span><br><span class=\"line\">    Worker(Runnable firstTask) &#123;</span><br><span class=\"line\">        setState(-<span class=\"number\">1</span>); </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.firstTask = firstTask;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.thread = getThreadFactory().newThread(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        runWorker(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isHeldExclusively</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getState() != <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> unused)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (compareAndSetState(<span class=\"number\">0</span>, <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryRelease</span><span class=\"params\">(<span class=\"keyword\">int</span> unused)</span> </span>&#123;</span><br><span class=\"line\">        setExclusiveOwnerThread(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">        setState(<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span>        </span>&#123; acquire(<span class=\"number\">1</span>); &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryLock</span><span class=\"params\">()</span>  </span>&#123; <span class=\"keyword\">return</span> tryAcquire(<span class=\"number\">1</span>); &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">unlock</span><span class=\"params\">()</span>      </span>&#123; release(<span class=\"number\">1</span>); &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isLocked</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> isHeldExclusively(); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">interruptIfStarted</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Thread t;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (getState() &gt;= <span class=\"number\">0</span> &amp;&amp; (t = thread) != <span class=\"keyword\">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                t.interrupt();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (SecurityException ignore) &#123;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">runWorker</span><span class=\"params\">(Worker w)</span> </span>&#123;</span><br><span class=\"line\">    Thread wt = Thread.currentThread();</span><br><span class=\"line\">    Runnable task = w.firstTask;</span><br><span class=\"line\">    w.firstTask = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 释放1个许可，此时当前线程线程可以被中断</span></span><br><span class=\"line\">    <span class=\"comment\">// @see Worker构造函数</span></span><br><span class=\"line\">    w.unlock();</span><br><span class=\"line\">    <span class=\"comment\">// 代表当前线程是否正常退出</span></span><br><span class=\"line\">    <span class=\"comment\">// true代表异常</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> completedAbruptly = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (task != <span class=\"keyword\">null</span> || (task = getTask()) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 这个就更操蛋了，单线程中自己对自己加锁。</span></span><br><span class=\"line\">            <span class=\"comment\">// 为什么这么做的原因是防止在执行过程中被其他的线程调用interruptIfStarted()</span></span><br><span class=\"line\">            w.lock();</span><br><span class=\"line\">            <span class=\"comment\">// 如果线程池正在推出，保证线程被中断</span></span><br><span class=\"line\">            <span class=\"comment\">// 否则，消除任何其他中断</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class=\"line\">                    (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted())</span><br><span class=\"line\">                wt.interrupt();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 回调</span></span><br><span class=\"line\">                beforeExecute(wt, task);</span><br><span class=\"line\">                Throwable thrown = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    task.run();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (RuntimeException x) &#123;</span><br><span class=\"line\">                    thrown = x; <span class=\"keyword\">throw</span> x;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Error x) &#123;</span><br><span class=\"line\">                    thrown = x; <span class=\"keyword\">throw</span> x;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Throwable x) &#123;</span><br><span class=\"line\">                    thrown = x; <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(x);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 回调</span></span><br><span class=\"line\">                    afterExecute(task, thrown);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                task = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                w.completedTasks++;</span><br><span class=\"line\">                w.unlock();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        completedAbruptly = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        processWorkerExit(w, completedAbruptly);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">processWorkerExit</span><span class=\"params\">(Worker w, <span class=\"keyword\">boolean</span> completedAbruptly)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果异常退出，会重新添加新的线程</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (completedAbruptly) <span class=\"comment\">// If abrupt, then workerCount wasn't adjusted</span></span><br><span class=\"line\">        decrementWorkerCount();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> ReentrantLock mainLock = <span class=\"keyword\">this</span>.mainLock;</span><br><span class=\"line\">    mainLock.lock();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        completedTaskCount += w.completedTasks;</span><br><span class=\"line\">        workers.remove(w);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        mainLock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    tryTerminate();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = ctl.get();</span><br><span class=\"line\">    <span class=\"comment\">// 没有停止</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 正常退出</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!completedAbruptly) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 这段代码又让人看不懂了</span></span><br><span class=\"line\">            <span class=\"comment\">// 主要意思是：</span></span><br><span class=\"line\">            <span class=\"comment\">// 如果设置了allowCoreTimeOut，则重新添加新的线程</span></span><br><span class=\"line\">            <span class=\"comment\">// 如果没有设置，但是队列还有任务，重新添加新线程</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> min = allowCoreThreadTimeOut ? <span class=\"number\">0</span> : corePoolSize;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (min == <span class=\"number\">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class=\"line\">                min = <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (workerCountOf(c) &gt;= min)</span><br><span class=\"line\">                <span class=\"keyword\">return</span>; <span class=\"comment\">// replacement not needed</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        addWorker(<span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"addWorker\"><a href=\"#addWorker\" class=\"headerlink\" title=\"addWorker\"></a>addWorker</h2><p>主要是根据不同的情况添加新的线程</p>\n<ol>\n<li>如果当前已经终止，任务队列为空，不添加，不为空添加</li>\n<li>如果当前未终止，但是任务队列为空</li>\n<li>添加时还需要注意是否刚更改Worker计数，然后整个线程池就被Shutdown或者STOP了，需要再次检测<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">addWorker</span><span class=\"params\">(Runnable firstTask, <span class=\"keyword\">boolean</span> core)</span> </span>&#123;</span><br><span class=\"line\">    retry:</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> c = ctl.get();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> rs = runStateOf(c);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 当前线程池已经在终止，并且没有需要执行的任务</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class=\"line\">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class=\"line\">                firstTask == <span class=\"keyword\">null</span> &amp;&amp;</span><br><span class=\"line\">                ! workQueue.isEmpty()))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> wc = workerCountOf(c);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (wc &gt;= CAPACITY ||</span><br><span class=\"line\">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class=\"line\">                <span class=\"keyword\">break</span> retry;</span><br><span class=\"line\">            c = ctl.get();  <span class=\"comment\">// Re-read ctl</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (runStateOf(c) != rs)</span><br><span class=\"line\">                <span class=\"keyword\">continue</span> retry;</span><br><span class=\"line\">            <span class=\"comment\">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> workerStarted = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> workerAdded = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    Worker w = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        w = <span class=\"keyword\">new</span> Worker(firstTask);</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Thread t = w.thread;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> ReentrantLock mainLock = <span class=\"keyword\">this</span>.mainLock;</span><br><span class=\"line\">            mainLock.lock();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> rs = runStateOf(ctl.get());</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (rs &lt; SHUTDOWN ||</span><br><span class=\"line\">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class=\"keyword\">null</span>)) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (t.isAlive()) <span class=\"comment\">// precheck that t is startable</span></span><br><span class=\"line\">                        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalThreadStateException();</span><br><span class=\"line\">                    workers.add(w);</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> s = workers.size();</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (s &gt; largestPoolSize)</span><br><span class=\"line\">                        largestPoolSize = s;</span><br><span class=\"line\">                    workerAdded = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                mainLock.unlock();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (workerAdded) &#123;</span><br><span class=\"line\">                t.start();</span><br><span class=\"line\">                workerStarted = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (! workerStarted)</span><br><span class=\"line\">            addWorkerFailed(w);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> workerStarted;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 线程数可能已满，无法再添加等等</span></span><br><span class=\"line\"><span class=\"comment\">// 或者添加过程中线程被终止</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">addWorkerFailed</span><span class=\"params\">(Worker w)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ReentrantLock mainLock = <span class=\"keyword\">this</span>.mainLock;</span><br><span class=\"line\">    mainLock.lock();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (w != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            workers.remove(w);</span><br><span class=\"line\">        decrementWorkerCount();</span><br><span class=\"line\">        tryTerminate();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        mainLock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>先思考一个问题，为什么需要是使用线程池？</p>\n<ol>\n<li>性能上，创建线程的开销挺大的，时间需要100us，空间也需要在1M左右。</li>\n<li>开发上，有任务需要异步执行，但是不需要在当前线程立刻知道任务的执行结果。</li>\n<li>系统上，系统可以创建的线程数量是比较固定的。</li>\n</ol>","more":"<h1 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h1><ol>\n<li>线程池的任务不一定是顺序执行：<br>当任务提交进去之后，如果当前核心线程池已满，队列已满，最大线程数未满的话，此时的任务会优先执行</li>\n<li>使用线程池的时候，execute需要注意不要抛出异常：<br>抛出异常可能导致线程死亡，需要使用ThreadGroup中的异常处理机器</li>\n</ol>\n<h1 id=\"成员属性\"><a href=\"#成员属性\" class=\"headerlink\" title=\"成员属性\"></a>成员属性</h1><ol>\n<li><code>BlockingQueue&lt;Runnable&gt; workQueue</code>，任务存储的阻塞队列</li>\n<li><code>ReentrantLock mainLock</code>，用于控制对worker的操作（创建，删除等等）</li>\n<li><code>HashSet&lt;Worker&gt; workers</code>，存储Worker的地方，访问被mainLock保护</li>\n<li><code>Condition termination</code>，关闭线程池时，会唤醒这个信号量</li>\n<li><code>int largestPoolSize</code>，线程池的线程数量的最大值（没什么用）</li>\n<li><code>long completedTaskCount</code>，已经完成的任务的数量</li>\n<li><code>ThreadFactory threadFactory</code>，创建线程的工厂</li>\n<li><code>RejectedExecutionHandler handler</code>，任务队列满时候的处理策略</li>\n<li><code>long keepAliveTime</code>，Worker最大空闲存活时间，</li>\n<li><code>boolean allowCoreThreadTimeOut</code>，控制核心线程在空闲时是否关闭</li>\n<li><code>int corePoolSize</code>，核心线程数量</li>\n<li><code>int maximumPoolSize</code>，最大线程数量（≥largestPoolSize）</li>\n<li><code>AtomicInteger ctl</code>，当前线程池的状态，以及线程数量，低29位是线程数量，高3位是状态<br>RUNNING    = -1 &lt;&lt; COUNT_BITS(29);<br>SHUTDOWN   =  0 &lt;&lt; COUNT_BITS;<br>STOP       =  1 &lt;&lt; COUNT_BITS;<br>TIDYING    =  2 &lt;&lt; COUNT_BITS;<br>TERMINATED =  3 &lt;&lt; COUNT_BITS;</li>\n</ol>\n<h1 id=\"主要方法\"><a href=\"#主要方法\" class=\"headerlink\" title=\"主要方法\"></a>主要方法</h1><h2 id=\"丢弃策略\"><a href=\"#丢弃策略\" class=\"headerlink\" title=\"丢弃策略\"></a>丢弃策略</h2><ol>\n<li>Abort，抛出异常，RejectedExecutionException</li>\n<li>Discard，直接被丢弃</li>\n<li>DiscardOldest，丢弃提交最早的那个</li>\n<li>CallerRun，提交者运行</li>\n</ol>\n<h2 id=\"线程池状态\"><a href=\"#线程池状态\" class=\"headerlink\" title=\"线程池状态\"></a>线程池状态</h2><p>主要过程是RUNNING –&gt; SHUTDOWN –&gt; STOP –&gt; TIDYING –&gt; TERMINATED</p>\n<ol>\n<li>RUNNING -&gt; SHUTDOWN<br>调用shutdown()</li>\n<li>(RUNNING or SHUTDOWN) -&gt; STOP<br>调用shutdownNow()</li>\n<li>SHUTDOWN -&gt; TIDYING<br>线程池和执行队列都空的时候</li>\n<li>STOP -&gt; TIDYING<br>当队列为空</li>\n<li>TIDYING -&gt; TERMINATED<br>执行完terminated()方法</li>\n</ol>\n<h2 id=\"allowsCoreThreadTimeOut\"><a href=\"#allowsCoreThreadTimeOut\" class=\"headerlink\" title=\"allowsCoreThreadTimeOut\"></a>allowsCoreThreadTimeOut</h2><p>这个方法是jdk<strong>1.6</strong>之后加的，可以让核心线程永久存活。</p>\n<h2 id=\"shutdown，shutdownNow，tryTerminate，awaitTermination\"><a href=\"#shutdown，shutdownNow，tryTerminate，awaitTermination\" class=\"headerlink\" title=\"shutdown，shutdownNow，tryTerminate，awaitTermination\"></a>shutdown，shutdownNow，tryTerminate，awaitTermination</h2><ol>\n<li>shutdown: RUNNING –&gt; SHUTDOWN, <strong>中断所有空闲线程</strong>，但是会等待所有已提交任务执行完成</li>\n<li>shutdownNow: RUNNING –&gt; STOP，<strong>中断所有线程</strong>，并且返回未执行的任务</li>\n<li>tryTerminate: 尝试设置Terminate状态，<br> 如果暂时不需要Terminate的话，则尽快返回。<br> 如果所有的队列都已空，并且没有存活线程，则触发信号量。</li>\n<li>shutdown, shutwdownNow，都不会等待线程结束的。<strong>awaitTermination才是具体的等待操作</strong>    <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">interruptWorkers</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ReentrantLock mainLock = <span class=\"keyword\">this</span>.mainLock;</span><br><span class=\"line\">    mainLock.lock();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Worker w : workers)</span><br><span class=\"line\">            <span class=\"comment\">// 主要就是中断线程</span></span><br><span class=\"line\">            w.interruptIfStarted();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        mainLock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">shutdown</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ReentrantLock mainLock = <span class=\"keyword\">this</span>.mainLock;</span><br><span class=\"line\">    mainLock.lock();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        checkShutdownAccess();</span><br><span class=\"line\">        <span class=\"comment\">// 状态更改为SHUTDOWN</span></span><br><span class=\"line\">        advanceRunState(SHUTDOWN);</span><br><span class=\"line\">        <span class=\"comment\">// 中断所有空闲的Worker线程</span></span><br><span class=\"line\">        interruptIdleWorkers();</span><br><span class=\"line\">        onShutdown(); <span class=\"comment\">// 空方法</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        mainLock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    tryTerminate();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> List&lt;Runnable&gt; <span class=\"title\">shutdownNow</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    List&lt;Runnable&gt; tasks;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ReentrantLock mainLock = <span class=\"keyword\">this</span>.mainLock;</span><br><span class=\"line\">    mainLock.lock();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        checkShutdownAccess();</span><br><span class=\"line\">        <span class=\"comment\">// 状态更改成STOP</span></span><br><span class=\"line\">        advanceRunState(STOP);</span><br><span class=\"line\">        <span class=\"comment\">// 中断所有Worker线程</span></span><br><span class=\"line\">        interruptWorkers();</span><br><span class=\"line\">        <span class=\"comment\">// 会把当前正在等待的任务都取出来</span></span><br><span class=\"line\">        tasks = drainQueue();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        mainLock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    tryTerminate();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tasks;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// tryTerminate会在很多地方被调用</span></span><br><span class=\"line\"><span class=\"comment\">// 1. shutdown</span></span><br><span class=\"line\"><span class=\"comment\">// 2. shutdownNow</span></span><br><span class=\"line\"><span class=\"comment\">// 3. addWorkerFailed</span></span><br><span class=\"line\"><span class=\"comment\">// 4. worker执行过程中发生异常</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">tryTerminate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> c = ctl.get();</span><br><span class=\"line\">        <span class=\"comment\">// 如果正在运行</span></span><br><span class=\"line\">        <span class=\"comment\">// 不处于TIDYING状态</span></span><br><span class=\"line\">        <span class=\"comment\">// 处于SHUTDOWN，但是任务队列还有数据</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isRunning(c) ||</span><br><span class=\"line\">            runStateAtLeast(c, TIDYING) ||</span><br><span class=\"line\">            (runStateOf(c) == SHUTDOWN &amp;&amp; !workQueue.isEmpty()))</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 只有Worker当中正在执行任务，但是Worker队列中也不存在数据了</span></span><br><span class=\"line\">        <span class=\"comment\">// 这边采用链式触发的感觉，让Worker逐步一个一个退出</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (workerCountOf(c) != <span class=\"number\">0</span>) &#123; <span class=\"comment\">// Eligible to terminate</span></span><br><span class=\"line\">            interruptIdleWorkers(ONLY_ONE);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> ReentrantLock mainLock = <span class=\"keyword\">this</span>.mainLock;</span><br><span class=\"line\">        mainLock.lock();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 这边只有在状态为STOP的情况下才会进来，或者等到所有任务执行完后</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class=\"number\">0</span>))) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    terminated();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    ctl.set(ctlOf(TERMINATED, <span class=\"number\">0</span>));</span><br><span class=\"line\">                    termination.signalAll();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            mainLock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 很简单的一个操作，等待终止信号量的完成</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">awaitTermination</span><span class=\"params\">(<span class=\"keyword\">long</span> timeout, TimeUnit unit)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> nanos = unit.toNanos(timeout);</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ReentrantLock mainLock = <span class=\"keyword\">this</span>.mainLock;</span><br><span class=\"line\">    mainLock.lock();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (runStateAtLeast(ctl.get(), TERMINATED))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nanos &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            nanos = termination.awaitNanos(nanos);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        mainLock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"execute和submit\"><a href=\"#execute和submit\" class=\"headerlink\" title=\"execute和submit\"></a>execute和submit</h2><p>两者主要的区别是submit提交的任务都是包装过的，基于FutureTask的封装。</p>\n<ol>\n<li>如果核心线程池未满，则直接新增核心线程，并且执行当前任务</li>\n<li>如果工作队列未满，则添加进入工作队列，并且再次检查需要新增Worker（因为可能有Worker刚执行异常退出了）</li>\n<li>如果工作队列已满，则尝试新增一个Worker去执行当前任务</li>\n<li>如果在添加的过程当中线程池被关闭，则会尝试移除当前任务<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Runnable command)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (command == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = ctl.get();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (addWorker(command, <span class=\"keyword\">true</span>))</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        c = ctl.get();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 工作队列未满</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> recheck = ctl.get();</span><br><span class=\"line\">        <span class=\"comment\">// 如果不在运行，则从队列中移除成功。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class=\"line\">            reject(command);</span><br><span class=\"line\">        <span class=\"comment\">// 进入这边代表正在运行，工作队列未满，需要添加新的Worker</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (workerCountOf(recheck) == <span class=\"number\">0</span>)</span><br><span class=\"line\">            addWorker(<span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 工作队列已满，则增加线程数量</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果已经达到最大线程数量，则拒绝当前任务。</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!addWorker(command, <span class=\"keyword\">false</span>))</span><br><span class=\"line\">        reject(command);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 都是通过FutureTask去封装的</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> &lt;T&gt; <span class=\"function\">RunnableFuture&lt;T&gt; <span class=\"title\">newTaskFor</span><span class=\"params\">(Callable&lt;T&gt; callable)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> FutureTask&lt;T&gt;(callable);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (task == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    execute(ftask);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ftask;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">Future&lt;T&gt; <span class=\"title\">submit</span><span class=\"params\">(Runnable task, T result)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (task == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);</span><br><span class=\"line\">    execute(ftask);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ftask;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">Future&lt;T&gt; <span class=\"title\">submit</span><span class=\"params\">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (task == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class=\"line\">    execute(ftask);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ftask;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"构造函数解析\"><a href=\"#构造函数解析\" class=\"headerlink\" title=\"构造函数解析\"></a>构造函数解析</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ThreadPoolExecutor</span><span class=\"params\">(<span class=\"keyword\">int</span> corePoolSize,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                        <span class=\"keyword\">int</span> maximumPoolSize,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                        <span class=\"keyword\">long</span> keepAliveTime,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                        TimeUnit unit,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                        BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                        ThreadFactory threadFactory,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                        RejectedExecutionHandler handler)</span> </span>&#123; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>corePoolSize<br>核心线程数量，当任务队列未满时，线程数量一直为corePoolSize</li>\n<li>maximumPoolSize<br>最大线程数量，当任务队列已满的时候，线程数量会增加到maximumPoolSize\b</li>\n<li>keepAliveTime, unit<br>线程最大空闲等待时间，用于从任务队列中poll任务的参数</li>\n<li>workQueue<br>任务队列，任务都是提交到任务队列里面去的。</li>\n<li>threadFactory<br>线程工厂，用来创建线程的</li>\n<li>handler<br>任务队列已满，线程数量达到最大，任务提交失败的时候执行的handler</li>\n</ol>\n<h2 id=\"Worker的高可用保障\"><a href=\"#Worker的高可用保障\" class=\"headerlink\" title=\"Worker的高可用保障\"></a>Worker的高可用保障</h2><ol>\n<li><p>通过runWorker内部的trycatch和completedAbruptly来</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">runWorker</span><span class=\"params\">(Worker w)</span> </span>&#123;</span><br><span class=\"line\">    Thread wt = Thread.currentThread();</span><br><span class=\"line\">    Runnable task = w.firstTask;</span><br><span class=\"line\">    w.firstTask = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    w.unlock(); <span class=\"comment\">// allow interrupts</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> completedAbruptly = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (task != <span class=\"keyword\">null</span> || (task = getTask()) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            w.lock();</span><br><span class=\"line\">            <span class=\"comment\">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class=\"line\">            <span class=\"comment\">// if not, ensure thread is not interrupted.  This</span></span><br><span class=\"line\">            <span class=\"comment\">// requires a recheck in second case to deal with</span></span><br><span class=\"line\">            <span class=\"comment\">// shutdownNow race while clearing interrupt</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class=\"line\">                    (Thread.interrupted() &amp;&amp;</span><br><span class=\"line\">                    runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class=\"line\">                !wt.isInterrupted())</span><br><span class=\"line\">                wt.interrupt();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                beforeExecute(wt, task);</span><br><span class=\"line\">                Throwable thrown = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    task.run();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (RuntimeException x) &#123;</span><br><span class=\"line\">                    thrown = x; <span class=\"keyword\">throw</span> x;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Error x) &#123;</span><br><span class=\"line\">                    thrown = x; <span class=\"keyword\">throw</span> x;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Throwable x) &#123;</span><br><span class=\"line\">                    thrown = x; <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(x);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    afterExecute(task, thrown);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                task = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                w.completedTasks++;</span><br><span class=\"line\">                w.unlock();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        completedAbruptly = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        processWorkerExit(w, completedAbruptly);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>通过ProcessWorkerExit函数来保证Worker不能被非正常的减少</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">processWorkerExit</span><span class=\"params\">(Worker w, <span class=\"keyword\">boolean</span> completedAbruptly)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (completedAbruptly) <span class=\"comment\">// If abrupt, then workerCount wasn't adjusted</span></span><br><span class=\"line\">        decrementWorkerCount();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> ReentrantLock mainLock = <span class=\"keyword\">this</span>.mainLock;</span><br><span class=\"line\">    mainLock.lock();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        completedTaskCount += w.completedTasks;</span><br><span class=\"line\">        workers.remove(w);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        mainLock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    tryTerminate();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = ctl.get();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!completedAbruptly) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> min = allowCoreThreadTimeOut ? <span class=\"number\">0</span> : corePoolSize;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (min == <span class=\"number\">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class=\"line\">                min = <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (workerCountOf(c) &gt;= min)</span><br><span class=\"line\">                <span class=\"keyword\">return</span>; <span class=\"comment\">// replacement not needed</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        addWorker(<span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>通过FutureTask内部的try-catch来保证</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state != NEW ||</span><br><span class=\"line\">        !UNSAFE.compareAndSwapObject(<span class=\"keyword\">this</span>, runnerOffset,</span><br><span class=\"line\">                                        <span class=\"keyword\">null</span>, Thread.currentThread()))</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        Callable&lt;V&gt; c = callable;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (c != <span class=\"keyword\">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class=\"line\">            V result;</span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> ran;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                result = c.call();</span><br><span class=\"line\">                ran = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Throwable ex) &#123;</span><br><span class=\"line\">                result = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                ran = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                setException(ex);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ran)</span><br><span class=\"line\">                set(result);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// runner must be non-null until state is settled to</span></span><br><span class=\"line\">        <span class=\"comment\">// prevent concurrent calls to run()</span></span><br><span class=\"line\">        runner = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"comment\">// state must be re-read after nulling runner to prevent</span></span><br><span class=\"line\">        <span class=\"comment\">// leaked interrupts</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> s = state;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s &gt;= INTERRUPTING)</span><br><span class=\"line\">            handlePossibleCancellationInterrupt(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"Worker\"><a href=\"#Worker\" class=\"headerlink\" title=\"Worker\"></a>Worker</h2><p>这个设计有些操蛋。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Worker</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractQueuedSynchronizer</span></span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">6138294804551838833L</span>;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Thread thread;</span><br><span class=\"line\">    Runnable firstTask;</span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> <span class=\"keyword\">long</span> completedTasks;</span><br><span class=\"line\"></span><br><span class=\"line\">    Worker(Runnable firstTask) &#123;</span><br><span class=\"line\">        setState(-<span class=\"number\">1</span>); </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.firstTask = firstTask;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.thread = getThreadFactory().newThread(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        runWorker(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isHeldExclusively</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getState() != <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> unused)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (compareAndSetState(<span class=\"number\">0</span>, <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryRelease</span><span class=\"params\">(<span class=\"keyword\">int</span> unused)</span> </span>&#123;</span><br><span class=\"line\">        setExclusiveOwnerThread(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">        setState(<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span>        </span>&#123; acquire(<span class=\"number\">1</span>); &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryLock</span><span class=\"params\">()</span>  </span>&#123; <span class=\"keyword\">return</span> tryAcquire(<span class=\"number\">1</span>); &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">unlock</span><span class=\"params\">()</span>      </span>&#123; release(<span class=\"number\">1</span>); &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isLocked</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> isHeldExclusively(); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">interruptIfStarted</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Thread t;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (getState() &gt;= <span class=\"number\">0</span> &amp;&amp; (t = thread) != <span class=\"keyword\">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                t.interrupt();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (SecurityException ignore) &#123;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">runWorker</span><span class=\"params\">(Worker w)</span> </span>&#123;</span><br><span class=\"line\">    Thread wt = Thread.currentThread();</span><br><span class=\"line\">    Runnable task = w.firstTask;</span><br><span class=\"line\">    w.firstTask = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 释放1个许可，此时当前线程线程可以被中断</span></span><br><span class=\"line\">    <span class=\"comment\">// @see Worker构造函数</span></span><br><span class=\"line\">    w.unlock();</span><br><span class=\"line\">    <span class=\"comment\">// 代表当前线程是否正常退出</span></span><br><span class=\"line\">    <span class=\"comment\">// true代表异常</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> completedAbruptly = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (task != <span class=\"keyword\">null</span> || (task = getTask()) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 这个就更操蛋了，单线程中自己对自己加锁。</span></span><br><span class=\"line\">            <span class=\"comment\">// 为什么这么做的原因是防止在执行过程中被其他的线程调用interruptIfStarted()</span></span><br><span class=\"line\">            w.lock();</span><br><span class=\"line\">            <span class=\"comment\">// 如果线程池正在推出，保证线程被中断</span></span><br><span class=\"line\">            <span class=\"comment\">// 否则，消除任何其他中断</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class=\"line\">                    (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted())</span><br><span class=\"line\">                wt.interrupt();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 回调</span></span><br><span class=\"line\">                beforeExecute(wt, task);</span><br><span class=\"line\">                Throwable thrown = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    task.run();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (RuntimeException x) &#123;</span><br><span class=\"line\">                    thrown = x; <span class=\"keyword\">throw</span> x;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Error x) &#123;</span><br><span class=\"line\">                    thrown = x; <span class=\"keyword\">throw</span> x;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Throwable x) &#123;</span><br><span class=\"line\">                    thrown = x; <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(x);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 回调</span></span><br><span class=\"line\">                    afterExecute(task, thrown);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                task = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                w.completedTasks++;</span><br><span class=\"line\">                w.unlock();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        completedAbruptly = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        processWorkerExit(w, completedAbruptly);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">processWorkerExit</span><span class=\"params\">(Worker w, <span class=\"keyword\">boolean</span> completedAbruptly)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果异常退出，会重新添加新的线程</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (completedAbruptly) <span class=\"comment\">// If abrupt, then workerCount wasn't adjusted</span></span><br><span class=\"line\">        decrementWorkerCount();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> ReentrantLock mainLock = <span class=\"keyword\">this</span>.mainLock;</span><br><span class=\"line\">    mainLock.lock();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        completedTaskCount += w.completedTasks;</span><br><span class=\"line\">        workers.remove(w);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        mainLock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    tryTerminate();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = ctl.get();</span><br><span class=\"line\">    <span class=\"comment\">// 没有停止</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 正常退出</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!completedAbruptly) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 这段代码又让人看不懂了</span></span><br><span class=\"line\">            <span class=\"comment\">// 主要意思是：</span></span><br><span class=\"line\">            <span class=\"comment\">// 如果设置了allowCoreTimeOut，则重新添加新的线程</span></span><br><span class=\"line\">            <span class=\"comment\">// 如果没有设置，但是队列还有任务，重新添加新线程</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> min = allowCoreThreadTimeOut ? <span class=\"number\">0</span> : corePoolSize;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (min == <span class=\"number\">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class=\"line\">                min = <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (workerCountOf(c) &gt;= min)</span><br><span class=\"line\">                <span class=\"keyword\">return</span>; <span class=\"comment\">// replacement not needed</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        addWorker(<span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"addWorker\"><a href=\"#addWorker\" class=\"headerlink\" title=\"addWorker\"></a>addWorker</h2><p>主要是根据不同的情况添加新的线程</p>\n<ol>\n<li>如果当前已经终止，任务队列为空，不添加，不为空添加</li>\n<li>如果当前未终止，但是任务队列为空</li>\n<li>添加时还需要注意是否刚更改Worker计数，然后整个线程池就被Shutdown或者STOP了，需要再次检测<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">addWorker</span><span class=\"params\">(Runnable firstTask, <span class=\"keyword\">boolean</span> core)</span> </span>&#123;</span><br><span class=\"line\">    retry:</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> c = ctl.get();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> rs = runStateOf(c);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 当前线程池已经在终止，并且没有需要执行的任务</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class=\"line\">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class=\"line\">                firstTask == <span class=\"keyword\">null</span> &amp;&amp;</span><br><span class=\"line\">                ! workQueue.isEmpty()))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> wc = workerCountOf(c);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (wc &gt;= CAPACITY ||</span><br><span class=\"line\">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class=\"line\">                <span class=\"keyword\">break</span> retry;</span><br><span class=\"line\">            c = ctl.get();  <span class=\"comment\">// Re-read ctl</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (runStateOf(c) != rs)</span><br><span class=\"line\">                <span class=\"keyword\">continue</span> retry;</span><br><span class=\"line\">            <span class=\"comment\">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> workerStarted = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> workerAdded = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    Worker w = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        w = <span class=\"keyword\">new</span> Worker(firstTask);</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Thread t = w.thread;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> ReentrantLock mainLock = <span class=\"keyword\">this</span>.mainLock;</span><br><span class=\"line\">            mainLock.lock();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> rs = runStateOf(ctl.get());</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (rs &lt; SHUTDOWN ||</span><br><span class=\"line\">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class=\"keyword\">null</span>)) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (t.isAlive()) <span class=\"comment\">// precheck that t is startable</span></span><br><span class=\"line\">                        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalThreadStateException();</span><br><span class=\"line\">                    workers.add(w);</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> s = workers.size();</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (s &gt; largestPoolSize)</span><br><span class=\"line\">                        largestPoolSize = s;</span><br><span class=\"line\">                    workerAdded = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                mainLock.unlock();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (workerAdded) &#123;</span><br><span class=\"line\">                t.start();</span><br><span class=\"line\">                workerStarted = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (! workerStarted)</span><br><span class=\"line\">            addWorkerFailed(w);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> workerStarted;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 线程数可能已满，无法再添加等等</span></span><br><span class=\"line\"><span class=\"comment\">// 或者添加过程中线程被终止</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">addWorkerFailed</span><span class=\"params\">(Worker w)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ReentrantLock mainLock = <span class=\"keyword\">this</span>.mainLock;</span><br><span class=\"line\">    mainLock.lock();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (w != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            workers.remove(w);</span><br><span class=\"line\">        decrementWorkerCount();</span><br><span class=\"line\">        tryTerminate();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        mainLock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>"},{"title":"gc日志","date":"2018-06-22T11:27:35.000Z","toc":true,"_content":"## cms参数\n-XX:+CMSClassUnloadingEnabled -XX:CMSInitiatingOccupancyFraction=80 -XX:CMSMaxAbortablePrecleanTime=5000 -XX:+ExplicitGCInvokesConcurrent -XX:InitialHeapSize=8589934592 -XX:MaxDirectMemorySize=4294967296 -XX:MaxHeapSize=8589934592 -XX:MaxNewSize=6442450944 -XX:NewSize=6442450944 -XX:OldPLABSize=16 -XX:ParallelGCThreads=4 -XX:+PrintGC -XX:+PrintGCDateStamps -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:SurvivorRatio=4 -XX:+UseCMSCompactAtFullCollection -XX:+UseCMSInitiatingOccupancyOnly -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseConcMarkSweepGC -XX:+UseParNewGC\n<!-- more -->\n\n## cms日志\n```json\n// 正常cms log\n2018-04-23T02:22:54.609+0800: 225411.844: [GC (CMS Initial Mark) [1 CMS-initial-mark: 1815727K(2097152K)] 2426460K(7340032K), 0.1136457 secs] [Times: user=0.38 sys=0.01, real=0.11 secs]\n2018-04-23T02:22:54.723+0800: 225411.958: [CMS-concurrent-mark-start]\n2018-04-23T02:22:55.236+0800: 225412.470: [CMS-concurrent-mark: 0.495/0.512 secs] [Times: user=1.70 sys=0.06, real=0.52 secs]\n2018-04-23T02:22:55.236+0800: 225412.470: [CMS-concurrent-preclean-start]\n2018-04-23T02:22:55.246+0800: 225412.480: [CMS-concurrent-preclean: 0.008/0.009 secs] [Times: user=0.03 sys=0.00, real=0.01 secs]\n2018-04-23T02:22:55.246+0800: 225412.480: [CMS-concurrent-abortable-preclean-start]\n2018-04-23T02:22:55.246+0800: 225412.480: [CMS-concurrent-abortable-preclean: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]\n2018-04-23T02:22:55.248+0800: 225412.483: [GC (CMS Final Remark) [YG occupancy: 923389 K (5242880 K)]2018-04-23T02:22:55.248+0800: 225412.483: [Rescan (parallel) , 0.1816314 secs]2018-04-23T02:22:55.430+0800: 225412.664: [weak refs processing, 0.0096429 secs]2018-04-23T02:22:55.440+0800: 225412.674: [class unloading, 0.1149430 secs]2018-04-23T02:22:55.555+0800: 225412.789: [scrub symbol table, 0.0100393 secs]2018-04-23T02:22:55.565+0800: 225412.799: [scrub string table, 0.0025445 secs][1 CMS-remark: 1815727K(2097152K)] 2739116K(7340032K), 0.3459856 secs] [Times: user=0.87 sys=0.01, real=0.34 secs]\n2018-04-23T02:22:55.611+0800: 225412.845: [CMS-concurrent-sweep-start]\n2018-04-23T02:22:56.039+0800: 225413.274: [CMS-concurrent-sweep: 0.374/0.429 secs] [Times: user=1.50 sys=0.04, real=0.43 secs]\n2018-04-23T02:22:56.040+0800: 225413.274: [CMS-concurrent-reset-start]\n2018-04-23T02:22:56.045+0800: 225413.279: [CMS-concurrent-reset: 0.005/0.005 secs] [Times: user=0.02 sys=0.00, real=0.00 secs]\n```\n# g1日志\n```json\n2018-05-19T14:54:29.930+0800: 181748.799: [GC pause (G1 Evacuation Pause) (young), 0.2280865 secs]\n   [Parallel Time: 206.5 ms, GC Workers: 4]\n      [GC Worker Start (ms): Min: 181748799.6, Avg: 181748799.8, Max: 181748800.2, Diff: 0.6]\n      [Ext Root Scanning (ms): Min: 4.7, Avg: 6.4, Max: 10.4, Diff: 5.7, Sum: 25.7]\n      [Update RS (ms): Min: 92.5, Avg: 95.9, Max: 97.4, Diff: 4.8, Sum: 383.6]\n         [Processed Buffers: Min: 483, Avg: 922.8, Max: 1157, Diff: 674, Sum: 3691]\n      [Scan RS (ms): Min: 0.8, Avg: 0.8, Max: 0.8, Diff: 0.1, Sum: 3.2]\n      [Code Root Scanning (ms): Min: 0.4, Avg: 0.4, Max: 0.4, Diff: 0.0, Sum: 1.6]\n      [Object Copy (ms): Min: 99.5, Avg: 100.2, Max: 101.3, Diff: 1.8, Sum: 401.0]\n      [Termination (ms): Min: 0.0, Avg: 1.6, Max: 2.7, Diff: 2.7, Sum: 6.4]\n         [Termination Attempts: Min: 1, Avg: 1.0, Max: 1, Diff: 0, Sum: 4]\n      [GC Worker Other (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.1]\n      [GC Worker Total (ms): Min: 204.5, Avg: 205.4, Max: 206.3, Diff: 1.9, Sum: 821.8]\n      [GC Worker End (ms): Min: 181749004.7, Avg: 181749005.3, Max: 181749006.0, Diff: 1.3]\n   [Code Root Fixup: 0.5 ms]\n   [Code Root Purge: 0.0 ms]\n   [Clear CT: 0.8 ms]\n   [Other: 20.3 ms]\n      [Choose CSet: 0.0 ms]\n      [Ref Proc: 16.6 ms]\n      [Ref Enq: 0.2 ms]\n      [Redirty Cards: 0.2 ms]\n      [Humongous Register: 0.2 ms]\n      [Humongous Reclaim: 0.6 ms]\n      [Free CSet: 1.7 ms]\n   [Eden: 4836.0M(4836.0M)->0.0B(4768.0M) Survivors: 76.0M->144.0M Heap: 5973.0M(8192.0M)->768.7M(8192.0M)]\n [Times: user=0.69 sys=0.01, real=0.23 secs]\n2018-05-19T14:54:57.248+0800: 181776.117: [GC pause (G1 Evacuation Pause) (young), 0.1199877 secs]\n   [Parallel Time: 104.5 ms, GC Workers: 4]\n      [GC Worker Start (ms): Min: 181776117.1, Avg: 181776117.1, Max: 181776117.2, Diff: 0.1]\n      [Ext Root Scanning (ms): Min: 2.9, Avg: 3.1, Max: 3.2, Diff: 0.3, Sum: 12.3]\n      [Update RS (ms): Min: 42.2, Avg: 42.3, Max: 42.3, Diff: 0.1, Sum: 169.1]\n         [Processed Buffers: Min: 482, Avg: 493.2, Max: 506, Diff: 24, Sum: 1973]\n      [Scan RS (ms): Min: 0.7, Avg: 0.8, Max: 0.9, Diff: 0.2, Sum: 3.3]\n      [Code Root Scanning (ms): Min: 0.4, Avg: 0.4, Max: 0.4, Diff: 0.1, Sum: 1.6]\n      [Object Copy (ms): Min: 57.5, Avg: 57.7, Max: 57.8, Diff: 0.3, Sum: 230.6]\n      [Termination (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]\n         [Termination Attempts: Min: 1, Avg: 1.0, Max: 1, Diff: 0, Sum: 4]\n      [GC Worker Other (ms): Min: 0.1, Avg: 0.1, Max: 0.1, Diff: 0.1, Sum: 0.4]\n      [GC Worker Total (ms): Min: 104.3, Avg: 104.4, Max: 104.4, Diff: 0.1, Sum: 417.4]\n      [GC Worker End (ms): Min: 181776221.5, Avg: 181776221.5, Max: 181776221.5, Diff: 0.1]\n   [Code Root Fixup: 0.5 ms]\n   [Code Root Purge: 0.0 ms]\n   [Clear CT: 0.6 ms]\n   [Other: 14.3 ms]\n      [Choose CSet: 0.0 ms]\n      [Ref Proc: 11.1 ms]\n      [Ref Enq: 0.1 ms]\n      [Redirty Cards: 0.1 ms]\n      [Humongous Register: 0.2 ms]\n      [Humongous Reclaim: 0.3 ms]\n      [Free CSet: 1.7 ms]\n   [Eden: 4768.0M(4768.0M)->0.0B(4820.0M) Survivors: 144.0M->92.0M Heap: 5758.2M(8192.0M)->718.8M(8192.0M)]\n [Times: user=0.42 sys=0.00, real=0.12 secs]\n2018-05-19T14:55:13.434+0800: 181792.302: [GC pause (G1 Evacuation Pause) (young), 0.0821037 secs]\n   [Parallel Time: 69.0 ms, GC Workers: 4]\n      [GC Worker Start (ms): Min: 181792302.8, Avg: 181792302.8, Max: 181792302.9, Diff: 0.1]\n      [Ext Root Scanning (ms): Min: 5.7, Avg: 6.1, Max: 6.5, Diff: 0.7, Sum: 24.6]\n      [Update RS (ms): Min: 26.6, Avg: 26.7, Max: 26.7, Diff: 0.1, Sum: 106.7]\n         [Processed Buffers: Min: 310, Avg: 326.2, Max: 343, Diff: 33, Sum: 1305]\n      [Scan RS (ms): Min: 0.8, Avg: 0.8, Max: 0.8, Diff: 0.1, Sum: 3.1]\n      [Code Root Scanning (ms): Min: 0.4, Avg: 0.4, Max: 0.4, Diff: 0.1, Sum: 1.7]\n      [Object Copy (ms): Min: 34.4, Avg: 34.7, Max: 35.0, Diff: 0.6, Sum: 138.7]\n      [Termination (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]\n         [Termination Attempts: Min: 1, Avg: 1.0, Max: 1, Diff: 0, Sum: 4]\n      [GC Worker Other (ms): Min: 0.1, Avg: 0.1, Max: 0.1, Diff: 0.1, Sum: 0.4]\n      [GC Worker Total (ms): Min: 68.8, Avg: 68.8, Max: 68.8, Diff: 0.0, Sum: 275.1]\n      [GC Worker End (ms): Min: 181792371.6, Avg: 181792371.6, Max: 181792371.6, Diff: 0.1]\n   [Code Root Fixup: 0.5 ms]\n   [Code Root Purge: 0.0 ms]\n   [Clear CT: 0.6 ms]\n   [Other: 12.0 ms]\n      [Choose CSet: 0.0 ms]\n      [Ref Proc: 9.0 ms]\n      [Ref Enq: 0.0 ms]\n      [Redirty Cards: 0.2 ms]\n      [Humongous Register: 0.2 ms]\n      [Humongous Reclaim: 0.2 ms]\n      [Free CSet: 1.6 ms]\n   [Eden: 4820.0M(4820.0M)->0.0B(4852.0M) Survivors: 92.0M->60.0M Heap: 5678.8M(8192.0M)->686.9M(8192.0M)]\n [Times: user=0.28 sys=0.01, real=0.08 secs]\n2018-05-19T14:55:42.260+0800: 181821.129: [GC pause (G1 Evacuation Pause) (young), 0.1619036 secs]\n   [Parallel Time: 141.3 ms, GC Workers: 4]\n      [GC Worker Start (ms): Min: 181821129.4, Avg: 181821129.5, Max: 181821129.5, Diff: 0.1]\n      [Ext Root Scanning (ms): Min: 2.9, Avg: 3.1, Max: 3.3, Diff: 0.4, Sum: 12.6]\n      [Update RS (ms): Min: 41.9, Avg: 41.9, Max: 42.0, Diff: 0.1, Sum: 167.8]\n         [Processed Buffers: Min: 469, Avg: 506.0, Max: 533, Diff: 64, Sum: 2024]\n      [Scan RS (ms): Min: 0.7, Avg: 0.8, Max: 0.8, Diff: 0.1, Sum: 3.2]\n      [Code Root Scanning (ms): Min: 0.4, Avg: 0.4, Max: 0.4, Diff: 0.0, Sum: 1.6]\n      [Object Copy (ms): Min: 94.5, Avg: 94.7, Max: 94.8, Diff: 0.3, Sum: 378.6]\n      [Termination (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]\n         [Termination Attempts: Min: 1, Avg: 1.0, Max: 1, Diff: 0, Sum: 4]\n      [GC Worker Other (ms): Min: 0.0, Avg: 0.1, Max: 0.1, Diff: 0.1, Sum: 0.3]\n      [GC Worker Total (ms): Min: 141.0, Avg: 141.0, Max: 141.1, Diff: 0.1, Sum: 564.1]\n      [GC Worker End (ms): Min: 181821270.4, Avg: 181821270.5, Max: 181821270.5, Diff: 0.1]\n   [Code Root Fixup: 0.5 ms]\n   [Code Root Purge: 0.0 ms]\n   [Clear CT: 0.7 ms]\n   [Other: 19.4 ms]\n      [Choose CSet: 0.0 ms]\n      [Ref Proc: 16.2 ms]\n      [Ref Enq: 0.2 ms]\n      [Redirty Cards: 0.1 ms]\n      [Humongous Register: 0.2 ms]\n      [Humongous Reclaim: 0.3 ms]\n      [Free CSet: 1.6 ms]\n   [Eden: 4852.0M(4852.0M)->0.0B(4756.0M) Survivors: 60.0M->156.0M Heap: 5766.5M(8192.0M)->786.9M(8192.0M)]\n [Times: user=0.57 sys=0.01, real=0.16 secs]\n ```","source":"_posts/gc日志.md","raw":"---\ntitle: gc日志\ndate: 2018-06-22 19:27:35\ntags: \n- jvm \n- gc \n- cms \n- g1\ncategories: \n- java\n- jvm\ntoc: true\n---\n## cms参数\n-XX:+CMSClassUnloadingEnabled -XX:CMSInitiatingOccupancyFraction=80 -XX:CMSMaxAbortablePrecleanTime=5000 -XX:+ExplicitGCInvokesConcurrent -XX:InitialHeapSize=8589934592 -XX:MaxDirectMemorySize=4294967296 -XX:MaxHeapSize=8589934592 -XX:MaxNewSize=6442450944 -XX:NewSize=6442450944 -XX:OldPLABSize=16 -XX:ParallelGCThreads=4 -XX:+PrintGC -XX:+PrintGCDateStamps -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:SurvivorRatio=4 -XX:+UseCMSCompactAtFullCollection -XX:+UseCMSInitiatingOccupancyOnly -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseConcMarkSweepGC -XX:+UseParNewGC\n<!-- more -->\n\n## cms日志\n```json\n// 正常cms log\n2018-04-23T02:22:54.609+0800: 225411.844: [GC (CMS Initial Mark) [1 CMS-initial-mark: 1815727K(2097152K)] 2426460K(7340032K), 0.1136457 secs] [Times: user=0.38 sys=0.01, real=0.11 secs]\n2018-04-23T02:22:54.723+0800: 225411.958: [CMS-concurrent-mark-start]\n2018-04-23T02:22:55.236+0800: 225412.470: [CMS-concurrent-mark: 0.495/0.512 secs] [Times: user=1.70 sys=0.06, real=0.52 secs]\n2018-04-23T02:22:55.236+0800: 225412.470: [CMS-concurrent-preclean-start]\n2018-04-23T02:22:55.246+0800: 225412.480: [CMS-concurrent-preclean: 0.008/0.009 secs] [Times: user=0.03 sys=0.00, real=0.01 secs]\n2018-04-23T02:22:55.246+0800: 225412.480: [CMS-concurrent-abortable-preclean-start]\n2018-04-23T02:22:55.246+0800: 225412.480: [CMS-concurrent-abortable-preclean: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]\n2018-04-23T02:22:55.248+0800: 225412.483: [GC (CMS Final Remark) [YG occupancy: 923389 K (5242880 K)]2018-04-23T02:22:55.248+0800: 225412.483: [Rescan (parallel) , 0.1816314 secs]2018-04-23T02:22:55.430+0800: 225412.664: [weak refs processing, 0.0096429 secs]2018-04-23T02:22:55.440+0800: 225412.674: [class unloading, 0.1149430 secs]2018-04-23T02:22:55.555+0800: 225412.789: [scrub symbol table, 0.0100393 secs]2018-04-23T02:22:55.565+0800: 225412.799: [scrub string table, 0.0025445 secs][1 CMS-remark: 1815727K(2097152K)] 2739116K(7340032K), 0.3459856 secs] [Times: user=0.87 sys=0.01, real=0.34 secs]\n2018-04-23T02:22:55.611+0800: 225412.845: [CMS-concurrent-sweep-start]\n2018-04-23T02:22:56.039+0800: 225413.274: [CMS-concurrent-sweep: 0.374/0.429 secs] [Times: user=1.50 sys=0.04, real=0.43 secs]\n2018-04-23T02:22:56.040+0800: 225413.274: [CMS-concurrent-reset-start]\n2018-04-23T02:22:56.045+0800: 225413.279: [CMS-concurrent-reset: 0.005/0.005 secs] [Times: user=0.02 sys=0.00, real=0.00 secs]\n```\n# g1日志\n```json\n2018-05-19T14:54:29.930+0800: 181748.799: [GC pause (G1 Evacuation Pause) (young), 0.2280865 secs]\n   [Parallel Time: 206.5 ms, GC Workers: 4]\n      [GC Worker Start (ms): Min: 181748799.6, Avg: 181748799.8, Max: 181748800.2, Diff: 0.6]\n      [Ext Root Scanning (ms): Min: 4.7, Avg: 6.4, Max: 10.4, Diff: 5.7, Sum: 25.7]\n      [Update RS (ms): Min: 92.5, Avg: 95.9, Max: 97.4, Diff: 4.8, Sum: 383.6]\n         [Processed Buffers: Min: 483, Avg: 922.8, Max: 1157, Diff: 674, Sum: 3691]\n      [Scan RS (ms): Min: 0.8, Avg: 0.8, Max: 0.8, Diff: 0.1, Sum: 3.2]\n      [Code Root Scanning (ms): Min: 0.4, Avg: 0.4, Max: 0.4, Diff: 0.0, Sum: 1.6]\n      [Object Copy (ms): Min: 99.5, Avg: 100.2, Max: 101.3, Diff: 1.8, Sum: 401.0]\n      [Termination (ms): Min: 0.0, Avg: 1.6, Max: 2.7, Diff: 2.7, Sum: 6.4]\n         [Termination Attempts: Min: 1, Avg: 1.0, Max: 1, Diff: 0, Sum: 4]\n      [GC Worker Other (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.1]\n      [GC Worker Total (ms): Min: 204.5, Avg: 205.4, Max: 206.3, Diff: 1.9, Sum: 821.8]\n      [GC Worker End (ms): Min: 181749004.7, Avg: 181749005.3, Max: 181749006.0, Diff: 1.3]\n   [Code Root Fixup: 0.5 ms]\n   [Code Root Purge: 0.0 ms]\n   [Clear CT: 0.8 ms]\n   [Other: 20.3 ms]\n      [Choose CSet: 0.0 ms]\n      [Ref Proc: 16.6 ms]\n      [Ref Enq: 0.2 ms]\n      [Redirty Cards: 0.2 ms]\n      [Humongous Register: 0.2 ms]\n      [Humongous Reclaim: 0.6 ms]\n      [Free CSet: 1.7 ms]\n   [Eden: 4836.0M(4836.0M)->0.0B(4768.0M) Survivors: 76.0M->144.0M Heap: 5973.0M(8192.0M)->768.7M(8192.0M)]\n [Times: user=0.69 sys=0.01, real=0.23 secs]\n2018-05-19T14:54:57.248+0800: 181776.117: [GC pause (G1 Evacuation Pause) (young), 0.1199877 secs]\n   [Parallel Time: 104.5 ms, GC Workers: 4]\n      [GC Worker Start (ms): Min: 181776117.1, Avg: 181776117.1, Max: 181776117.2, Diff: 0.1]\n      [Ext Root Scanning (ms): Min: 2.9, Avg: 3.1, Max: 3.2, Diff: 0.3, Sum: 12.3]\n      [Update RS (ms): Min: 42.2, Avg: 42.3, Max: 42.3, Diff: 0.1, Sum: 169.1]\n         [Processed Buffers: Min: 482, Avg: 493.2, Max: 506, Diff: 24, Sum: 1973]\n      [Scan RS (ms): Min: 0.7, Avg: 0.8, Max: 0.9, Diff: 0.2, Sum: 3.3]\n      [Code Root Scanning (ms): Min: 0.4, Avg: 0.4, Max: 0.4, Diff: 0.1, Sum: 1.6]\n      [Object Copy (ms): Min: 57.5, Avg: 57.7, Max: 57.8, Diff: 0.3, Sum: 230.6]\n      [Termination (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]\n         [Termination Attempts: Min: 1, Avg: 1.0, Max: 1, Diff: 0, Sum: 4]\n      [GC Worker Other (ms): Min: 0.1, Avg: 0.1, Max: 0.1, Diff: 0.1, Sum: 0.4]\n      [GC Worker Total (ms): Min: 104.3, Avg: 104.4, Max: 104.4, Diff: 0.1, Sum: 417.4]\n      [GC Worker End (ms): Min: 181776221.5, Avg: 181776221.5, Max: 181776221.5, Diff: 0.1]\n   [Code Root Fixup: 0.5 ms]\n   [Code Root Purge: 0.0 ms]\n   [Clear CT: 0.6 ms]\n   [Other: 14.3 ms]\n      [Choose CSet: 0.0 ms]\n      [Ref Proc: 11.1 ms]\n      [Ref Enq: 0.1 ms]\n      [Redirty Cards: 0.1 ms]\n      [Humongous Register: 0.2 ms]\n      [Humongous Reclaim: 0.3 ms]\n      [Free CSet: 1.7 ms]\n   [Eden: 4768.0M(4768.0M)->0.0B(4820.0M) Survivors: 144.0M->92.0M Heap: 5758.2M(8192.0M)->718.8M(8192.0M)]\n [Times: user=0.42 sys=0.00, real=0.12 secs]\n2018-05-19T14:55:13.434+0800: 181792.302: [GC pause (G1 Evacuation Pause) (young), 0.0821037 secs]\n   [Parallel Time: 69.0 ms, GC Workers: 4]\n      [GC Worker Start (ms): Min: 181792302.8, Avg: 181792302.8, Max: 181792302.9, Diff: 0.1]\n      [Ext Root Scanning (ms): Min: 5.7, Avg: 6.1, Max: 6.5, Diff: 0.7, Sum: 24.6]\n      [Update RS (ms): Min: 26.6, Avg: 26.7, Max: 26.7, Diff: 0.1, Sum: 106.7]\n         [Processed Buffers: Min: 310, Avg: 326.2, Max: 343, Diff: 33, Sum: 1305]\n      [Scan RS (ms): Min: 0.8, Avg: 0.8, Max: 0.8, Diff: 0.1, Sum: 3.1]\n      [Code Root Scanning (ms): Min: 0.4, Avg: 0.4, Max: 0.4, Diff: 0.1, Sum: 1.7]\n      [Object Copy (ms): Min: 34.4, Avg: 34.7, Max: 35.0, Diff: 0.6, Sum: 138.7]\n      [Termination (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]\n         [Termination Attempts: Min: 1, Avg: 1.0, Max: 1, Diff: 0, Sum: 4]\n      [GC Worker Other (ms): Min: 0.1, Avg: 0.1, Max: 0.1, Diff: 0.1, Sum: 0.4]\n      [GC Worker Total (ms): Min: 68.8, Avg: 68.8, Max: 68.8, Diff: 0.0, Sum: 275.1]\n      [GC Worker End (ms): Min: 181792371.6, Avg: 181792371.6, Max: 181792371.6, Diff: 0.1]\n   [Code Root Fixup: 0.5 ms]\n   [Code Root Purge: 0.0 ms]\n   [Clear CT: 0.6 ms]\n   [Other: 12.0 ms]\n      [Choose CSet: 0.0 ms]\n      [Ref Proc: 9.0 ms]\n      [Ref Enq: 0.0 ms]\n      [Redirty Cards: 0.2 ms]\n      [Humongous Register: 0.2 ms]\n      [Humongous Reclaim: 0.2 ms]\n      [Free CSet: 1.6 ms]\n   [Eden: 4820.0M(4820.0M)->0.0B(4852.0M) Survivors: 92.0M->60.0M Heap: 5678.8M(8192.0M)->686.9M(8192.0M)]\n [Times: user=0.28 sys=0.01, real=0.08 secs]\n2018-05-19T14:55:42.260+0800: 181821.129: [GC pause (G1 Evacuation Pause) (young), 0.1619036 secs]\n   [Parallel Time: 141.3 ms, GC Workers: 4]\n      [GC Worker Start (ms): Min: 181821129.4, Avg: 181821129.5, Max: 181821129.5, Diff: 0.1]\n      [Ext Root Scanning (ms): Min: 2.9, Avg: 3.1, Max: 3.3, Diff: 0.4, Sum: 12.6]\n      [Update RS (ms): Min: 41.9, Avg: 41.9, Max: 42.0, Diff: 0.1, Sum: 167.8]\n         [Processed Buffers: Min: 469, Avg: 506.0, Max: 533, Diff: 64, Sum: 2024]\n      [Scan RS (ms): Min: 0.7, Avg: 0.8, Max: 0.8, Diff: 0.1, Sum: 3.2]\n      [Code Root Scanning (ms): Min: 0.4, Avg: 0.4, Max: 0.4, Diff: 0.0, Sum: 1.6]\n      [Object Copy (ms): Min: 94.5, Avg: 94.7, Max: 94.8, Diff: 0.3, Sum: 378.6]\n      [Termination (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]\n         [Termination Attempts: Min: 1, Avg: 1.0, Max: 1, Diff: 0, Sum: 4]\n      [GC Worker Other (ms): Min: 0.0, Avg: 0.1, Max: 0.1, Diff: 0.1, Sum: 0.3]\n      [GC Worker Total (ms): Min: 141.0, Avg: 141.0, Max: 141.1, Diff: 0.1, Sum: 564.1]\n      [GC Worker End (ms): Min: 181821270.4, Avg: 181821270.5, Max: 181821270.5, Diff: 0.1]\n   [Code Root Fixup: 0.5 ms]\n   [Code Root Purge: 0.0 ms]\n   [Clear CT: 0.7 ms]\n   [Other: 19.4 ms]\n      [Choose CSet: 0.0 ms]\n      [Ref Proc: 16.2 ms]\n      [Ref Enq: 0.2 ms]\n      [Redirty Cards: 0.1 ms]\n      [Humongous Register: 0.2 ms]\n      [Humongous Reclaim: 0.3 ms]\n      [Free CSet: 1.6 ms]\n   [Eden: 4852.0M(4852.0M)->0.0B(4756.0M) Survivors: 60.0M->156.0M Heap: 5766.5M(8192.0M)->786.9M(8192.0M)]\n [Times: user=0.57 sys=0.01, real=0.16 secs]\n ```","slug":"gc日志","published":1,"updated":"2018-06-23T09:54:44.013Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5u1tvh001e1av88o3v6fb6","content":"<h2 id=\"cms参数\"><a href=\"#cms参数\" class=\"headerlink\" title=\"cms参数\"></a>cms参数</h2><p>-XX:+CMSClassUnloadingEnabled -XX:CMSInitiatingOccupancyFraction=80 -XX:CMSMaxAbortablePrecleanTime=5000 -XX:+ExplicitGCInvokesConcurrent -XX:InitialHeapSize=8589934592 -XX:MaxDirectMemorySize=4294967296 -XX:MaxHeapSize=8589934592 -XX:MaxNewSize=6442450944 -XX:NewSize=6442450944 -XX:OldPLABSize=16 -XX:ParallelGCThreads=4 -XX:+PrintGC -XX:+PrintGCDateStamps -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:SurvivorRatio=4 -XX:+UseCMSCompactAtFullCollection -XX:+UseCMSInitiatingOccupancyOnly -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseConcMarkSweepGC -XX:+UseParNewGC<br><a id=\"more\"></a></p>\n<h2 id=\"cms日志\"><a href=\"#cms日志\" class=\"headerlink\" title=\"cms日志\"></a>cms日志</h2><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 正常cms log</span><br><span class=\"line\">2018-04-23T02:22:54.609+0800: 225411.844: [GC (CMS Initial Mark) [1 CMS-initial-mark: 1815727K(2097152K)] 2426460K(7340032K), 0.1136457 secs] [Times: user=0.38 sys=0.01, real=0.11 secs]</span><br><span class=\"line\">2018-04-23T02:22:54.723+0800: 225411.958: [CMS-concurrent-mark-start]</span><br><span class=\"line\">2018-04-23T02:22:55.236+0800: 225412.470: [CMS-concurrent-mark: 0.495/0.512 secs] [Times: user=1.70 sys=0.06, real=0.52 secs]</span><br><span class=\"line\">2018-04-23T02:22:55.236+0800: 225412.470: [CMS-concurrent-preclean-start]</span><br><span class=\"line\">2018-04-23T02:22:55.246+0800: 225412.480: [CMS-concurrent-preclean: 0.008/0.009 secs] [Times: user=0.03 sys=0.00, real=0.01 secs]</span><br><span class=\"line\">2018-04-23T02:22:55.246+0800: 225412.480: [CMS-concurrent-abortable-preclean-start]</span><br><span class=\"line\">2018-04-23T02:22:55.246+0800: 225412.480: [CMS-concurrent-abortable-preclean: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</span><br><span class=\"line\">2018-04-23T02:22:55.248+0800: 225412.483: [GC (CMS Final Remark) [YG occupancy: 923389 K (5242880 K)]2018-04-23T02:22:55.248+0800: 225412.483: [Rescan (parallel) , 0.1816314 secs]2018-04-23T02:22:55.430+0800: 225412.664: [weak refs processing, 0.0096429 secs]2018-04-23T02:22:55.440+0800: 225412.674: [class unloading, 0.1149430 secs]2018-04-23T02:22:55.555+0800: 225412.789: [scrub symbol table, 0.0100393 secs]2018-04-23T02:22:55.565+0800: 225412.799: [scrub string table, 0.0025445 secs][1 CMS-remark: 1815727K(2097152K)] 2739116K(7340032K), 0.3459856 secs] [Times: user=0.87 sys=0.01, real=0.34 secs]</span><br><span class=\"line\">2018-04-23T02:22:55.611+0800: 225412.845: [CMS-concurrent-sweep-start]</span><br><span class=\"line\">2018-04-23T02:22:56.039+0800: 225413.274: [CMS-concurrent-sweep: 0.374/0.429 secs] [Times: user=1.50 sys=0.04, real=0.43 secs]</span><br><span class=\"line\">2018-04-23T02:22:56.040+0800: 225413.274: [CMS-concurrent-reset-start]</span><br><span class=\"line\">2018-04-23T02:22:56.045+0800: 225413.279: [CMS-concurrent-reset: 0.005/0.005 secs] [Times: user=0.02 sys=0.00, real=0.00 secs]</span><br></pre></td></tr></table></figure>\n<h1 id=\"g1日志\"><a href=\"#g1日志\" class=\"headerlink\" title=\"g1日志\"></a>g1日志</h1><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2018-05-19T14:54:29.930+0800: 181748.799: [GC pause (G1 Evacuation Pause) (young), 0.2280865 secs]</span><br><span class=\"line\">   [Parallel Time: <span class=\"number\">206.5</span> ms, GC Workers: <span class=\"number\">4</span>]</span><br><span class=\"line\">      [GC Worker Start (ms): Min: <span class=\"number\">181748799.6</span>, Avg: <span class=\"number\">181748799.8</span>, Max: <span class=\"number\">181748800.2</span>, Diff: <span class=\"number\">0.6</span>]</span><br><span class=\"line\">      [Ext Root Scanning (ms): Min: <span class=\"number\">4.7</span>, Avg: <span class=\"number\">6.4</span>, Max: <span class=\"number\">10.4</span>, Diff: <span class=\"number\">5.7</span>, Sum: <span class=\"number\">25.7</span>]</span><br><span class=\"line\">      [Update RS (ms): Min: <span class=\"number\">92.5</span>, Avg: <span class=\"number\">95.9</span>, Max: <span class=\"number\">97.4</span>, Diff: <span class=\"number\">4.8</span>, Sum: <span class=\"number\">383.6</span>]</span><br><span class=\"line\">         [Processed Buffers: Min: <span class=\"number\">483</span>, Avg: <span class=\"number\">922.8</span>, Max: <span class=\"number\">1157</span>, Diff: <span class=\"number\">674</span>, Sum: <span class=\"number\">3691</span>]</span><br><span class=\"line\">      [Scan RS (ms): Min: <span class=\"number\">0.8</span>, Avg: <span class=\"number\">0.8</span>, Max: <span class=\"number\">0.8</span>, Diff: <span class=\"number\">0.1</span>, Sum: <span class=\"number\">3.2</span>]</span><br><span class=\"line\">      [Code Root Scanning (ms): Min: <span class=\"number\">0.4</span>, Avg: <span class=\"number\">0.4</span>, Max: <span class=\"number\">0.4</span>, Diff: <span class=\"number\">0.0</span>, Sum: <span class=\"number\">1.6</span>]</span><br><span class=\"line\">      [Object Copy (ms): Min: <span class=\"number\">99.5</span>, Avg: <span class=\"number\">100.2</span>, Max: <span class=\"number\">101.3</span>, Diff: <span class=\"number\">1.8</span>, Sum: <span class=\"number\">401.0</span>]</span><br><span class=\"line\">      [Termination (ms): Min: <span class=\"number\">0.0</span>, Avg: <span class=\"number\">1.6</span>, Max: <span class=\"number\">2.7</span>, Diff: <span class=\"number\">2.7</span>, Sum: <span class=\"number\">6.4</span>]</span><br><span class=\"line\">         [Termination Attempts: Min: <span class=\"number\">1</span>, Avg: <span class=\"number\">1.0</span>, Max: <span class=\"number\">1</span>, Diff: <span class=\"number\">0</span>, Sum: <span class=\"number\">4</span>]</span><br><span class=\"line\">      [GC Worker Other (ms): Min: <span class=\"number\">0.0</span>, Avg: <span class=\"number\">0.0</span>, Max: <span class=\"number\">0.0</span>, Diff: <span class=\"number\">0.0</span>, Sum: <span class=\"number\">0.1</span>]</span><br><span class=\"line\">      [GC Worker Total (ms): Min: <span class=\"number\">204.5</span>, Avg: <span class=\"number\">205.4</span>, Max: <span class=\"number\">206.3</span>, Diff: <span class=\"number\">1.9</span>, Sum: <span class=\"number\">821.8</span>]</span><br><span class=\"line\">      [GC Worker End (ms): Min: <span class=\"number\">181749004.7</span>, Avg: <span class=\"number\">181749005.3</span>, Max: <span class=\"number\">181749006.0</span>, Diff: <span class=\"number\">1.3</span>]</span><br><span class=\"line\">   [Code Root Fixup: <span class=\"number\">0.5</span> ms]</span><br><span class=\"line\">   [Code Root Purge: <span class=\"number\">0.0</span> ms]</span><br><span class=\"line\">   [Clear CT: <span class=\"number\">0.8</span> ms]</span><br><span class=\"line\">   [Other: <span class=\"number\">20.3</span> ms]</span><br><span class=\"line\">      [Choose CSet: <span class=\"number\">0.0</span> ms]</span><br><span class=\"line\">      [Ref Proc: <span class=\"number\">16.6</span> ms]</span><br><span class=\"line\">      [Ref Enq: <span class=\"number\">0.2</span> ms]</span><br><span class=\"line\">      [Redirty Cards: <span class=\"number\">0.2</span> ms]</span><br><span class=\"line\">      [Humongous Register: <span class=\"number\">0.2</span> ms]</span><br><span class=\"line\">      [Humongous Reclaim: <span class=\"number\">0.6</span> ms]</span><br><span class=\"line\">      [Free CSet: <span class=\"number\">1.7</span> ms]</span><br><span class=\"line\">   [Eden: <span class=\"number\">4836.0</span>M(<span class=\"number\">4836.0</span>M)-&gt;<span class=\"number\">0.0</span>B(<span class=\"number\">4768.0</span>M) Survivors: <span class=\"number\">76.0</span>M-&gt;<span class=\"number\">144.0</span>M Heap: <span class=\"number\">5973.0</span>M(<span class=\"number\">8192.0</span>M)-&gt;<span class=\"number\">768.7</span>M(<span class=\"number\">8192.0</span>M)]</span><br><span class=\"line\"> [Times: user=<span class=\"number\">0.69</span> sys=<span class=\"number\">0.01</span>, real=<span class=\"number\">0.23</span> secs]</span><br><span class=\"line\">2018-05-19T14:54:57.248+0800: 181776.117: [GC pause (G1 Evacuation Pause) (young), 0.1199877 secs]</span><br><span class=\"line\">   [Parallel Time: <span class=\"number\">104.5</span> ms, GC Workers: <span class=\"number\">4</span>]</span><br><span class=\"line\">      [GC Worker Start (ms): Min: <span class=\"number\">181776117.1</span>, Avg: <span class=\"number\">181776117.1</span>, Max: <span class=\"number\">181776117.2</span>, Diff: <span class=\"number\">0.1</span>]</span><br><span class=\"line\">      [Ext Root Scanning (ms): Min: <span class=\"number\">2.9</span>, Avg: <span class=\"number\">3.1</span>, Max: <span class=\"number\">3.2</span>, Diff: <span class=\"number\">0.3</span>, Sum: <span class=\"number\">12.3</span>]</span><br><span class=\"line\">      [Update RS (ms): Min: <span class=\"number\">42.2</span>, Avg: <span class=\"number\">42.3</span>, Max: <span class=\"number\">42.3</span>, Diff: <span class=\"number\">0.1</span>, Sum: <span class=\"number\">169.1</span>]</span><br><span class=\"line\">         [Processed Buffers: Min: <span class=\"number\">482</span>, Avg: <span class=\"number\">493.2</span>, Max: <span class=\"number\">506</span>, Diff: <span class=\"number\">24</span>, Sum: <span class=\"number\">1973</span>]</span><br><span class=\"line\">      [Scan RS (ms): Min: <span class=\"number\">0.7</span>, Avg: <span class=\"number\">0.8</span>, Max: <span class=\"number\">0.9</span>, Diff: <span class=\"number\">0.2</span>, Sum: <span class=\"number\">3.3</span>]</span><br><span class=\"line\">      [Code Root Scanning (ms): Min: <span class=\"number\">0.4</span>, Avg: <span class=\"number\">0.4</span>, Max: <span class=\"number\">0.4</span>, Diff: <span class=\"number\">0.1</span>, Sum: <span class=\"number\">1.6</span>]</span><br><span class=\"line\">      [Object Copy (ms): Min: <span class=\"number\">57.5</span>, Avg: <span class=\"number\">57.7</span>, Max: <span class=\"number\">57.8</span>, Diff: <span class=\"number\">0.3</span>, Sum: <span class=\"number\">230.6</span>]</span><br><span class=\"line\">      [Termination (ms): Min: <span class=\"number\">0.0</span>, Avg: <span class=\"number\">0.0</span>, Max: <span class=\"number\">0.0</span>, Diff: <span class=\"number\">0.0</span>, Sum: <span class=\"number\">0.0</span>]</span><br><span class=\"line\">         [Termination Attempts: Min: <span class=\"number\">1</span>, Avg: <span class=\"number\">1.0</span>, Max: <span class=\"number\">1</span>, Diff: <span class=\"number\">0</span>, Sum: <span class=\"number\">4</span>]</span><br><span class=\"line\">      [GC Worker Other (ms): Min: <span class=\"number\">0.1</span>, Avg: <span class=\"number\">0.1</span>, Max: <span class=\"number\">0.1</span>, Diff: <span class=\"number\">0.1</span>, Sum: <span class=\"number\">0.4</span>]</span><br><span class=\"line\">      [GC Worker Total (ms): Min: <span class=\"number\">104.3</span>, Avg: <span class=\"number\">104.4</span>, Max: <span class=\"number\">104.4</span>, Diff: <span class=\"number\">0.1</span>, Sum: <span class=\"number\">417.4</span>]</span><br><span class=\"line\">      [GC Worker End (ms): Min: <span class=\"number\">181776221.5</span>, Avg: <span class=\"number\">181776221.5</span>, Max: <span class=\"number\">181776221.5</span>, Diff: <span class=\"number\">0.1</span>]</span><br><span class=\"line\">   [Code Root Fixup: <span class=\"number\">0.5</span> ms]</span><br><span class=\"line\">   [Code Root Purge: <span class=\"number\">0.0</span> ms]</span><br><span class=\"line\">   [Clear CT: <span class=\"number\">0.6</span> ms]</span><br><span class=\"line\">   [Other: <span class=\"number\">14.3</span> ms]</span><br><span class=\"line\">      [Choose CSet: <span class=\"number\">0.0</span> ms]</span><br><span class=\"line\">      [Ref Proc: <span class=\"number\">11.1</span> ms]</span><br><span class=\"line\">      [Ref Enq: <span class=\"number\">0.1</span> ms]</span><br><span class=\"line\">      [Redirty Cards: <span class=\"number\">0.1</span> ms]</span><br><span class=\"line\">      [Humongous Register: <span class=\"number\">0.2</span> ms]</span><br><span class=\"line\">      [Humongous Reclaim: <span class=\"number\">0.3</span> ms]</span><br><span class=\"line\">      [Free CSet: <span class=\"number\">1.7</span> ms]</span><br><span class=\"line\">   [Eden: <span class=\"number\">4768.0</span>M(<span class=\"number\">4768.0</span>M)-&gt;<span class=\"number\">0.0</span>B(<span class=\"number\">4820.0</span>M) Survivors: <span class=\"number\">144.0</span>M-&gt;<span class=\"number\">92.0</span>M Heap: <span class=\"number\">5758.2</span>M(<span class=\"number\">8192.0</span>M)-&gt;<span class=\"number\">718.8</span>M(<span class=\"number\">8192.0</span>M)]</span><br><span class=\"line\"> [Times: user=<span class=\"number\">0.42</span> sys=<span class=\"number\">0.00</span>, real=<span class=\"number\">0.12</span> secs]</span><br><span class=\"line\">2018-05-19T14:55:13.434+0800: 181792.302: [GC pause (G1 Evacuation Pause) (young), 0.0821037 secs]</span><br><span class=\"line\">   [Parallel Time: <span class=\"number\">69.0</span> ms, GC Workers: <span class=\"number\">4</span>]</span><br><span class=\"line\">      [GC Worker Start (ms): Min: <span class=\"number\">181792302.8</span>, Avg: <span class=\"number\">181792302.8</span>, Max: <span class=\"number\">181792302.9</span>, Diff: <span class=\"number\">0.1</span>]</span><br><span class=\"line\">      [Ext Root Scanning (ms): Min: <span class=\"number\">5.7</span>, Avg: <span class=\"number\">6.1</span>, Max: <span class=\"number\">6.5</span>, Diff: <span class=\"number\">0.7</span>, Sum: <span class=\"number\">24.6</span>]</span><br><span class=\"line\">      [Update RS (ms): Min: <span class=\"number\">26.6</span>, Avg: <span class=\"number\">26.7</span>, Max: <span class=\"number\">26.7</span>, Diff: <span class=\"number\">0.1</span>, Sum: <span class=\"number\">106.7</span>]</span><br><span class=\"line\">         [Processed Buffers: Min: <span class=\"number\">310</span>, Avg: <span class=\"number\">326.2</span>, Max: <span class=\"number\">343</span>, Diff: <span class=\"number\">33</span>, Sum: <span class=\"number\">1305</span>]</span><br><span class=\"line\">      [Scan RS (ms): Min: <span class=\"number\">0.8</span>, Avg: <span class=\"number\">0.8</span>, Max: <span class=\"number\">0.8</span>, Diff: <span class=\"number\">0.1</span>, Sum: <span class=\"number\">3.1</span>]</span><br><span class=\"line\">      [Code Root Scanning (ms): Min: <span class=\"number\">0.4</span>, Avg: <span class=\"number\">0.4</span>, Max: <span class=\"number\">0.4</span>, Diff: <span class=\"number\">0.1</span>, Sum: <span class=\"number\">1.7</span>]</span><br><span class=\"line\">      [Object Copy (ms): Min: <span class=\"number\">34.4</span>, Avg: <span class=\"number\">34.7</span>, Max: <span class=\"number\">35.0</span>, Diff: <span class=\"number\">0.6</span>, Sum: <span class=\"number\">138.7</span>]</span><br><span class=\"line\">      [Termination (ms): Min: <span class=\"number\">0.0</span>, Avg: <span class=\"number\">0.0</span>, Max: <span class=\"number\">0.0</span>, Diff: <span class=\"number\">0.0</span>, Sum: <span class=\"number\">0.0</span>]</span><br><span class=\"line\">         [Termination Attempts: Min: <span class=\"number\">1</span>, Avg: <span class=\"number\">1.0</span>, Max: <span class=\"number\">1</span>, Diff: <span class=\"number\">0</span>, Sum: <span class=\"number\">4</span>]</span><br><span class=\"line\">      [GC Worker Other (ms): Min: <span class=\"number\">0.1</span>, Avg: <span class=\"number\">0.1</span>, Max: <span class=\"number\">0.1</span>, Diff: <span class=\"number\">0.1</span>, Sum: <span class=\"number\">0.4</span>]</span><br><span class=\"line\">      [GC Worker Total (ms): Min: <span class=\"number\">68.8</span>, Avg: <span class=\"number\">68.8</span>, Max: <span class=\"number\">68.8</span>, Diff: <span class=\"number\">0.0</span>, Sum: <span class=\"number\">275.1</span>]</span><br><span class=\"line\">      [GC Worker End (ms): Min: <span class=\"number\">181792371.6</span>, Avg: <span class=\"number\">181792371.6</span>, Max: <span class=\"number\">181792371.6</span>, Diff: <span class=\"number\">0.1</span>]</span><br><span class=\"line\">   [Code Root Fixup: <span class=\"number\">0.5</span> ms]</span><br><span class=\"line\">   [Code Root Purge: <span class=\"number\">0.0</span> ms]</span><br><span class=\"line\">   [Clear CT: <span class=\"number\">0.6</span> ms]</span><br><span class=\"line\">   [Other: <span class=\"number\">12.0</span> ms]</span><br><span class=\"line\">      [Choose CSet: <span class=\"number\">0.0</span> ms]</span><br><span class=\"line\">      [Ref Proc: <span class=\"number\">9.0</span> ms]</span><br><span class=\"line\">      [Ref Enq: <span class=\"number\">0.0</span> ms]</span><br><span class=\"line\">      [Redirty Cards: <span class=\"number\">0.2</span> ms]</span><br><span class=\"line\">      [Humongous Register: <span class=\"number\">0.2</span> ms]</span><br><span class=\"line\">      [Humongous Reclaim: <span class=\"number\">0.2</span> ms]</span><br><span class=\"line\">      [Free CSet: <span class=\"number\">1.6</span> ms]</span><br><span class=\"line\">   [Eden: <span class=\"number\">4820.0</span>M(<span class=\"number\">4820.0</span>M)-&gt;<span class=\"number\">0.0</span>B(<span class=\"number\">4852.0</span>M) Survivors: <span class=\"number\">92.0</span>M-&gt;<span class=\"number\">60.0</span>M Heap: <span class=\"number\">5678.8</span>M(<span class=\"number\">8192.0</span>M)-&gt;<span class=\"number\">686.9</span>M(<span class=\"number\">8192.0</span>M)]</span><br><span class=\"line\"> [Times: user=<span class=\"number\">0.28</span> sys=<span class=\"number\">0.01</span>, real=<span class=\"number\">0.08</span> secs]</span><br><span class=\"line\">2018-05-19T14:55:42.260+0800: 181821.129: [GC pause (G1 Evacuation Pause) (young), 0.1619036 secs]</span><br><span class=\"line\">   [Parallel Time: <span class=\"number\">141.3</span> ms, GC Workers: <span class=\"number\">4</span>]</span><br><span class=\"line\">      [GC Worker Start (ms): Min: <span class=\"number\">181821129.4</span>, Avg: <span class=\"number\">181821129.5</span>, Max: <span class=\"number\">181821129.5</span>, Diff: <span class=\"number\">0.1</span>]</span><br><span class=\"line\">      [Ext Root Scanning (ms): Min: <span class=\"number\">2.9</span>, Avg: <span class=\"number\">3.1</span>, Max: <span class=\"number\">3.3</span>, Diff: <span class=\"number\">0.4</span>, Sum: <span class=\"number\">12.6</span>]</span><br><span class=\"line\">      [Update RS (ms): Min: <span class=\"number\">41.9</span>, Avg: <span class=\"number\">41.9</span>, Max: <span class=\"number\">42.0</span>, Diff: <span class=\"number\">0.1</span>, Sum: <span class=\"number\">167.8</span>]</span><br><span class=\"line\">         [Processed Buffers: Min: <span class=\"number\">469</span>, Avg: <span class=\"number\">506.0</span>, Max: <span class=\"number\">533</span>, Diff: <span class=\"number\">64</span>, Sum: <span class=\"number\">2024</span>]</span><br><span class=\"line\">      [Scan RS (ms): Min: <span class=\"number\">0.7</span>, Avg: <span class=\"number\">0.8</span>, Max: <span class=\"number\">0.8</span>, Diff: <span class=\"number\">0.1</span>, Sum: <span class=\"number\">3.2</span>]</span><br><span class=\"line\">      [Code Root Scanning (ms): Min: <span class=\"number\">0.4</span>, Avg: <span class=\"number\">0.4</span>, Max: <span class=\"number\">0.4</span>, Diff: <span class=\"number\">0.0</span>, Sum: <span class=\"number\">1.6</span>]</span><br><span class=\"line\">      [Object Copy (ms): Min: <span class=\"number\">94.5</span>, Avg: <span class=\"number\">94.7</span>, Max: <span class=\"number\">94.8</span>, Diff: <span class=\"number\">0.3</span>, Sum: <span class=\"number\">378.6</span>]</span><br><span class=\"line\">      [Termination (ms): Min: <span class=\"number\">0.0</span>, Avg: <span class=\"number\">0.0</span>, Max: <span class=\"number\">0.0</span>, Diff: <span class=\"number\">0.0</span>, Sum: <span class=\"number\">0.0</span>]</span><br><span class=\"line\">         [Termination Attempts: Min: <span class=\"number\">1</span>, Avg: <span class=\"number\">1.0</span>, Max: <span class=\"number\">1</span>, Diff: <span class=\"number\">0</span>, Sum: <span class=\"number\">4</span>]</span><br><span class=\"line\">      [GC Worker Other (ms): Min: <span class=\"number\">0.0</span>, Avg: <span class=\"number\">0.1</span>, Max: <span class=\"number\">0.1</span>, Diff: <span class=\"number\">0.1</span>, Sum: <span class=\"number\">0.3</span>]</span><br><span class=\"line\">      [GC Worker Total (ms): Min: <span class=\"number\">141.0</span>, Avg: <span class=\"number\">141.0</span>, Max: <span class=\"number\">141.1</span>, Diff: <span class=\"number\">0.1</span>, Sum: <span class=\"number\">564.1</span>]</span><br><span class=\"line\">      [GC Worker End (ms): Min: <span class=\"number\">181821270.4</span>, Avg: <span class=\"number\">181821270.5</span>, Max: <span class=\"number\">181821270.5</span>, Diff: <span class=\"number\">0.1</span>]</span><br><span class=\"line\">   [Code Root Fixup: <span class=\"number\">0.5</span> ms]</span><br><span class=\"line\">   [Code Root Purge: <span class=\"number\">0.0</span> ms]</span><br><span class=\"line\">   [Clear CT: <span class=\"number\">0.7</span> ms]</span><br><span class=\"line\">   [Other: <span class=\"number\">19.4</span> ms]</span><br><span class=\"line\">      [Choose CSet: <span class=\"number\">0.0</span> ms]</span><br><span class=\"line\">      [Ref Proc: <span class=\"number\">16.2</span> ms]</span><br><span class=\"line\">      [Ref Enq: <span class=\"number\">0.2</span> ms]</span><br><span class=\"line\">      [Redirty Cards: <span class=\"number\">0.1</span> ms]</span><br><span class=\"line\">      [Humongous Register: <span class=\"number\">0.2</span> ms]</span><br><span class=\"line\">      [Humongous Reclaim: <span class=\"number\">0.3</span> ms]</span><br><span class=\"line\">      [Free CSet: <span class=\"number\">1.6</span> ms]</span><br><span class=\"line\">   [Eden: <span class=\"number\">4852.0</span>M(<span class=\"number\">4852.0</span>M)-&gt;<span class=\"number\">0.0</span>B(<span class=\"number\">4756.0</span>M) Survivors: <span class=\"number\">60.0</span>M-&gt;<span class=\"number\">156.0</span>M Heap: <span class=\"number\">5766.5</span>M(<span class=\"number\">8192.0</span>M)-&gt;<span class=\"number\">786.9</span>M(<span class=\"number\">8192.0</span>M)]</span><br><span class=\"line\"> [Times: user=<span class=\"number\">0.57</span> sys=<span class=\"number\">0.01</span>, real=<span class=\"number\">0.16</span> secs]</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"cms参数\"><a href=\"#cms参数\" class=\"headerlink\" title=\"cms参数\"></a>cms参数</h2><p>-XX:+CMSClassUnloadingEnabled -XX:CMSInitiatingOccupancyFraction=80 -XX:CMSMaxAbortablePrecleanTime=5000 -XX:+ExplicitGCInvokesConcurrent -XX:InitialHeapSize=8589934592 -XX:MaxDirectMemorySize=4294967296 -XX:MaxHeapSize=8589934592 -XX:MaxNewSize=6442450944 -XX:NewSize=6442450944 -XX:OldPLABSize=16 -XX:ParallelGCThreads=4 -XX:+PrintGC -XX:+PrintGCDateStamps -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:SurvivorRatio=4 -XX:+UseCMSCompactAtFullCollection -XX:+UseCMSInitiatingOccupancyOnly -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseConcMarkSweepGC -XX:+UseParNewGC<br>","more":"</p>\n<h2 id=\"cms日志\"><a href=\"#cms日志\" class=\"headerlink\" title=\"cms日志\"></a>cms日志</h2><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 正常cms log</span><br><span class=\"line\">2018-04-23T02:22:54.609+0800: 225411.844: [GC (CMS Initial Mark) [1 CMS-initial-mark: 1815727K(2097152K)] 2426460K(7340032K), 0.1136457 secs] [Times: user=0.38 sys=0.01, real=0.11 secs]</span><br><span class=\"line\">2018-04-23T02:22:54.723+0800: 225411.958: [CMS-concurrent-mark-start]</span><br><span class=\"line\">2018-04-23T02:22:55.236+0800: 225412.470: [CMS-concurrent-mark: 0.495/0.512 secs] [Times: user=1.70 sys=0.06, real=0.52 secs]</span><br><span class=\"line\">2018-04-23T02:22:55.236+0800: 225412.470: [CMS-concurrent-preclean-start]</span><br><span class=\"line\">2018-04-23T02:22:55.246+0800: 225412.480: [CMS-concurrent-preclean: 0.008/0.009 secs] [Times: user=0.03 sys=0.00, real=0.01 secs]</span><br><span class=\"line\">2018-04-23T02:22:55.246+0800: 225412.480: [CMS-concurrent-abortable-preclean-start]</span><br><span class=\"line\">2018-04-23T02:22:55.246+0800: 225412.480: [CMS-concurrent-abortable-preclean: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</span><br><span class=\"line\">2018-04-23T02:22:55.248+0800: 225412.483: [GC (CMS Final Remark) [YG occupancy: 923389 K (5242880 K)]2018-04-23T02:22:55.248+0800: 225412.483: [Rescan (parallel) , 0.1816314 secs]2018-04-23T02:22:55.430+0800: 225412.664: [weak refs processing, 0.0096429 secs]2018-04-23T02:22:55.440+0800: 225412.674: [class unloading, 0.1149430 secs]2018-04-23T02:22:55.555+0800: 225412.789: [scrub symbol table, 0.0100393 secs]2018-04-23T02:22:55.565+0800: 225412.799: [scrub string table, 0.0025445 secs][1 CMS-remark: 1815727K(2097152K)] 2739116K(7340032K), 0.3459856 secs] [Times: user=0.87 sys=0.01, real=0.34 secs]</span><br><span class=\"line\">2018-04-23T02:22:55.611+0800: 225412.845: [CMS-concurrent-sweep-start]</span><br><span class=\"line\">2018-04-23T02:22:56.039+0800: 225413.274: [CMS-concurrent-sweep: 0.374/0.429 secs] [Times: user=1.50 sys=0.04, real=0.43 secs]</span><br><span class=\"line\">2018-04-23T02:22:56.040+0800: 225413.274: [CMS-concurrent-reset-start]</span><br><span class=\"line\">2018-04-23T02:22:56.045+0800: 225413.279: [CMS-concurrent-reset: 0.005/0.005 secs] [Times: user=0.02 sys=0.00, real=0.00 secs]</span><br></pre></td></tr></table></figure>\n<h1 id=\"g1日志\"><a href=\"#g1日志\" class=\"headerlink\" title=\"g1日志\"></a>g1日志</h1><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2018-05-19T14:54:29.930+0800: 181748.799: [GC pause (G1 Evacuation Pause) (young), 0.2280865 secs]</span><br><span class=\"line\">   [Parallel Time: <span class=\"number\">206.5</span> ms, GC Workers: <span class=\"number\">4</span>]</span><br><span class=\"line\">      [GC Worker Start (ms): Min: <span class=\"number\">181748799.6</span>, Avg: <span class=\"number\">181748799.8</span>, Max: <span class=\"number\">181748800.2</span>, Diff: <span class=\"number\">0.6</span>]</span><br><span class=\"line\">      [Ext Root Scanning (ms): Min: <span class=\"number\">4.7</span>, Avg: <span class=\"number\">6.4</span>, Max: <span class=\"number\">10.4</span>, Diff: <span class=\"number\">5.7</span>, Sum: <span class=\"number\">25.7</span>]</span><br><span class=\"line\">      [Update RS (ms): Min: <span class=\"number\">92.5</span>, Avg: <span class=\"number\">95.9</span>, Max: <span class=\"number\">97.4</span>, Diff: <span class=\"number\">4.8</span>, Sum: <span class=\"number\">383.6</span>]</span><br><span class=\"line\">         [Processed Buffers: Min: <span class=\"number\">483</span>, Avg: <span class=\"number\">922.8</span>, Max: <span class=\"number\">1157</span>, Diff: <span class=\"number\">674</span>, Sum: <span class=\"number\">3691</span>]</span><br><span class=\"line\">      [Scan RS (ms): Min: <span class=\"number\">0.8</span>, Avg: <span class=\"number\">0.8</span>, Max: <span class=\"number\">0.8</span>, Diff: <span class=\"number\">0.1</span>, Sum: <span class=\"number\">3.2</span>]</span><br><span class=\"line\">      [Code Root Scanning (ms): Min: <span class=\"number\">0.4</span>, Avg: <span class=\"number\">0.4</span>, Max: <span class=\"number\">0.4</span>, Diff: <span class=\"number\">0.0</span>, Sum: <span class=\"number\">1.6</span>]</span><br><span class=\"line\">      [Object Copy (ms): Min: <span class=\"number\">99.5</span>, Avg: <span class=\"number\">100.2</span>, Max: <span class=\"number\">101.3</span>, Diff: <span class=\"number\">1.8</span>, Sum: <span class=\"number\">401.0</span>]</span><br><span class=\"line\">      [Termination (ms): Min: <span class=\"number\">0.0</span>, Avg: <span class=\"number\">1.6</span>, Max: <span class=\"number\">2.7</span>, Diff: <span class=\"number\">2.7</span>, Sum: <span class=\"number\">6.4</span>]</span><br><span class=\"line\">         [Termination Attempts: Min: <span class=\"number\">1</span>, Avg: <span class=\"number\">1.0</span>, Max: <span class=\"number\">1</span>, Diff: <span class=\"number\">0</span>, Sum: <span class=\"number\">4</span>]</span><br><span class=\"line\">      [GC Worker Other (ms): Min: <span class=\"number\">0.0</span>, Avg: <span class=\"number\">0.0</span>, Max: <span class=\"number\">0.0</span>, Diff: <span class=\"number\">0.0</span>, Sum: <span class=\"number\">0.1</span>]</span><br><span class=\"line\">      [GC Worker Total (ms): Min: <span class=\"number\">204.5</span>, Avg: <span class=\"number\">205.4</span>, Max: <span class=\"number\">206.3</span>, Diff: <span class=\"number\">1.9</span>, Sum: <span class=\"number\">821.8</span>]</span><br><span class=\"line\">      [GC Worker End (ms): Min: <span class=\"number\">181749004.7</span>, Avg: <span class=\"number\">181749005.3</span>, Max: <span class=\"number\">181749006.0</span>, Diff: <span class=\"number\">1.3</span>]</span><br><span class=\"line\">   [Code Root Fixup: <span class=\"number\">0.5</span> ms]</span><br><span class=\"line\">   [Code Root Purge: <span class=\"number\">0.0</span> ms]</span><br><span class=\"line\">   [Clear CT: <span class=\"number\">0.8</span> ms]</span><br><span class=\"line\">   [Other: <span class=\"number\">20.3</span> ms]</span><br><span class=\"line\">      [Choose CSet: <span class=\"number\">0.0</span> ms]</span><br><span class=\"line\">      [Ref Proc: <span class=\"number\">16.6</span> ms]</span><br><span class=\"line\">      [Ref Enq: <span class=\"number\">0.2</span> ms]</span><br><span class=\"line\">      [Redirty Cards: <span class=\"number\">0.2</span> ms]</span><br><span class=\"line\">      [Humongous Register: <span class=\"number\">0.2</span> ms]</span><br><span class=\"line\">      [Humongous Reclaim: <span class=\"number\">0.6</span> ms]</span><br><span class=\"line\">      [Free CSet: <span class=\"number\">1.7</span> ms]</span><br><span class=\"line\">   [Eden: <span class=\"number\">4836.0</span>M(<span class=\"number\">4836.0</span>M)-&gt;<span class=\"number\">0.0</span>B(<span class=\"number\">4768.0</span>M) Survivors: <span class=\"number\">76.0</span>M-&gt;<span class=\"number\">144.0</span>M Heap: <span class=\"number\">5973.0</span>M(<span class=\"number\">8192.0</span>M)-&gt;<span class=\"number\">768.7</span>M(<span class=\"number\">8192.0</span>M)]</span><br><span class=\"line\"> [Times: user=<span class=\"number\">0.69</span> sys=<span class=\"number\">0.01</span>, real=<span class=\"number\">0.23</span> secs]</span><br><span class=\"line\">2018-05-19T14:54:57.248+0800: 181776.117: [GC pause (G1 Evacuation Pause) (young), 0.1199877 secs]</span><br><span class=\"line\">   [Parallel Time: <span class=\"number\">104.5</span> ms, GC Workers: <span class=\"number\">4</span>]</span><br><span class=\"line\">      [GC Worker Start (ms): Min: <span class=\"number\">181776117.1</span>, Avg: <span class=\"number\">181776117.1</span>, Max: <span class=\"number\">181776117.2</span>, Diff: <span class=\"number\">0.1</span>]</span><br><span class=\"line\">      [Ext Root Scanning (ms): Min: <span class=\"number\">2.9</span>, Avg: <span class=\"number\">3.1</span>, Max: <span class=\"number\">3.2</span>, Diff: <span class=\"number\">0.3</span>, Sum: <span class=\"number\">12.3</span>]</span><br><span class=\"line\">      [Update RS (ms): Min: <span class=\"number\">42.2</span>, Avg: <span class=\"number\">42.3</span>, Max: <span class=\"number\">42.3</span>, Diff: <span class=\"number\">0.1</span>, Sum: <span class=\"number\">169.1</span>]</span><br><span class=\"line\">         [Processed Buffers: Min: <span class=\"number\">482</span>, Avg: <span class=\"number\">493.2</span>, Max: <span class=\"number\">506</span>, Diff: <span class=\"number\">24</span>, Sum: <span class=\"number\">1973</span>]</span><br><span class=\"line\">      [Scan RS (ms): Min: <span class=\"number\">0.7</span>, Avg: <span class=\"number\">0.8</span>, Max: <span class=\"number\">0.9</span>, Diff: <span class=\"number\">0.2</span>, Sum: <span class=\"number\">3.3</span>]</span><br><span class=\"line\">      [Code Root Scanning (ms): Min: <span class=\"number\">0.4</span>, Avg: <span class=\"number\">0.4</span>, Max: <span class=\"number\">0.4</span>, Diff: <span class=\"number\">0.1</span>, Sum: <span class=\"number\">1.6</span>]</span><br><span class=\"line\">      [Object Copy (ms): Min: <span class=\"number\">57.5</span>, Avg: <span class=\"number\">57.7</span>, Max: <span class=\"number\">57.8</span>, Diff: <span class=\"number\">0.3</span>, Sum: <span class=\"number\">230.6</span>]</span><br><span class=\"line\">      [Termination (ms): Min: <span class=\"number\">0.0</span>, Avg: <span class=\"number\">0.0</span>, Max: <span class=\"number\">0.0</span>, Diff: <span class=\"number\">0.0</span>, Sum: <span class=\"number\">0.0</span>]</span><br><span class=\"line\">         [Termination Attempts: Min: <span class=\"number\">1</span>, Avg: <span class=\"number\">1.0</span>, Max: <span class=\"number\">1</span>, Diff: <span class=\"number\">0</span>, Sum: <span class=\"number\">4</span>]</span><br><span class=\"line\">      [GC Worker Other (ms): Min: <span class=\"number\">0.1</span>, Avg: <span class=\"number\">0.1</span>, Max: <span class=\"number\">0.1</span>, Diff: <span class=\"number\">0.1</span>, Sum: <span class=\"number\">0.4</span>]</span><br><span class=\"line\">      [GC Worker Total (ms): Min: <span class=\"number\">104.3</span>, Avg: <span class=\"number\">104.4</span>, Max: <span class=\"number\">104.4</span>, Diff: <span class=\"number\">0.1</span>, Sum: <span class=\"number\">417.4</span>]</span><br><span class=\"line\">      [GC Worker End (ms): Min: <span class=\"number\">181776221.5</span>, Avg: <span class=\"number\">181776221.5</span>, Max: <span class=\"number\">181776221.5</span>, Diff: <span class=\"number\">0.1</span>]</span><br><span class=\"line\">   [Code Root Fixup: <span class=\"number\">0.5</span> ms]</span><br><span class=\"line\">   [Code Root Purge: <span class=\"number\">0.0</span> ms]</span><br><span class=\"line\">   [Clear CT: <span class=\"number\">0.6</span> ms]</span><br><span class=\"line\">   [Other: <span class=\"number\">14.3</span> ms]</span><br><span class=\"line\">      [Choose CSet: <span class=\"number\">0.0</span> ms]</span><br><span class=\"line\">      [Ref Proc: <span class=\"number\">11.1</span> ms]</span><br><span class=\"line\">      [Ref Enq: <span class=\"number\">0.1</span> ms]</span><br><span class=\"line\">      [Redirty Cards: <span class=\"number\">0.1</span> ms]</span><br><span class=\"line\">      [Humongous Register: <span class=\"number\">0.2</span> ms]</span><br><span class=\"line\">      [Humongous Reclaim: <span class=\"number\">0.3</span> ms]</span><br><span class=\"line\">      [Free CSet: <span class=\"number\">1.7</span> ms]</span><br><span class=\"line\">   [Eden: <span class=\"number\">4768.0</span>M(<span class=\"number\">4768.0</span>M)-&gt;<span class=\"number\">0.0</span>B(<span class=\"number\">4820.0</span>M) Survivors: <span class=\"number\">144.0</span>M-&gt;<span class=\"number\">92.0</span>M Heap: <span class=\"number\">5758.2</span>M(<span class=\"number\">8192.0</span>M)-&gt;<span class=\"number\">718.8</span>M(<span class=\"number\">8192.0</span>M)]</span><br><span class=\"line\"> [Times: user=<span class=\"number\">0.42</span> sys=<span class=\"number\">0.00</span>, real=<span class=\"number\">0.12</span> secs]</span><br><span class=\"line\">2018-05-19T14:55:13.434+0800: 181792.302: [GC pause (G1 Evacuation Pause) (young), 0.0821037 secs]</span><br><span class=\"line\">   [Parallel Time: <span class=\"number\">69.0</span> ms, GC Workers: <span class=\"number\">4</span>]</span><br><span class=\"line\">      [GC Worker Start (ms): Min: <span class=\"number\">181792302.8</span>, Avg: <span class=\"number\">181792302.8</span>, Max: <span class=\"number\">181792302.9</span>, Diff: <span class=\"number\">0.1</span>]</span><br><span class=\"line\">      [Ext Root Scanning (ms): Min: <span class=\"number\">5.7</span>, Avg: <span class=\"number\">6.1</span>, Max: <span class=\"number\">6.5</span>, Diff: <span class=\"number\">0.7</span>, Sum: <span class=\"number\">24.6</span>]</span><br><span class=\"line\">      [Update RS (ms): Min: <span class=\"number\">26.6</span>, Avg: <span class=\"number\">26.7</span>, Max: <span class=\"number\">26.7</span>, Diff: <span class=\"number\">0.1</span>, Sum: <span class=\"number\">106.7</span>]</span><br><span class=\"line\">         [Processed Buffers: Min: <span class=\"number\">310</span>, Avg: <span class=\"number\">326.2</span>, Max: <span class=\"number\">343</span>, Diff: <span class=\"number\">33</span>, Sum: <span class=\"number\">1305</span>]</span><br><span class=\"line\">      [Scan RS (ms): Min: <span class=\"number\">0.8</span>, Avg: <span class=\"number\">0.8</span>, Max: <span class=\"number\">0.8</span>, Diff: <span class=\"number\">0.1</span>, Sum: <span class=\"number\">3.1</span>]</span><br><span class=\"line\">      [Code Root Scanning (ms): Min: <span class=\"number\">0.4</span>, Avg: <span class=\"number\">0.4</span>, Max: <span class=\"number\">0.4</span>, Diff: <span class=\"number\">0.1</span>, Sum: <span class=\"number\">1.7</span>]</span><br><span class=\"line\">      [Object Copy (ms): Min: <span class=\"number\">34.4</span>, Avg: <span class=\"number\">34.7</span>, Max: <span class=\"number\">35.0</span>, Diff: <span class=\"number\">0.6</span>, Sum: <span class=\"number\">138.7</span>]</span><br><span class=\"line\">      [Termination (ms): Min: <span class=\"number\">0.0</span>, Avg: <span class=\"number\">0.0</span>, Max: <span class=\"number\">0.0</span>, Diff: <span class=\"number\">0.0</span>, Sum: <span class=\"number\">0.0</span>]</span><br><span class=\"line\">         [Termination Attempts: Min: <span class=\"number\">1</span>, Avg: <span class=\"number\">1.0</span>, Max: <span class=\"number\">1</span>, Diff: <span class=\"number\">0</span>, Sum: <span class=\"number\">4</span>]</span><br><span class=\"line\">      [GC Worker Other (ms): Min: <span class=\"number\">0.1</span>, Avg: <span class=\"number\">0.1</span>, Max: <span class=\"number\">0.1</span>, Diff: <span class=\"number\">0.1</span>, Sum: <span class=\"number\">0.4</span>]</span><br><span class=\"line\">      [GC Worker Total (ms): Min: <span class=\"number\">68.8</span>, Avg: <span class=\"number\">68.8</span>, Max: <span class=\"number\">68.8</span>, Diff: <span class=\"number\">0.0</span>, Sum: <span class=\"number\">275.1</span>]</span><br><span class=\"line\">      [GC Worker End (ms): Min: <span class=\"number\">181792371.6</span>, Avg: <span class=\"number\">181792371.6</span>, Max: <span class=\"number\">181792371.6</span>, Diff: <span class=\"number\">0.1</span>]</span><br><span class=\"line\">   [Code Root Fixup: <span class=\"number\">0.5</span> ms]</span><br><span class=\"line\">   [Code Root Purge: <span class=\"number\">0.0</span> ms]</span><br><span class=\"line\">   [Clear CT: <span class=\"number\">0.6</span> ms]</span><br><span class=\"line\">   [Other: <span class=\"number\">12.0</span> ms]</span><br><span class=\"line\">      [Choose CSet: <span class=\"number\">0.0</span> ms]</span><br><span class=\"line\">      [Ref Proc: <span class=\"number\">9.0</span> ms]</span><br><span class=\"line\">      [Ref Enq: <span class=\"number\">0.0</span> ms]</span><br><span class=\"line\">      [Redirty Cards: <span class=\"number\">0.2</span> ms]</span><br><span class=\"line\">      [Humongous Register: <span class=\"number\">0.2</span> ms]</span><br><span class=\"line\">      [Humongous Reclaim: <span class=\"number\">0.2</span> ms]</span><br><span class=\"line\">      [Free CSet: <span class=\"number\">1.6</span> ms]</span><br><span class=\"line\">   [Eden: <span class=\"number\">4820.0</span>M(<span class=\"number\">4820.0</span>M)-&gt;<span class=\"number\">0.0</span>B(<span class=\"number\">4852.0</span>M) Survivors: <span class=\"number\">92.0</span>M-&gt;<span class=\"number\">60.0</span>M Heap: <span class=\"number\">5678.8</span>M(<span class=\"number\">8192.0</span>M)-&gt;<span class=\"number\">686.9</span>M(<span class=\"number\">8192.0</span>M)]</span><br><span class=\"line\"> [Times: user=<span class=\"number\">0.28</span> sys=<span class=\"number\">0.01</span>, real=<span class=\"number\">0.08</span> secs]</span><br><span class=\"line\">2018-05-19T14:55:42.260+0800: 181821.129: [GC pause (G1 Evacuation Pause) (young), 0.1619036 secs]</span><br><span class=\"line\">   [Parallel Time: <span class=\"number\">141.3</span> ms, GC Workers: <span class=\"number\">4</span>]</span><br><span class=\"line\">      [GC Worker Start (ms): Min: <span class=\"number\">181821129.4</span>, Avg: <span class=\"number\">181821129.5</span>, Max: <span class=\"number\">181821129.5</span>, Diff: <span class=\"number\">0.1</span>]</span><br><span class=\"line\">      [Ext Root Scanning (ms): Min: <span class=\"number\">2.9</span>, Avg: <span class=\"number\">3.1</span>, Max: <span class=\"number\">3.3</span>, Diff: <span class=\"number\">0.4</span>, Sum: <span class=\"number\">12.6</span>]</span><br><span class=\"line\">      [Update RS (ms): Min: <span class=\"number\">41.9</span>, Avg: <span class=\"number\">41.9</span>, Max: <span class=\"number\">42.0</span>, Diff: <span class=\"number\">0.1</span>, Sum: <span class=\"number\">167.8</span>]</span><br><span class=\"line\">         [Processed Buffers: Min: <span class=\"number\">469</span>, Avg: <span class=\"number\">506.0</span>, Max: <span class=\"number\">533</span>, Diff: <span class=\"number\">64</span>, Sum: <span class=\"number\">2024</span>]</span><br><span class=\"line\">      [Scan RS (ms): Min: <span class=\"number\">0.7</span>, Avg: <span class=\"number\">0.8</span>, Max: <span class=\"number\">0.8</span>, Diff: <span class=\"number\">0.1</span>, Sum: <span class=\"number\">3.2</span>]</span><br><span class=\"line\">      [Code Root Scanning (ms): Min: <span class=\"number\">0.4</span>, Avg: <span class=\"number\">0.4</span>, Max: <span class=\"number\">0.4</span>, Diff: <span class=\"number\">0.0</span>, Sum: <span class=\"number\">1.6</span>]</span><br><span class=\"line\">      [Object Copy (ms): Min: <span class=\"number\">94.5</span>, Avg: <span class=\"number\">94.7</span>, Max: <span class=\"number\">94.8</span>, Diff: <span class=\"number\">0.3</span>, Sum: <span class=\"number\">378.6</span>]</span><br><span class=\"line\">      [Termination (ms): Min: <span class=\"number\">0.0</span>, Avg: <span class=\"number\">0.0</span>, Max: <span class=\"number\">0.0</span>, Diff: <span class=\"number\">0.0</span>, Sum: <span class=\"number\">0.0</span>]</span><br><span class=\"line\">         [Termination Attempts: Min: <span class=\"number\">1</span>, Avg: <span class=\"number\">1.0</span>, Max: <span class=\"number\">1</span>, Diff: <span class=\"number\">0</span>, Sum: <span class=\"number\">4</span>]</span><br><span class=\"line\">      [GC Worker Other (ms): Min: <span class=\"number\">0.0</span>, Avg: <span class=\"number\">0.1</span>, Max: <span class=\"number\">0.1</span>, Diff: <span class=\"number\">0.1</span>, Sum: <span class=\"number\">0.3</span>]</span><br><span class=\"line\">      [GC Worker Total (ms): Min: <span class=\"number\">141.0</span>, Avg: <span class=\"number\">141.0</span>, Max: <span class=\"number\">141.1</span>, Diff: <span class=\"number\">0.1</span>, Sum: <span class=\"number\">564.1</span>]</span><br><span class=\"line\">      [GC Worker End (ms): Min: <span class=\"number\">181821270.4</span>, Avg: <span class=\"number\">181821270.5</span>, Max: <span class=\"number\">181821270.5</span>, Diff: <span class=\"number\">0.1</span>]</span><br><span class=\"line\">   [Code Root Fixup: <span class=\"number\">0.5</span> ms]</span><br><span class=\"line\">   [Code Root Purge: <span class=\"number\">0.0</span> ms]</span><br><span class=\"line\">   [Clear CT: <span class=\"number\">0.7</span> ms]</span><br><span class=\"line\">   [Other: <span class=\"number\">19.4</span> ms]</span><br><span class=\"line\">      [Choose CSet: <span class=\"number\">0.0</span> ms]</span><br><span class=\"line\">      [Ref Proc: <span class=\"number\">16.2</span> ms]</span><br><span class=\"line\">      [Ref Enq: <span class=\"number\">0.2</span> ms]</span><br><span class=\"line\">      [Redirty Cards: <span class=\"number\">0.1</span> ms]</span><br><span class=\"line\">      [Humongous Register: <span class=\"number\">0.2</span> ms]</span><br><span class=\"line\">      [Humongous Reclaim: <span class=\"number\">0.3</span> ms]</span><br><span class=\"line\">      [Free CSet: <span class=\"number\">1.6</span> ms]</span><br><span class=\"line\">   [Eden: <span class=\"number\">4852.0</span>M(<span class=\"number\">4852.0</span>M)-&gt;<span class=\"number\">0.0</span>B(<span class=\"number\">4756.0</span>M) Survivors: <span class=\"number\">60.0</span>M-&gt;<span class=\"number\">156.0</span>M Heap: <span class=\"number\">5766.5</span>M(<span class=\"number\">8192.0</span>M)-&gt;<span class=\"number\">786.9</span>M(<span class=\"number\">8192.0</span>M)]</span><br><span class=\"line\"> [Times: user=<span class=\"number\">0.57</span> sys=<span class=\"number\">0.01</span>, real=<span class=\"number\">0.16</span> secs]</span><br></pre></td></tr></table></figure>"},{"title":"gc介绍","date":"2018-06-22T11:36:16.000Z","toc":true,"_content":"\n## GC分类\n### partial gc\n1. minor gc，回收年轻代\n2. major gc，回收老年代\n3. mixed gc，回收年轻代和一部分老年代，只有G1有\n\n### full gc\n回收整个java堆的gc\n\n### full gc的触发的原因：\n1. 由于\u001byoung gc前的预估发现老年代存放不下新生代晋升的对象（PromotionFailure）\n2. 创建大对象的时候，没有连续的内存存储，老年代不足以存放\n3. 显示的调用了System.GC，并且配合上了\u001bjvm参数\n\n**一般来说，Full GC == Major GC，因为发生major gc的时候一般都会先minor gc，\u001b但又不完全等价，Full GC需要回收年轻代和老年代，major gc不会**\n<!-- more -->\n\n## safe\u001b point\nGC的时候，\b所有线程都需要进入safe point才可以进行gc，\u001b而safe point是由jit\u001b加入的\n### 具体加入地点\n1. 所有方法返回之前\n2. 非计数循环的回跳之前\n3. native方法可以视为自动拥有safe point，native代码的执行与jvm\b无关\n\n## 对象存活判断\n名称|含义|优点|缺点  \n:-:|:-:|:-:|:-:\n引用计数|给每个对象加上一个属性，值为其他对象指向当前对象的次数。<br/>如果该属性值为0，就代表对象需要被回收。 |实现简单，性能高| 对象直接循环引用，会造成内存泄漏。\n可达性分析|从一组GC根对象出发，对堆内所有对象进行遍历，标记那些可以被到达的对象|准确度比较高，不会误判|耗时比较长，并且分析的过程中需要暂停程序的运行\n\n## 根对象\ngc根对象\b包含以下：\n1. java方法栈内的对象\n2. 本地方法栈内的对象\n3. 方法区内类静态属性引用的\b对象\n4. 方法区内常量池引用的\b对象\n\n## 回收算法\n名称|定义|优点|缺点  \n:-:|:-:|:-:|:-:\n标记复制（mark copy）|内存空间分为两块等大的区域，from和to区域。当from区域用完，先对需要回收的对象做标记，然后将未被标记的对象复制到另外to区域，最后清理from区域内存|速度比较快，只需要拷贝一遍对象就行了|\b占用内存比较大\n标记删除（mark sweep）|内存空间是连续的一整块。当内存用完的时候，标记需要回收的对象，然后\b进行回收。|较为快速，内存空间的利用率是比较高的|内存碎片出现比较大\n标记整理（mark compact）|在标记删除的最后，加上整理内存的步骤。|\b\b内存的连续性比较好，空间可以得到充分的利用。|时间比较长，整个步骤被分为，标记和复制两个步骤\n分代收集|针对于95%以上的对象存活时间比较短，将内存划分成两块区域，新生代和老年代。针对不同的代使用不同的算法|回收速度，内存连续性，内存使用率上面达到了一个平衡|暂无\n\n## 垃圾收集器\n### 其他gc\n名称|回收过程|参数|算法种类|优点|缺点\n:-:|:-:|:-:|:-:|:-:|:-:\nSerial/Serial Old|暂停\b\b所有用户线程，开始\u001b标记\u001b新生代和老年代，\b然后进行回收。|-XX:+UseSerialGC|**新生代**标记复制，老年代**标记整理**|\u001b简单而高效|\u001b大内存回收耗时比较长\nParNew|Serial收集器的多线程\u001b版本|-XX:+UseParNewGC，-XX:ParallelGCThreads|**新生代**收集器，标记复制|CMS的默认新生代收集器，多线程，效率较高|无\nParallel Scavenge|stw，并行，吞吐量优先|-XX:+UseParallelGC，-XX:MaxGCPauseMillis，-XX:GCTimeRatio，-XX:+UseAdptiveSizePolicy|**新生代**并行收集器，标记复制|\u001b\u001b多线程，吞吐量优先|回收不一定保证能完全回收\nParallel Old|\u001b同上|-XX:+UseParallelOldGC|老年代\u001b并行收集器，**标记整理**|同上|占用内存比较多\n\ntip: \n1. 所有的新生代收集器，标记整理\n2. SerialOld，ParallelOld，标记整理算法（只有这俩能够进行full gc）\n3. cms，标记\u001b删除\n4. g1，\u001b整体的标记复制\n\n### CMS\nconcurrent mark sweep\n#### 介绍\n老年代\u001b并发收集器，注重\u001b缩短收集时的用户线程的停顿时间\n#### 参数\n-XX:+UseConcMarkSweepGC，-XX:CMSFullGCsBeforeCompaction，-XX:+CMSParallelRemarkEnabled，\n-XX+UseCMSCompactAtFullCollection-XX:+UseCMSInitiatingOccupancyOnly，-XX:CMSInitiatingOccupancyFraction=70，\n-XX:CMSInitiatingPermOccupancyFraction，-XX:+CMSIncrementalMode，-XX:+CMSClassUnloadingEnabled\n#### 步骤\n1. 初始标记，stw，标记一下Gc Roots能关联到的对象\n2. 并发标记，在和用户线程并发运行的过程中，使用初始标记的结果作为集合去标记\u001b对象\n3. 重新标记，stw，修正并发标记的误差，\u001b因为有些对象可能没有被标记出来，\b时间比初始标记长\n4. 并发清除，回收所有垃圾对象\n\n#### 算法\n标记清除，会产生内存碎片，但是可以打开标记整理。\n#### 触发条件\n老年代使用率大于CMSInitiatingOccupancyFraction\n#### Concurrent Mode Failure\n- 由于整个时间操作都是比较长的，并且在CMS\b运行过程中,，预留空间不能够满足使用（大小不够或者连续容量不够）\n- 此时在并发阶段出现ConcurrentModeFailure的情况，CMS会启用**Serial Old**作为backup，配合ParNew去执行FullGC\n- cms会\u001b在老年代占用比例超过CMSInitiatingOccupancyFraction的时候进行回收\u001b老年代，发生major\b gc\n- major gc的重新标记步骤，**可能会触发一次新生代gc**（根据参数,CMSMaxAbortablePrecleanTime），触发了并且这次新生代gc成功，就会进行重新标记\n- 触发了\b，但是执行不成功，会转为由Serial Old来进行老年代的回收（完全的stw）\n#### 优点\nCMS的优点是，在\u001b老年代是使用到一定的比例就会开始进行老年代的\b回收，并且\u001b回收发生的绝大部分时间之内\b程序都是可以运行的。\n\n### G1\n#### 特性\n1. 更高的回收效率\n2. 更少的内存碎片\n3. 可预测的停顿模型\n\n#### 算法\n标记复制算法，小区域的复制，但是大范围上看起来是标记整理，不会产生内存碎片。\n#### 介绍\n将整个堆内存划分成最大2048个区域，年轻代和老年代可能会物理相邻。(region的大小从1MB开始，为2的倍数，最大32MB)。   \n在内存使用率大于InitiatingHeapOccupancyPercent开始进行初始标记，剩余内存小于G1ReservePercent时，进行回收。  \n整个回收的过程可能是young gc，或者是mixed gc。\nmixed gc回收多少老年代则主要取决于预测模型的决定。  \n预测模型会根据MaxGCPauseMillis来进行决定怎么回收，具体对哪一块进行回收（回收的效益会达到最高）。  \nHumongous对象会直接进入H区，H区的扫描比较简单的。  \nG1的young gc，mixed gc都会stw。  \n\n#### tip \n1. 回收过程中发生concurrent mode failure（晋升失败）或者 发生promotion failure，\u001b会启用serial old\u001b来stw做full gc\n2. mixed gc时候，通常需要也先触发一次young gc，这时候可以复用根扫描这个操作，并且可以大幅度减少需要扫描的对象\n\n#### 回收过程\n**young gc:**\n1. 根扫描， 静态和本地对象被扫描\n2. 更新RS，处理dirty card队列更新RS\n3. 处理RS，检测从年轻代指向年老代的对象\n4. 对象拷贝，拷贝存活的对象到survivor/old区域\n5. 处理引用队列，软引用，弱引用，虚引用处理  \n如图：![young区域回收](/images/g1内存示意.png)\n\n**mixed gc:**\n1. 初始标记（会复用young gc的标记）\n2. 并发标记\n3. 再次标记\n4. 清除垃圾\n5. 拷贝\n\n**tip**\n- RS中保存了`新生代的哪些对象被老年代引用了`\n- 在新生代扫描的过程当中，根扫描是一个比较耗时的工作，引入了remember set，用来记录哪些对象被老年代引用了\n- 主要还是为了避免扫描整个堆（老年代扫描比较慢）\n\n#### 参数\n-XX:UseG1GC,-XX:+UseG1GC,-XX:MaxGCPauseMillis=400,-XX:InitiatingHeapOccupancyPercent=40\n-XX:SurvivorRatio=1,-XX:MaxTenuringThreshold=15,-XX:G1ReservePercent=15\n-XX:+UnlockExperimentalVMOptions,-XX:G1NewSizePercent=40,-XX:G1MaxNewSizePercent=80\n\nParallel收集器和G1收集器不是在传统的hotspot垃圾收集器框架里面开发的，所以不能配合和其他收集器使用。","source":"_posts/gc介绍.md","raw":"---\ntitle: gc介绍\ndate: 2018-06-22 19:36:16\ntags:\n- jvm\n- gc\n- g1\n- cms\ncategories: \n- java\n- jvm\ntoc: true\n---\n\n## GC分类\n### partial gc\n1. minor gc，回收年轻代\n2. major gc，回收老年代\n3. mixed gc，回收年轻代和一部分老年代，只有G1有\n\n### full gc\n回收整个java堆的gc\n\n### full gc的触发的原因：\n1. 由于\u001byoung gc前的预估发现老年代存放不下新生代晋升的对象（PromotionFailure）\n2. 创建大对象的时候，没有连续的内存存储，老年代不足以存放\n3. 显示的调用了System.GC，并且配合上了\u001bjvm参数\n\n**一般来说，Full GC == Major GC，因为发生major gc的时候一般都会先minor gc，\u001b但又不完全等价，Full GC需要回收年轻代和老年代，major gc不会**\n<!-- more -->\n\n## safe\u001b point\nGC的时候，\b所有线程都需要进入safe point才可以进行gc，\u001b而safe point是由jit\u001b加入的\n### 具体加入地点\n1. 所有方法返回之前\n2. 非计数循环的回跳之前\n3. native方法可以视为自动拥有safe point，native代码的执行与jvm\b无关\n\n## 对象存活判断\n名称|含义|优点|缺点  \n:-:|:-:|:-:|:-:\n引用计数|给每个对象加上一个属性，值为其他对象指向当前对象的次数。<br/>如果该属性值为0，就代表对象需要被回收。 |实现简单，性能高| 对象直接循环引用，会造成内存泄漏。\n可达性分析|从一组GC根对象出发，对堆内所有对象进行遍历，标记那些可以被到达的对象|准确度比较高，不会误判|耗时比较长，并且分析的过程中需要暂停程序的运行\n\n## 根对象\ngc根对象\b包含以下：\n1. java方法栈内的对象\n2. 本地方法栈内的对象\n3. 方法区内类静态属性引用的\b对象\n4. 方法区内常量池引用的\b对象\n\n## 回收算法\n名称|定义|优点|缺点  \n:-:|:-:|:-:|:-:\n标记复制（mark copy）|内存空间分为两块等大的区域，from和to区域。当from区域用完，先对需要回收的对象做标记，然后将未被标记的对象复制到另外to区域，最后清理from区域内存|速度比较快，只需要拷贝一遍对象就行了|\b占用内存比较大\n标记删除（mark sweep）|内存空间是连续的一整块。当内存用完的时候，标记需要回收的对象，然后\b进行回收。|较为快速，内存空间的利用率是比较高的|内存碎片出现比较大\n标记整理（mark compact）|在标记删除的最后，加上整理内存的步骤。|\b\b内存的连续性比较好，空间可以得到充分的利用。|时间比较长，整个步骤被分为，标记和复制两个步骤\n分代收集|针对于95%以上的对象存活时间比较短，将内存划分成两块区域，新生代和老年代。针对不同的代使用不同的算法|回收速度，内存连续性，内存使用率上面达到了一个平衡|暂无\n\n## 垃圾收集器\n### 其他gc\n名称|回收过程|参数|算法种类|优点|缺点\n:-:|:-:|:-:|:-:|:-:|:-:\nSerial/Serial Old|暂停\b\b所有用户线程，开始\u001b标记\u001b新生代和老年代，\b然后进行回收。|-XX:+UseSerialGC|**新生代**标记复制，老年代**标记整理**|\u001b简单而高效|\u001b大内存回收耗时比较长\nParNew|Serial收集器的多线程\u001b版本|-XX:+UseParNewGC，-XX:ParallelGCThreads|**新生代**收集器，标记复制|CMS的默认新生代收集器，多线程，效率较高|无\nParallel Scavenge|stw，并行，吞吐量优先|-XX:+UseParallelGC，-XX:MaxGCPauseMillis，-XX:GCTimeRatio，-XX:+UseAdptiveSizePolicy|**新生代**并行收集器，标记复制|\u001b\u001b多线程，吞吐量优先|回收不一定保证能完全回收\nParallel Old|\u001b同上|-XX:+UseParallelOldGC|老年代\u001b并行收集器，**标记整理**|同上|占用内存比较多\n\ntip: \n1. 所有的新生代收集器，标记整理\n2. SerialOld，ParallelOld，标记整理算法（只有这俩能够进行full gc）\n3. cms，标记\u001b删除\n4. g1，\u001b整体的标记复制\n\n### CMS\nconcurrent mark sweep\n#### 介绍\n老年代\u001b并发收集器，注重\u001b缩短收集时的用户线程的停顿时间\n#### 参数\n-XX:+UseConcMarkSweepGC，-XX:CMSFullGCsBeforeCompaction，-XX:+CMSParallelRemarkEnabled，\n-XX+UseCMSCompactAtFullCollection-XX:+UseCMSInitiatingOccupancyOnly，-XX:CMSInitiatingOccupancyFraction=70，\n-XX:CMSInitiatingPermOccupancyFraction，-XX:+CMSIncrementalMode，-XX:+CMSClassUnloadingEnabled\n#### 步骤\n1. 初始标记，stw，标记一下Gc Roots能关联到的对象\n2. 并发标记，在和用户线程并发运行的过程中，使用初始标记的结果作为集合去标记\u001b对象\n3. 重新标记，stw，修正并发标记的误差，\u001b因为有些对象可能没有被标记出来，\b时间比初始标记长\n4. 并发清除，回收所有垃圾对象\n\n#### 算法\n标记清除，会产生内存碎片，但是可以打开标记整理。\n#### 触发条件\n老年代使用率大于CMSInitiatingOccupancyFraction\n#### Concurrent Mode Failure\n- 由于整个时间操作都是比较长的，并且在CMS\b运行过程中,，预留空间不能够满足使用（大小不够或者连续容量不够）\n- 此时在并发阶段出现ConcurrentModeFailure的情况，CMS会启用**Serial Old**作为backup，配合ParNew去执行FullGC\n- cms会\u001b在老年代占用比例超过CMSInitiatingOccupancyFraction的时候进行回收\u001b老年代，发生major\b gc\n- major gc的重新标记步骤，**可能会触发一次新生代gc**（根据参数,CMSMaxAbortablePrecleanTime），触发了并且这次新生代gc成功，就会进行重新标记\n- 触发了\b，但是执行不成功，会转为由Serial Old来进行老年代的回收（完全的stw）\n#### 优点\nCMS的优点是，在\u001b老年代是使用到一定的比例就会开始进行老年代的\b回收，并且\u001b回收发生的绝大部分时间之内\b程序都是可以运行的。\n\n### G1\n#### 特性\n1. 更高的回收效率\n2. 更少的内存碎片\n3. 可预测的停顿模型\n\n#### 算法\n标记复制算法，小区域的复制，但是大范围上看起来是标记整理，不会产生内存碎片。\n#### 介绍\n将整个堆内存划分成最大2048个区域，年轻代和老年代可能会物理相邻。(region的大小从1MB开始，为2的倍数，最大32MB)。   \n在内存使用率大于InitiatingHeapOccupancyPercent开始进行初始标记，剩余内存小于G1ReservePercent时，进行回收。  \n整个回收的过程可能是young gc，或者是mixed gc。\nmixed gc回收多少老年代则主要取决于预测模型的决定。  \n预测模型会根据MaxGCPauseMillis来进行决定怎么回收，具体对哪一块进行回收（回收的效益会达到最高）。  \nHumongous对象会直接进入H区，H区的扫描比较简单的。  \nG1的young gc，mixed gc都会stw。  \n\n#### tip \n1. 回收过程中发生concurrent mode failure（晋升失败）或者 发生promotion failure，\u001b会启用serial old\u001b来stw做full gc\n2. mixed gc时候，通常需要也先触发一次young gc，这时候可以复用根扫描这个操作，并且可以大幅度减少需要扫描的对象\n\n#### 回收过程\n**young gc:**\n1. 根扫描， 静态和本地对象被扫描\n2. 更新RS，处理dirty card队列更新RS\n3. 处理RS，检测从年轻代指向年老代的对象\n4. 对象拷贝，拷贝存活的对象到survivor/old区域\n5. 处理引用队列，软引用，弱引用，虚引用处理  \n如图：![young区域回收](/images/g1内存示意.png)\n\n**mixed gc:**\n1. 初始标记（会复用young gc的标记）\n2. 并发标记\n3. 再次标记\n4. 清除垃圾\n5. 拷贝\n\n**tip**\n- RS中保存了`新生代的哪些对象被老年代引用了`\n- 在新生代扫描的过程当中，根扫描是一个比较耗时的工作，引入了remember set，用来记录哪些对象被老年代引用了\n- 主要还是为了避免扫描整个堆（老年代扫描比较慢）\n\n#### 参数\n-XX:UseG1GC,-XX:+UseG1GC,-XX:MaxGCPauseMillis=400,-XX:InitiatingHeapOccupancyPercent=40\n-XX:SurvivorRatio=1,-XX:MaxTenuringThreshold=15,-XX:G1ReservePercent=15\n-XX:+UnlockExperimentalVMOptions,-XX:G1NewSizePercent=40,-XX:G1MaxNewSizePercent=80\n\nParallel收集器和G1收集器不是在传统的hotspot垃圾收集器框架里面开发的，所以不能配合和其他收集器使用。","slug":"gc介绍","published":1,"updated":"2018-06-23T10:57:59.184Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5u1tvj001j1av8trgj8igr","content":"<h2 id=\"GC分类\"><a href=\"#GC分类\" class=\"headerlink\" title=\"GC分类\"></a>GC分类</h2><h3 id=\"partial-gc\"><a href=\"#partial-gc\" class=\"headerlink\" title=\"partial gc\"></a>partial gc</h3><ol>\n<li>minor gc，回收年轻代</li>\n<li>major gc，回收老年代</li>\n<li>mixed gc，回收年轻代和一部分老年代，只有G1有</li>\n</ol>\n<h3 id=\"full-gc\"><a href=\"#full-gc\" class=\"headerlink\" title=\"full gc\"></a>full gc</h3><p>回收整个java堆的gc</p>\n<h3 id=\"full-gc的触发的原因：\"><a href=\"#full-gc的触发的原因：\" class=\"headerlink\" title=\"full gc的触发的原因：\"></a>full gc的触发的原因：</h3><ol>\n<li>由于\u001byoung gc前的预估发现老年代存放不下新生代晋升的对象（PromotionFailure）</li>\n<li>创建大对象的时候，没有连续的内存存储，老年代不足以存放</li>\n<li>显示的调用了System.GC，并且配合上了\u001bjvm参数</li>\n</ol>\n<p><strong>一般来说，Full GC == Major GC，因为发生major gc的时候一般都会先minor gc，\u001b但又不完全等价，Full GC需要回收年轻代和老年代，major gc不会</strong><br><a id=\"more\"></a></p>\n<h2 id=\"safe-point\"><a href=\"#safe-point\" class=\"headerlink\" title=\"safe\u001b point\"></a>safe\u001b point</h2><p>GC的时候，\b所有线程都需要进入safe point才可以进行gc，\u001b而safe point是由jit\u001b加入的</p>\n<h3 id=\"具体加入地点\"><a href=\"#具体加入地点\" class=\"headerlink\" title=\"具体加入地点\"></a>具体加入地点</h3><ol>\n<li>所有方法返回之前</li>\n<li>非计数循环的回跳之前</li>\n<li>native方法可以视为自动拥有safe point，native代码的执行与jvm\b无关</li>\n</ol>\n<h2 id=\"对象存活判断\"><a href=\"#对象存活判断\" class=\"headerlink\" title=\"对象存活判断\"></a>对象存活判断</h2><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">名称</th>\n<th style=\"text-align:center\">含义</th>\n<th style=\"text-align:center\">优点</th>\n<th style=\"text-align:center\">缺点  </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">引用计数</td>\n<td style=\"text-align:center\">给每个对象加上一个属性，值为其他对象指向当前对象的次数。<br>如果该属性值为0，就代表对象需要被回收。</td>\n<td style=\"text-align:center\">实现简单，性能高</td>\n<td style=\"text-align:center\">对象直接循环引用，会造成内存泄漏。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">可达性分析</td>\n<td style=\"text-align:center\">从一组GC根对象出发，对堆内所有对象进行遍历，标记那些可以被到达的对象</td>\n<td style=\"text-align:center\">准确度比较高，不会误判</td>\n<td style=\"text-align:center\">耗时比较长，并且分析的过程中需要暂停程序的运行</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"根对象\"><a href=\"#根对象\" class=\"headerlink\" title=\"根对象\"></a>根对象</h2><p>gc根对象\b包含以下：</p>\n<ol>\n<li>java方法栈内的对象</li>\n<li>本地方法栈内的对象</li>\n<li>方法区内类静态属性引用的\b对象</li>\n<li>方法区内常量池引用的\b对象</li>\n</ol>\n<h2 id=\"回收算法\"><a href=\"#回收算法\" class=\"headerlink\" title=\"回收算法\"></a>回收算法</h2><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">名称</th>\n<th style=\"text-align:center\">定义</th>\n<th style=\"text-align:center\">优点</th>\n<th style=\"text-align:center\">缺点  </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">标记复制（mark copy）</td>\n<td style=\"text-align:center\">内存空间分为两块等大的区域，from和to区域。当from区域用完，先对需要回收的对象做标记，然后将未被标记的对象复制到另外to区域，最后清理from区域内存</td>\n<td style=\"text-align:center\">速度比较快，只需要拷贝一遍对象就行了</td>\n<td style=\"text-align:center\">\b占用内存比较大</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">标记删除（mark sweep）</td>\n<td style=\"text-align:center\">内存空间是连续的一整块。当内存用完的时候，标记需要回收的对象，然后\b进行回收。</td>\n<td style=\"text-align:center\">较为快速，内存空间的利用率是比较高的</td>\n<td style=\"text-align:center\">内存碎片出现比较大</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">标记整理（mark compact）</td>\n<td style=\"text-align:center\">在标记删除的最后，加上整理内存的步骤。</td>\n<td style=\"text-align:center\">\b\b内存的连续性比较好，空间可以得到充分的利用。</td>\n<td style=\"text-align:center\">时间比较长，整个步骤被分为，标记和复制两个步骤</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">分代收集</td>\n<td style=\"text-align:center\">针对于95%以上的对象存活时间比较短，将内存划分成两块区域，新生代和老年代。针对不同的代使用不同的算法</td>\n<td style=\"text-align:center\">回收速度，内存连续性，内存使用率上面达到了一个平衡</td>\n<td style=\"text-align:center\">暂无</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"垃圾收集器\"><a href=\"#垃圾收集器\" class=\"headerlink\" title=\"垃圾收集器\"></a>垃圾收集器</h2><h3 id=\"其他gc\"><a href=\"#其他gc\" class=\"headerlink\" title=\"其他gc\"></a>其他gc</h3><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">名称</th>\n<th style=\"text-align:center\">回收过程</th>\n<th style=\"text-align:center\">参数</th>\n<th style=\"text-align:center\">算法种类</th>\n<th style=\"text-align:center\">优点</th>\n<th style=\"text-align:center\">缺点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">Serial/Serial Old</td>\n<td style=\"text-align:center\">暂停\b\b所有用户线程，开始\u001b标记\u001b新生代和老年代，\b然后进行回收。</td>\n<td style=\"text-align:center\">-XX:+UseSerialGC</td>\n<td style=\"text-align:center\"><strong>新生代</strong>标记复制，老年代<strong>标记整理</strong></td>\n<td style=\"text-align:center\">\u001b简单而高效</td>\n<td style=\"text-align:center\">\u001b大内存回收耗时比较长</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ParNew</td>\n<td style=\"text-align:center\">Serial收集器的多线程\u001b版本</td>\n<td style=\"text-align:center\">-XX:+UseParNewGC，-XX:ParallelGCThreads</td>\n<td style=\"text-align:center\"><strong>新生代</strong>收集器，标记复制</td>\n<td style=\"text-align:center\">CMS的默认新生代收集器，多线程，效率较高</td>\n<td style=\"text-align:center\">无</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Parallel Scavenge</td>\n<td style=\"text-align:center\">stw，并行，吞吐量优先</td>\n<td style=\"text-align:center\">-XX:+UseParallelGC，-XX:MaxGCPauseMillis，-XX:GCTimeRatio，-XX:+UseAdptiveSizePolicy</td>\n<td style=\"text-align:center\"><strong>新生代</strong>并行收集器，标记复制</td>\n<td style=\"text-align:center\">\u001b\u001b多线程，吞吐量优先</td>\n<td style=\"text-align:center\">回收不一定保证能完全回收</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Parallel Old</td>\n<td style=\"text-align:center\">\u001b同上</td>\n<td style=\"text-align:center\">-XX:+UseParallelOldGC</td>\n<td style=\"text-align:center\">老年代\u001b并行收集器，<strong>标记整理</strong></td>\n<td style=\"text-align:center\">同上</td>\n<td style=\"text-align:center\">占用内存比较多</td>\n</tr>\n</tbody>\n</table>\n<p>tip: </p>\n<ol>\n<li>所有的新生代收集器，标记整理</li>\n<li>SerialOld，ParallelOld，标记整理算法（只有这俩能够进行full gc）</li>\n<li>cms，标记\u001b删除</li>\n<li>g1，\u001b整体的标记复制</li>\n</ol>\n<h3 id=\"CMS\"><a href=\"#CMS\" class=\"headerlink\" title=\"CMS\"></a>CMS</h3><p>concurrent mark sweep</p>\n<h4 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><p>老年代\u001b并发收集器，注重\u001b缩短收集时的用户线程的停顿时间</p>\n<h4 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h4><p>-XX:+UseConcMarkSweepGC，-XX:CMSFullGCsBeforeCompaction，-XX:+CMSParallelRemarkEnabled，<br>-XX+UseCMSCompactAtFullCollection-XX:+UseCMSInitiatingOccupancyOnly，-XX:CMSInitiatingOccupancyFraction=70，<br>-XX:CMSInitiatingPermOccupancyFraction，-XX:+CMSIncrementalMode，-XX:+CMSClassUnloadingEnabled</p>\n<h4 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h4><ol>\n<li>初始标记，stw，标记一下Gc Roots能关联到的对象</li>\n<li>并发标记，在和用户线程并发运行的过程中，使用初始标记的结果作为集合去标记\u001b对象</li>\n<li>重新标记，stw，修正并发标记的误差，\u001b因为有些对象可能没有被标记出来，\b时间比初始标记长</li>\n<li>并发清除，回收所有垃圾对象</li>\n</ol>\n<h4 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h4><p>标记清除，会产生内存碎片，但是可以打开标记整理。</p>\n<h4 id=\"触发条件\"><a href=\"#触发条件\" class=\"headerlink\" title=\"触发条件\"></a>触发条件</h4><p>老年代使用率大于CMSInitiatingOccupancyFraction</p>\n<h4 id=\"Concurrent-Mode-Failure\"><a href=\"#Concurrent-Mode-Failure\" class=\"headerlink\" title=\"Concurrent Mode Failure\"></a>Concurrent Mode Failure</h4><ul>\n<li>由于整个时间操作都是比较长的，并且在CMS\b运行过程中,，预留空间不能够满足使用（大小不够或者连续容量不够）</li>\n<li>此时在并发阶段出现ConcurrentModeFailure的情况，CMS会启用<strong>Serial Old</strong>作为backup，配合ParNew去执行FullGC</li>\n<li>cms会\u001b在老年代占用比例超过CMSInitiatingOccupancyFraction的时候进行回收\u001b老年代，发生major\b gc</li>\n<li>major gc的重新标记步骤，<strong>可能会触发一次新生代gc</strong>（根据参数,CMSMaxAbortablePrecleanTime），触发了并且这次新生代gc成功，就会进行重新标记</li>\n<li>触发了\b，但是执行不成功，会转为由Serial Old来进行老年代的回收（完全的stw）<h4 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h4>CMS的优点是，在\u001b老年代是使用到一定的比例就会开始进行老年代的\b回收，并且\u001b回收发生的绝大部分时间之内\b程序都是可以运行的。</li>\n</ul>\n<h3 id=\"G1\"><a href=\"#G1\" class=\"headerlink\" title=\"G1\"></a>G1</h3><h4 id=\"特性\"><a href=\"#特性\" class=\"headerlink\" title=\"特性\"></a>特性</h4><ol>\n<li>更高的回收效率</li>\n<li>更少的内存碎片</li>\n<li>可预测的停顿模型</li>\n</ol>\n<h4 id=\"算法-1\"><a href=\"#算法-1\" class=\"headerlink\" title=\"算法\"></a>算法</h4><p>标记复制算法，小区域的复制，但是大范围上看起来是标记整理，不会产生内存碎片。</p>\n<h4 id=\"介绍-1\"><a href=\"#介绍-1\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><p>将整个堆内存划分成最大2048个区域，年轻代和老年代可能会物理相邻。(region的大小从1MB开始，为2的倍数，最大32MB)。<br>在内存使用率大于InitiatingHeapOccupancyPercent开始进行初始标记，剩余内存小于G1ReservePercent时，进行回收。<br>整个回收的过程可能是young gc，或者是mixed gc。<br>mixed gc回收多少老年代则主要取决于预测模型的决定。<br>预测模型会根据MaxGCPauseMillis来进行决定怎么回收，具体对哪一块进行回收（回收的效益会达到最高）。<br>Humongous对象会直接进入H区，H区的扫描比较简单的。<br>G1的young gc，mixed gc都会stw。  </p>\n<h4 id=\"tip\"><a href=\"#tip\" class=\"headerlink\" title=\"tip\"></a>tip</h4><ol>\n<li>回收过程中发生concurrent mode failure（晋升失败）或者 发生promotion failure，\u001b会启用serial old\u001b来stw做full gc</li>\n<li>mixed gc时候，通常需要也先触发一次young gc，这时候可以复用根扫描这个操作，并且可以大幅度减少需要扫描的对象</li>\n</ol>\n<h4 id=\"回收过程\"><a href=\"#回收过程\" class=\"headerlink\" title=\"回收过程\"></a>回收过程</h4><p><strong>young gc:</strong></p>\n<ol>\n<li>根扫描， 静态和本地对象被扫描</li>\n<li>更新RS，处理dirty card队列更新RS</li>\n<li>处理RS，检测从年轻代指向年老代的对象</li>\n<li>对象拷贝，拷贝存活的对象到survivor/old区域</li>\n<li>处理引用队列，软引用，弱引用，虚引用处理<br>如图：<img src=\"/images/g1内存示意.png\" alt=\"young区域回收\"></li>\n</ol>\n<p><strong>mixed gc:</strong></p>\n<ol>\n<li>初始标记（会复用young gc的标记）</li>\n<li>并发标记</li>\n<li>再次标记</li>\n<li>清除垃圾</li>\n<li>拷贝</li>\n</ol>\n<p><strong>tip</strong></p>\n<ul>\n<li>RS中保存了<code>新生代的哪些对象被老年代引用了</code></li>\n<li>在新生代扫描的过程当中，根扫描是一个比较耗时的工作，引入了remember set，用来记录哪些对象被老年代引用了</li>\n<li>主要还是为了避免扫描整个堆（老年代扫描比较慢）</li>\n</ul>\n<h4 id=\"参数-1\"><a href=\"#参数-1\" class=\"headerlink\" title=\"参数\"></a>参数</h4><p>-XX:UseG1GC,-XX:+UseG1GC,-XX:MaxGCPauseMillis=400,-XX:InitiatingHeapOccupancyPercent=40<br>-XX:SurvivorRatio=1,-XX:MaxTenuringThreshold=15,-XX:G1ReservePercent=15<br>-XX:+UnlockExperimentalVMOptions,-XX:G1NewSizePercent=40,-XX:G1MaxNewSizePercent=80</p>\n<p>Parallel收集器和G1收集器不是在传统的hotspot垃圾收集器框架里面开发的，所以不能配合和其他收集器使用。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"GC分类\"><a href=\"#GC分类\" class=\"headerlink\" title=\"GC分类\"></a>GC分类</h2><h3 id=\"partial-gc\"><a href=\"#partial-gc\" class=\"headerlink\" title=\"partial gc\"></a>partial gc</h3><ol>\n<li>minor gc，回收年轻代</li>\n<li>major gc，回收老年代</li>\n<li>mixed gc，回收年轻代和一部分老年代，只有G1有</li>\n</ol>\n<h3 id=\"full-gc\"><a href=\"#full-gc\" class=\"headerlink\" title=\"full gc\"></a>full gc</h3><p>回收整个java堆的gc</p>\n<h3 id=\"full-gc的触发的原因：\"><a href=\"#full-gc的触发的原因：\" class=\"headerlink\" title=\"full gc的触发的原因：\"></a>full gc的触发的原因：</h3><ol>\n<li>由于\u001byoung gc前的预估发现老年代存放不下新生代晋升的对象（PromotionFailure）</li>\n<li>创建大对象的时候，没有连续的内存存储，老年代不足以存放</li>\n<li>显示的调用了System.GC，并且配合上了\u001bjvm参数</li>\n</ol>\n<p><strong>一般来说，Full GC == Major GC，因为发生major gc的时候一般都会先minor gc，\u001b但又不完全等价，Full GC需要回收年轻代和老年代，major gc不会</strong><br>","more":"</p>\n<h2 id=\"safe-point\"><a href=\"#safe-point\" class=\"headerlink\" title=\"safe\u001b point\"></a>safe\u001b point</h2><p>GC的时候，\b所有线程都需要进入safe point才可以进行gc，\u001b而safe point是由jit\u001b加入的</p>\n<h3 id=\"具体加入地点\"><a href=\"#具体加入地点\" class=\"headerlink\" title=\"具体加入地点\"></a>具体加入地点</h3><ol>\n<li>所有方法返回之前</li>\n<li>非计数循环的回跳之前</li>\n<li>native方法可以视为自动拥有safe point，native代码的执行与jvm\b无关</li>\n</ol>\n<h2 id=\"对象存活判断\"><a href=\"#对象存活判断\" class=\"headerlink\" title=\"对象存活判断\"></a>对象存活判断</h2><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">名称</th>\n<th style=\"text-align:center\">含义</th>\n<th style=\"text-align:center\">优点</th>\n<th style=\"text-align:center\">缺点  </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">引用计数</td>\n<td style=\"text-align:center\">给每个对象加上一个属性，值为其他对象指向当前对象的次数。<br>如果该属性值为0，就代表对象需要被回收。</td>\n<td style=\"text-align:center\">实现简单，性能高</td>\n<td style=\"text-align:center\">对象直接循环引用，会造成内存泄漏。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">可达性分析</td>\n<td style=\"text-align:center\">从一组GC根对象出发，对堆内所有对象进行遍历，标记那些可以被到达的对象</td>\n<td style=\"text-align:center\">准确度比较高，不会误判</td>\n<td style=\"text-align:center\">耗时比较长，并且分析的过程中需要暂停程序的运行</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"根对象\"><a href=\"#根对象\" class=\"headerlink\" title=\"根对象\"></a>根对象</h2><p>gc根对象\b包含以下：</p>\n<ol>\n<li>java方法栈内的对象</li>\n<li>本地方法栈内的对象</li>\n<li>方法区内类静态属性引用的\b对象</li>\n<li>方法区内常量池引用的\b对象</li>\n</ol>\n<h2 id=\"回收算法\"><a href=\"#回收算法\" class=\"headerlink\" title=\"回收算法\"></a>回收算法</h2><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">名称</th>\n<th style=\"text-align:center\">定义</th>\n<th style=\"text-align:center\">优点</th>\n<th style=\"text-align:center\">缺点  </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">标记复制（mark copy）</td>\n<td style=\"text-align:center\">内存空间分为两块等大的区域，from和to区域。当from区域用完，先对需要回收的对象做标记，然后将未被标记的对象复制到另外to区域，最后清理from区域内存</td>\n<td style=\"text-align:center\">速度比较快，只需要拷贝一遍对象就行了</td>\n<td style=\"text-align:center\">\b占用内存比较大</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">标记删除（mark sweep）</td>\n<td style=\"text-align:center\">内存空间是连续的一整块。当内存用完的时候，标记需要回收的对象，然后\b进行回收。</td>\n<td style=\"text-align:center\">较为快速，内存空间的利用率是比较高的</td>\n<td style=\"text-align:center\">内存碎片出现比较大</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">标记整理（mark compact）</td>\n<td style=\"text-align:center\">在标记删除的最后，加上整理内存的步骤。</td>\n<td style=\"text-align:center\">\b\b内存的连续性比较好，空间可以得到充分的利用。</td>\n<td style=\"text-align:center\">时间比较长，整个步骤被分为，标记和复制两个步骤</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">分代收集</td>\n<td style=\"text-align:center\">针对于95%以上的对象存活时间比较短，将内存划分成两块区域，新生代和老年代。针对不同的代使用不同的算法</td>\n<td style=\"text-align:center\">回收速度，内存连续性，内存使用率上面达到了一个平衡</td>\n<td style=\"text-align:center\">暂无</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"垃圾收集器\"><a href=\"#垃圾收集器\" class=\"headerlink\" title=\"垃圾收集器\"></a>垃圾收集器</h2><h3 id=\"其他gc\"><a href=\"#其他gc\" class=\"headerlink\" title=\"其他gc\"></a>其他gc</h3><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">名称</th>\n<th style=\"text-align:center\">回收过程</th>\n<th style=\"text-align:center\">参数</th>\n<th style=\"text-align:center\">算法种类</th>\n<th style=\"text-align:center\">优点</th>\n<th style=\"text-align:center\">缺点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">Serial/Serial Old</td>\n<td style=\"text-align:center\">暂停\b\b所有用户线程，开始\u001b标记\u001b新生代和老年代，\b然后进行回收。</td>\n<td style=\"text-align:center\">-XX:+UseSerialGC</td>\n<td style=\"text-align:center\"><strong>新生代</strong>标记复制，老年代<strong>标记整理</strong></td>\n<td style=\"text-align:center\">\u001b简单而高效</td>\n<td style=\"text-align:center\">\u001b大内存回收耗时比较长</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ParNew</td>\n<td style=\"text-align:center\">Serial收集器的多线程\u001b版本</td>\n<td style=\"text-align:center\">-XX:+UseParNewGC，-XX:ParallelGCThreads</td>\n<td style=\"text-align:center\"><strong>新生代</strong>收集器，标记复制</td>\n<td style=\"text-align:center\">CMS的默认新生代收集器，多线程，效率较高</td>\n<td style=\"text-align:center\">无</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Parallel Scavenge</td>\n<td style=\"text-align:center\">stw，并行，吞吐量优先</td>\n<td style=\"text-align:center\">-XX:+UseParallelGC，-XX:MaxGCPauseMillis，-XX:GCTimeRatio，-XX:+UseAdptiveSizePolicy</td>\n<td style=\"text-align:center\"><strong>新生代</strong>并行收集器，标记复制</td>\n<td style=\"text-align:center\">\u001b\u001b多线程，吞吐量优先</td>\n<td style=\"text-align:center\">回收不一定保证能完全回收</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Parallel Old</td>\n<td style=\"text-align:center\">\u001b同上</td>\n<td style=\"text-align:center\">-XX:+UseParallelOldGC</td>\n<td style=\"text-align:center\">老年代\u001b并行收集器，<strong>标记整理</strong></td>\n<td style=\"text-align:center\">同上</td>\n<td style=\"text-align:center\">占用内存比较多</td>\n</tr>\n</tbody>\n</table>\n<p>tip: </p>\n<ol>\n<li>所有的新生代收集器，标记整理</li>\n<li>SerialOld，ParallelOld，标记整理算法（只有这俩能够进行full gc）</li>\n<li>cms，标记\u001b删除</li>\n<li>g1，\u001b整体的标记复制</li>\n</ol>\n<h3 id=\"CMS\"><a href=\"#CMS\" class=\"headerlink\" title=\"CMS\"></a>CMS</h3><p>concurrent mark sweep</p>\n<h4 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><p>老年代\u001b并发收集器，注重\u001b缩短收集时的用户线程的停顿时间</p>\n<h4 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h4><p>-XX:+UseConcMarkSweepGC，-XX:CMSFullGCsBeforeCompaction，-XX:+CMSParallelRemarkEnabled，<br>-XX+UseCMSCompactAtFullCollection-XX:+UseCMSInitiatingOccupancyOnly，-XX:CMSInitiatingOccupancyFraction=70，<br>-XX:CMSInitiatingPermOccupancyFraction，-XX:+CMSIncrementalMode，-XX:+CMSClassUnloadingEnabled</p>\n<h4 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h4><ol>\n<li>初始标记，stw，标记一下Gc Roots能关联到的对象</li>\n<li>并发标记，在和用户线程并发运行的过程中，使用初始标记的结果作为集合去标记\u001b对象</li>\n<li>重新标记，stw，修正并发标记的误差，\u001b因为有些对象可能没有被标记出来，\b时间比初始标记长</li>\n<li>并发清除，回收所有垃圾对象</li>\n</ol>\n<h4 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h4><p>标记清除，会产生内存碎片，但是可以打开标记整理。</p>\n<h4 id=\"触发条件\"><a href=\"#触发条件\" class=\"headerlink\" title=\"触发条件\"></a>触发条件</h4><p>老年代使用率大于CMSInitiatingOccupancyFraction</p>\n<h4 id=\"Concurrent-Mode-Failure\"><a href=\"#Concurrent-Mode-Failure\" class=\"headerlink\" title=\"Concurrent Mode Failure\"></a>Concurrent Mode Failure</h4><ul>\n<li>由于整个时间操作都是比较长的，并且在CMS\b运行过程中,，预留空间不能够满足使用（大小不够或者连续容量不够）</li>\n<li>此时在并发阶段出现ConcurrentModeFailure的情况，CMS会启用<strong>Serial Old</strong>作为backup，配合ParNew去执行FullGC</li>\n<li>cms会\u001b在老年代占用比例超过CMSInitiatingOccupancyFraction的时候进行回收\u001b老年代，发生major\b gc</li>\n<li>major gc的重新标记步骤，<strong>可能会触发一次新生代gc</strong>（根据参数,CMSMaxAbortablePrecleanTime），触发了并且这次新生代gc成功，就会进行重新标记</li>\n<li>触发了\b，但是执行不成功，会转为由Serial Old来进行老年代的回收（完全的stw）<h4 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h4>CMS的优点是，在\u001b老年代是使用到一定的比例就会开始进行老年代的\b回收，并且\u001b回收发生的绝大部分时间之内\b程序都是可以运行的。</li>\n</ul>\n<h3 id=\"G1\"><a href=\"#G1\" class=\"headerlink\" title=\"G1\"></a>G1</h3><h4 id=\"特性\"><a href=\"#特性\" class=\"headerlink\" title=\"特性\"></a>特性</h4><ol>\n<li>更高的回收效率</li>\n<li>更少的内存碎片</li>\n<li>可预测的停顿模型</li>\n</ol>\n<h4 id=\"算法-1\"><a href=\"#算法-1\" class=\"headerlink\" title=\"算法\"></a>算法</h4><p>标记复制算法，小区域的复制，但是大范围上看起来是标记整理，不会产生内存碎片。</p>\n<h4 id=\"介绍-1\"><a href=\"#介绍-1\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><p>将整个堆内存划分成最大2048个区域，年轻代和老年代可能会物理相邻。(region的大小从1MB开始，为2的倍数，最大32MB)。<br>在内存使用率大于InitiatingHeapOccupancyPercent开始进行初始标记，剩余内存小于G1ReservePercent时，进行回收。<br>整个回收的过程可能是young gc，或者是mixed gc。<br>mixed gc回收多少老年代则主要取决于预测模型的决定。<br>预测模型会根据MaxGCPauseMillis来进行决定怎么回收，具体对哪一块进行回收（回收的效益会达到最高）。<br>Humongous对象会直接进入H区，H区的扫描比较简单的。<br>G1的young gc，mixed gc都会stw。  </p>\n<h4 id=\"tip\"><a href=\"#tip\" class=\"headerlink\" title=\"tip\"></a>tip</h4><ol>\n<li>回收过程中发生concurrent mode failure（晋升失败）或者 发生promotion failure，\u001b会启用serial old\u001b来stw做full gc</li>\n<li>mixed gc时候，通常需要也先触发一次young gc，这时候可以复用根扫描这个操作，并且可以大幅度减少需要扫描的对象</li>\n</ol>\n<h4 id=\"回收过程\"><a href=\"#回收过程\" class=\"headerlink\" title=\"回收过程\"></a>回收过程</h4><p><strong>young gc:</strong></p>\n<ol>\n<li>根扫描， 静态和本地对象被扫描</li>\n<li>更新RS，处理dirty card队列更新RS</li>\n<li>处理RS，检测从年轻代指向年老代的对象</li>\n<li>对象拷贝，拷贝存活的对象到survivor/old区域</li>\n<li>处理引用队列，软引用，弱引用，虚引用处理<br>如图：<img src=\"/images/g1内存示意.png\" alt=\"young区域回收\"></li>\n</ol>\n<p><strong>mixed gc:</strong></p>\n<ol>\n<li>初始标记（会复用young gc的标记）</li>\n<li>并发标记</li>\n<li>再次标记</li>\n<li>清除垃圾</li>\n<li>拷贝</li>\n</ol>\n<p><strong>tip</strong></p>\n<ul>\n<li>RS中保存了<code>新生代的哪些对象被老年代引用了</code></li>\n<li>在新生代扫描的过程当中，根扫描是一个比较耗时的工作，引入了remember set，用来记录哪些对象被老年代引用了</li>\n<li>主要还是为了避免扫描整个堆（老年代扫描比较慢）</li>\n</ul>\n<h4 id=\"参数-1\"><a href=\"#参数-1\" class=\"headerlink\" title=\"参数\"></a>参数</h4><p>-XX:UseG1GC,-XX:+UseG1GC,-XX:MaxGCPauseMillis=400,-XX:InitiatingHeapOccupancyPercent=40<br>-XX:SurvivorRatio=1,-XX:MaxTenuringThreshold=15,-XX:G1ReservePercent=15<br>-XX:+UnlockExperimentalVMOptions,-XX:G1NewSizePercent=40,-XX:G1MaxNewSizePercent=80</p>\n<p>Parallel收集器和G1收集器不是在传统的hotspot垃圾收集器框架里面开发的，所以不能配合和其他收集器使用。</p>"},{"title":"happen-before","date":"2018-06-23T07:54:35.000Z","toc":true,"_content":"1. 相互之间有依赖的代码，前面的代码先执行，后面的代码再执行\n2. 锁定规则，lock操作发生在unlock操作之前\n3. volatile变量的读取发生在写入操作之后（storeLoad和storeStore屏障）\n4. A先发生于B，B先发生于C，则A先发生于C\n5. 线程的start方法发生于后续的状态控制方法之前，所有的非stop()方法都发生在stop()方法之前\n6. 线程的interrupt方法发生于检测到中断之前\n7. 线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行\n8. 一个对象的初始化早于finalize之前","source":"_posts/happen-before.md","raw":"---\ntitle: happen-before\ndate: 2018-06-23 15:54:35\ntags: \n- jvm\n- jmm\ncategories:\n- java\n- jvm\ntoc: true\n---\n1. 相互之间有依赖的代码，前面的代码先执行，后面的代码再执行\n2. 锁定规则，lock操作发生在unlock操作之前\n3. volatile变量的读取发生在写入操作之后（storeLoad和storeStore屏障）\n4. A先发生于B，B先发生于C，则A先发生于C\n5. 线程的start方法发生于后续的状态控制方法之前，所有的非stop()方法都发生在stop()方法之前\n6. 线程的interrupt方法发生于检测到中断之前\n7. 线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行\n8. 一个对象的初始化早于finalize之前","slug":"happen-before","published":1,"updated":"2018-06-23T09:54:46.731Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5u1tvl001m1av8u7znswe5","content":"<ol>\n<li>相互之间有依赖的代码，前面的代码先执行，后面的代码再执行</li>\n<li>锁定规则，lock操作发生在unlock操作之前</li>\n<li>volatile变量的读取发生在写入操作之后（storeLoad和storeStore屏障）</li>\n<li>A先发生于B，B先发生于C，则A先发生于C</li>\n<li>线程的start方法发生于后续的状态控制方法之前，所有的非stop()方法都发生在stop()方法之前</li>\n<li>线程的interrupt方法发生于检测到中断之前</li>\n<li>线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行</li>\n<li>一个对象的初始化早于finalize之前</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>相互之间有依赖的代码，前面的代码先执行，后面的代码再执行</li>\n<li>锁定规则，lock操作发生在unlock操作之前</li>\n<li>volatile变量的读取发生在写入操作之后（storeLoad和storeStore屏障）</li>\n<li>A先发生于B，B先发生于C，则A先发生于C</li>\n<li>线程的start方法发生于后续的状态控制方法之前，所有的非stop()方法都发生在stop()方法之前</li>\n<li>线程的interrupt方法发生于检测到中断之前</li>\n<li>线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行</li>\n<li>一个对象的初始化早于finalize之前</li>\n</ol>\n"},{"title":"hello world","author":"chenbin","date":"2018-06-22T11:27:35.000Z","toc":true,"_content":"好久没更新blog了，原有的文章也已经丢失，现在将自己本地积累的传上来。","source":"_posts/hello-world.md","raw":"---\ntitle: hello world\nauthor: chenbin\ndate: 2018-06-22 19:27:35\ntags: \n- 随笔\ncategories:\n- 随笔\ntoc: true\n---\n好久没更新blog了，原有的文章也已经丢失，现在将自己本地积累的传上来。","slug":"hello-world","published":1,"updated":"2018-06-23T09:54:49.932Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5u1tvn001r1av82eq9lzq8","content":"<p>好久没更新blog了，原有的文章也已经丢失，现在将自己本地积累的传上来。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>好久没更新blog了，原有的文章也已经丢失，现在将自己本地积累的传上来。</p>\n"},{"title":"hotspot","date":"2018-06-23T08:13:42.000Z","toc":true,"_content":"![hotspot](/images/hotspot架构.png)\n","source":"_posts/hotspot.md","raw":"---\ntitle: hotspot\ndate: 2018-06-23 16:13:42\ntags:\n- java\n- jvm\ncategories:\n- java\n- jvm\ntoc: true\n---\n![hotspot](/images/hotspot架构.png)\n","slug":"hotspot","published":1,"updated":"2018-06-23T09:54:52.588Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5u1tvp001u1av8tlgocts3","content":"<p><img src=\"/images/hotspot架构.png\" alt=\"hotspot\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/images/hotspot架构.png\" alt=\"hotspot\"></p>\n"},{"title":"instanceof","date":"2018-06-23T08:19:33.000Z","toc":true,"_content":"# instanceof\njavac 有一个INSTANCEOF指令\njvm的实现是，会对每一个对象，有一个主要超类型链（实现为数组，\b深度为7以内的超类），\u001b可能会有一个次要超类型链表（实现为数组，接口，以及深度超过8的超\u001b类)\n\binstanceof会执行一下这两个方法，查找主要超类型和次要超类型链\n下面是hotspot的实现\n```c++\nS.is_subtype_of(T) := {\n  int off = T.offset;\n  if (S == T) return true;\n  if (T == S[off]) return true;\n  if (off != &cache) return false;\n  if ( S.scan_secondary_subtype_array(T) ) {\n    S.cache = T;\n    return true;\n  }\n  return false;\n}\n```\n","source":"_posts/instanceof.md","raw":"---\ntitle: instanceof\ndate: 2018-06-23 16:19:33\ntags:\n- java\n- 基础\n- 关键字\ncategories:\n- java\n- 基础\ntoc: true\n---\n# instanceof\njavac 有一个INSTANCEOF指令\njvm的实现是，会对每一个对象，有一个主要超类型链（实现为数组，\b深度为7以内的超类），\u001b可能会有一个次要超类型链表（实现为数组，接口，以及深度超过8的超\u001b类)\n\binstanceof会执行一下这两个方法，查找主要超类型和次要超类型链\n下面是hotspot的实现\n```c++\nS.is_subtype_of(T) := {\n  int off = T.offset;\n  if (S == T) return true;\n  if (T == S[off]) return true;\n  if (off != &cache) return false;\n  if ( S.scan_secondary_subtype_array(T) ) {\n    S.cache = T;\n    return true;\n  }\n  return false;\n}\n```\n","slug":"instanceof","published":1,"updated":"2018-06-23T09:54:55.891Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5u1tvt001z1av8it10kkqv","content":"<h1 id=\"instanceof\"><a href=\"#instanceof\" class=\"headerlink\" title=\"instanceof\"></a>instanceof</h1><p>javac 有一个INSTANCEOF指令<br>jvm的实现是，会对每一个对象，有一个主要超类型链（实现为数组，\b深度为7以内的超类），\u001b可能会有一个次要超类型链表（实现为数组，接口，以及深度超过8的超\u001b类)<br>\binstanceof会执行一下这两个方法，查找主要超类型和次要超类型链<br>下面是hotspot的实现<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">S.is_subtype_of(T) := &#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> off = T.offset;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (S == T) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (T == S[off]) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (off != &amp;cache) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( S.scan_secondary_subtype_array(T) ) &#123;</span><br><span class=\"line\">    S.cache = T;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"instanceof\"><a href=\"#instanceof\" class=\"headerlink\" title=\"instanceof\"></a>instanceof</h1><p>javac 有一个INSTANCEOF指令<br>jvm的实现是，会对每一个对象，有一个主要超类型链（实现为数组，\b深度为7以内的超类），\u001b可能会有一个次要超类型链表（实现为数组，接口，以及深度超过8的超\u001b类)<br>\binstanceof会执行一下这两个方法，查找主要超类型和次要超类型链<br>下面是hotspot的实现<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">S.is_subtype_of(T) := &#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> off = T.offset;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (S == T) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (T == S[off]) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (off != &amp;cache) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( S.scan_secondary_subtype_array(T) ) &#123;</span><br><span class=\"line\">    S.cache = T;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"io","date":"2018-06-23T08:19:21.000Z","toc":true,"_content":"#### nio:\nnew io，同步非阻塞，底层使用linux的epoll，用于实现一个线程可以同时监听多个channel，基于时间驱动的思想\n用于连接数多，但时间比较短的地方\n\n#### bio：\n阻塞io，同步并阻塞，jdk1.4之前常用，性能较差，一个线程只能操作一个端口，\n\n#### aio\n异步io，异步非阻塞，和bio的区别是数据的操作是异步完成的，当前线程不需要等待，用于连接数目比较多，时间比较长的地方\n\nio中有两个模式reactor模式：\nnetty用nio实现","source":"_posts/io.md","raw":"---\ntitle: io\ndate: 2018-06-23 16:19:21\ntags:\n- java\n- 基础\n- io\ncategories:\n- java\n- 基础\ntoc: true\n---\n#### nio:\nnew io，同步非阻塞，底层使用linux的epoll，用于实现一个线程可以同时监听多个channel，基于时间驱动的思想\n用于连接数多，但时间比较短的地方\n\n#### bio：\n阻塞io，同步并阻塞，jdk1.4之前常用，性能较差，一个线程只能操作一个端口，\n\n#### aio\n异步io，异步非阻塞，和bio的区别是数据的操作是异步完成的，当前线程不需要等待，用于连接数目比较多，时间比较长的地方\n\nio中有两个模式reactor模式：\nnetty用nio实现","slug":"io","published":1,"updated":"2018-06-23T09:55:12.706Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5u1tvv00221av8rllf1ygn","content":"<h4 id=\"nio\"><a href=\"#nio\" class=\"headerlink\" title=\"nio:\"></a>nio:</h4><p>new io，同步非阻塞，底层使用linux的epoll，用于实现一个线程可以同时监听多个channel，基于时间驱动的思想<br>用于连接数多，但时间比较短的地方</p>\n<h4 id=\"bio：\"><a href=\"#bio：\" class=\"headerlink\" title=\"bio：\"></a>bio：</h4><p>阻塞io，同步并阻塞，jdk1.4之前常用，性能较差，一个线程只能操作一个端口，</p>\n<h4 id=\"aio\"><a href=\"#aio\" class=\"headerlink\" title=\"aio\"></a>aio</h4><p>异步io，异步非阻塞，和bio的区别是数据的操作是异步完成的，当前线程不需要等待，用于连接数目比较多，时间比较长的地方</p>\n<p>io中有两个模式reactor模式：<br>netty用nio实现</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"nio\"><a href=\"#nio\" class=\"headerlink\" title=\"nio:\"></a>nio:</h4><p>new io，同步非阻塞，底层使用linux的epoll，用于实现一个线程可以同时监听多个channel，基于时间驱动的思想<br>用于连接数多，但时间比较短的地方</p>\n<h4 id=\"bio：\"><a href=\"#bio：\" class=\"headerlink\" title=\"bio：\"></a>bio：</h4><p>阻塞io，同步并阻塞，jdk1.4之前常用，性能较差，一个线程只能操作一个端口，</p>\n<h4 id=\"aio\"><a href=\"#aio\" class=\"headerlink\" title=\"aio\"></a>aio</h4><p>异步io，异步非阻塞，和bio的区别是数据的操作是异步完成的，当前线程不需要等待，用于连接数目比较多，时间比较长的地方</p>\n<p>io中有两个模式reactor模式：<br>netty用nio实现</p>\n"},{"title":"tcp","date":"2018-06-23T08:19:25.000Z","toc":true,"_content":"\n#### tcp状态\n![tcp状态](/images/tcp状态.gif)\n<!-- more -->\n1. CLOSE_WAIT: \u001b被动关闭的这方，接收到FIN包之后就会进入Close_Wait状态，等待这边相关读写操作都完成(调用socket的close)，才会由CLOSE_WAIT切换到LAST_WAIT状态  \n2. TIME_WAIT：主动关闭的这方会处于\u001bTime_Wait状态，为了防止最后一个ack丢失（\b\b被动方会重新发送FIN包），\b会等待大概4分钟（2msl，maximum segment lifetime）。server端应该减少关闭连接的次数。\n\n#### tip\n1. crawler上面就发现了这个问题\n2. http-1.1使用Connection: keep alive来避免服务器端TIME_WAIT过多的情况\n3. CLOSE_WAIT状态过多避免，被动关闭连接处理不当，没有调用close\u001b()方法，导致过多","source":"_posts/tcp.md","raw":"---\ntitle: tcp\ndate: 2018-06-23 16:19:25\ntags:\n- java\n- 基础\n- tcp\n- 网络\ncategories:\n- java\n- 基础\ntoc: true\n---\n\n#### tcp状态\n![tcp状态](/images/tcp状态.gif)\n<!-- more -->\n1. CLOSE_WAIT: \u001b被动关闭的这方，接收到FIN包之后就会进入Close_Wait状态，等待这边相关读写操作都完成(调用socket的close)，才会由CLOSE_WAIT切换到LAST_WAIT状态  \n2. TIME_WAIT：主动关闭的这方会处于\u001bTime_Wait状态，为了防止最后一个ack丢失（\b\b被动方会重新发送FIN包），\b会等待大概4分钟（2msl，maximum segment lifetime）。server端应该减少关闭连接的次数。\n\n#### tip\n1. crawler上面就发现了这个问题\n2. http-1.1使用Connection: keep alive来避免服务器端TIME_WAIT过多的情况\n3. CLOSE_WAIT状态过多避免，被动关闭连接处理不当，没有调用close\u001b()方法，导致过多","slug":"tcp","published":1,"updated":"2018-06-23T09:55:19.590Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5u1tvy00261av8bjq3tin6","content":"<h4 id=\"tcp状态\"><a href=\"#tcp状态\" class=\"headerlink\" title=\"tcp状态\"></a>tcp状态</h4><p><img src=\"/images/tcp状态.gif\" alt=\"tcp状态\"><br><a id=\"more\"></a></p>\n<ol>\n<li>CLOSE_WAIT: \u001b被动关闭的这方，接收到FIN包之后就会进入Close_Wait状态，等待这边相关读写操作都完成(调用socket的close)，才会由CLOSE_WAIT切换到LAST_WAIT状态  </li>\n<li>TIME_WAIT：主动关闭的这方会处于\u001bTime_Wait状态，为了防止最后一个ack丢失（\b\b被动方会重新发送FIN包），\b会等待大概4分钟（2msl，maximum segment lifetime）。server端应该减少关闭连接的次数。</li>\n</ol>\n<h4 id=\"tip\"><a href=\"#tip\" class=\"headerlink\" title=\"tip\"></a>tip</h4><ol>\n<li>crawler上面就发现了这个问题</li>\n<li>http-1.1使用Connection: keep alive来避免服务器端TIME_WAIT过多的情况</li>\n<li>CLOSE_WAIT状态过多避免，被动关闭连接处理不当，没有调用close\u001b()方法，导致过多</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h4 id=\"tcp状态\"><a href=\"#tcp状态\" class=\"headerlink\" title=\"tcp状态\"></a>tcp状态</h4><p><img src=\"/images/tcp状态.gif\" alt=\"tcp状态\"><br>","more":"</p>\n<ol>\n<li>CLOSE_WAIT: \u001b被动关闭的这方，接收到FIN包之后就会进入Close_Wait状态，等待这边相关读写操作都完成(调用socket的close)，才会由CLOSE_WAIT切换到LAST_WAIT状态  </li>\n<li>TIME_WAIT：主动关闭的这方会处于\u001bTime_Wait状态，为了防止最后一个ack丢失（\b\b被动方会重新发送FIN包），\b会等待大概4分钟（2msl，maximum segment lifetime）。server端应该减少关闭连接的次数。</li>\n</ol>\n<h4 id=\"tip\"><a href=\"#tip\" class=\"headerlink\" title=\"tip\"></a>tip</h4><ol>\n<li>crawler上面就发现了这个问题</li>\n<li>http-1.1使用Connection: keep alive来避免服务器端TIME_WAIT过多的情况</li>\n<li>CLOSE_WAIT状态过多避免，被动关闭连接处理不当，没有调用close\u001b()方法，导致过多</li>\n</ol>"},{"title":"jmm","date":"2018-06-23T07:56:13.000Z","toc":true,"_content":"# 内存区域\n1. 程序计数器\n2. java方法栈\n3. 本地方法栈\n4. 程序计数器\n5. 方法区\n\n# 方法区\n1. 类信息\n2. 常量池\n3. 静态变量\n4. javac编译产生的符号引用，字面量，jit编译优化后的代码\n5. 等等\n\n<!-- more -->\n\n# 常量池\n1. class文件中的常量池，字面量（文本字符串等），符号引用（接口，类，方法，字段名称）\n2. 运行时常量池，编译期（javac编译）生成的各种字面量和符号引用\n3. 全局字符串常量池，StringTable\n\n```java\nString s = new String(\"123\");\nString s2 = s.intern()\n// \"123\"被存储在第一部分常量池中\n// s被存储在堆内存中\n// s2则被存储在StringTable中了\n```\n\n# 永久代变动\n为什么移除永久代\n1. 字符串存储在永久代中，容易溢出\n2. 类相关信息比较难确定大小，容易溢出\n3. 永久代为gc带来了不必要的复杂度，回收效率偏低\n\n## jdk6\n1. 上面的常量池\n2. 类信息（动态的Class对象，Method，Field等对象，**jit编译优化过后的机器码存储在native内存**）\n3. 静态变量\n\n## jdk7\n1. 符号\u001e引用移动到native heap（8中的元数据区）\n2. 字面量移动到java heap（\b包含StringTable）\n3. 静态变量移到java heap\n\n## jdk8\n彻底移除永久代，取而代之产生了MetaSpace\n\n## jmm\n### 主内存和工作内存\n主内存，对标内存，工作内存对标cpu缓存（或者寄存器）。\n### 内存操作指令\n1. read，从主内存传输到工作内存\n2. load，从read回来的数据装载到工作内存中的副本\n3. write，将传输回来的值，写入到主内存\n4. store，从工作内存传输回主内存，供write操作使用\n5. lock，对变量加锁\n6. unlock，对变量解锁\n7. use，使用变量\n8. assign，对变量复制","source":"_posts/jmm.md","raw":"---\ntitle: jmm\ndate: 2018-06-23 15:56:13\ntags: \n- java\n- jvm\n- jmm\ncategories:\n- java\n- jvm\ntoc: true\n---\n# 内存区域\n1. 程序计数器\n2. java方法栈\n3. 本地方法栈\n4. 程序计数器\n5. 方法区\n\n# 方法区\n1. 类信息\n2. 常量池\n3. 静态变量\n4. javac编译产生的符号引用，字面量，jit编译优化后的代码\n5. 等等\n\n<!-- more -->\n\n# 常量池\n1. class文件中的常量池，字面量（文本字符串等），符号引用（接口，类，方法，字段名称）\n2. 运行时常量池，编译期（javac编译）生成的各种字面量和符号引用\n3. 全局字符串常量池，StringTable\n\n```java\nString s = new String(\"123\");\nString s2 = s.intern()\n// \"123\"被存储在第一部分常量池中\n// s被存储在堆内存中\n// s2则被存储在StringTable中了\n```\n\n# 永久代变动\n为什么移除永久代\n1. 字符串存储在永久代中，容易溢出\n2. 类相关信息比较难确定大小，容易溢出\n3. 永久代为gc带来了不必要的复杂度，回收效率偏低\n\n## jdk6\n1. 上面的常量池\n2. 类信息（动态的Class对象，Method，Field等对象，**jit编译优化过后的机器码存储在native内存**）\n3. 静态变量\n\n## jdk7\n1. 符号\u001e引用移动到native heap（8中的元数据区）\n2. 字面量移动到java heap（\b包含StringTable）\n3. 静态变量移到java heap\n\n## jdk8\n彻底移除永久代，取而代之产生了MetaSpace\n\n## jmm\n### 主内存和工作内存\n主内存，对标内存，工作内存对标cpu缓存（或者寄存器）。\n### 内存操作指令\n1. read，从主内存传输到工作内存\n2. load，从read回来的数据装载到工作内存中的副本\n3. write，将传输回来的值，写入到主内存\n4. store，从工作内存传输回主内存，供write操作使用\n5. lock，对变量加锁\n6. unlock，对变量解锁\n7. use，使用变量\n8. assign，对变量复制","slug":"jmm","published":1,"updated":"2018-06-23T09:55:15.005Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5u1tw000281av88w7v0oba","content":"<h1 id=\"内存区域\"><a href=\"#内存区域\" class=\"headerlink\" title=\"内存区域\"></a>内存区域</h1><ol>\n<li>程序计数器</li>\n<li>java方法栈</li>\n<li>本地方法栈</li>\n<li>程序计数器</li>\n<li>方法区</li>\n</ol>\n<h1 id=\"方法区\"><a href=\"#方法区\" class=\"headerlink\" title=\"方法区\"></a>方法区</h1><ol>\n<li>类信息</li>\n<li>常量池</li>\n<li>静态变量</li>\n<li>javac编译产生的符号引用，字面量，jit编译优化后的代码</li>\n<li>等等</li>\n</ol>\n<a id=\"more\"></a>\n<h1 id=\"常量池\"><a href=\"#常量池\" class=\"headerlink\" title=\"常量池\"></a>常量池</h1><ol>\n<li>class文件中的常量池，字面量（文本字符串等），符号引用（接口，类，方法，字段名称）</li>\n<li>运行时常量池，编译期（javac编译）生成的各种字面量和符号引用</li>\n<li>全局字符串常量池，StringTable</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String s = <span class=\"keyword\">new</span> String(<span class=\"string\">\"123\"</span>);</span><br><span class=\"line\">String s2 = s.intern()</span><br><span class=\"line\"><span class=\"comment\">// \"123\"被存储在第一部分常量池中</span></span><br><span class=\"line\"><span class=\"comment\">// s被存储在堆内存中</span></span><br><span class=\"line\"><span class=\"comment\">// s2则被存储在StringTable中了</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"永久代变动\"><a href=\"#永久代变动\" class=\"headerlink\" title=\"永久代变动\"></a>永久代变动</h1><p>为什么移除永久代</p>\n<ol>\n<li>字符串存储在永久代中，容易溢出</li>\n<li>类相关信息比较难确定大小，容易溢出</li>\n<li>永久代为gc带来了不必要的复杂度，回收效率偏低</li>\n</ol>\n<h2 id=\"jdk6\"><a href=\"#jdk6\" class=\"headerlink\" title=\"jdk6\"></a>jdk6</h2><ol>\n<li>上面的常量池</li>\n<li>类信息（动态的Class对象，Method，Field等对象，<strong>jit编译优化过后的机器码存储在native内存</strong>）</li>\n<li>静态变量</li>\n</ol>\n<h2 id=\"jdk7\"><a href=\"#jdk7\" class=\"headerlink\" title=\"jdk7\"></a>jdk7</h2><ol>\n<li>符号\u001e引用移动到native heap（8中的元数据区）</li>\n<li>字面量移动到java heap（\b包含StringTable）</li>\n<li>静态变量移到java heap</li>\n</ol>\n<h2 id=\"jdk8\"><a href=\"#jdk8\" class=\"headerlink\" title=\"jdk8\"></a>jdk8</h2><p>彻底移除永久代，取而代之产生了MetaSpace</p>\n<h2 id=\"jmm\"><a href=\"#jmm\" class=\"headerlink\" title=\"jmm\"></a>jmm</h2><h3 id=\"主内存和工作内存\"><a href=\"#主内存和工作内存\" class=\"headerlink\" title=\"主内存和工作内存\"></a>主内存和工作内存</h3><p>主内存，对标内存，工作内存对标cpu缓存（或者寄存器）。</p>\n<h3 id=\"内存操作指令\"><a href=\"#内存操作指令\" class=\"headerlink\" title=\"内存操作指令\"></a>内存操作指令</h3><ol>\n<li>read，从主内存传输到工作内存</li>\n<li>load，从read回来的数据装载到工作内存中的副本</li>\n<li>write，将传输回来的值，写入到主内存</li>\n<li>store，从工作内存传输回主内存，供write操作使用</li>\n<li>lock，对变量加锁</li>\n<li>unlock，对变量解锁</li>\n<li>use，使用变量</li>\n<li>assign，对变量复制</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h1 id=\"内存区域\"><a href=\"#内存区域\" class=\"headerlink\" title=\"内存区域\"></a>内存区域</h1><ol>\n<li>程序计数器</li>\n<li>java方法栈</li>\n<li>本地方法栈</li>\n<li>程序计数器</li>\n<li>方法区</li>\n</ol>\n<h1 id=\"方法区\"><a href=\"#方法区\" class=\"headerlink\" title=\"方法区\"></a>方法区</h1><ol>\n<li>类信息</li>\n<li>常量池</li>\n<li>静态变量</li>\n<li>javac编译产生的符号引用，字面量，jit编译优化后的代码</li>\n<li>等等</li>\n</ol>","more":"<h1 id=\"常量池\"><a href=\"#常量池\" class=\"headerlink\" title=\"常量池\"></a>常量池</h1><ol>\n<li>class文件中的常量池，字面量（文本字符串等），符号引用（接口，类，方法，字段名称）</li>\n<li>运行时常量池，编译期（javac编译）生成的各种字面量和符号引用</li>\n<li>全局字符串常量池，StringTable</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String s = <span class=\"keyword\">new</span> String(<span class=\"string\">\"123\"</span>);</span><br><span class=\"line\">String s2 = s.intern()</span><br><span class=\"line\"><span class=\"comment\">// \"123\"被存储在第一部分常量池中</span></span><br><span class=\"line\"><span class=\"comment\">// s被存储在堆内存中</span></span><br><span class=\"line\"><span class=\"comment\">// s2则被存储在StringTable中了</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"永久代变动\"><a href=\"#永久代变动\" class=\"headerlink\" title=\"永久代变动\"></a>永久代变动</h1><p>为什么移除永久代</p>\n<ol>\n<li>字符串存储在永久代中，容易溢出</li>\n<li>类相关信息比较难确定大小，容易溢出</li>\n<li>永久代为gc带来了不必要的复杂度，回收效率偏低</li>\n</ol>\n<h2 id=\"jdk6\"><a href=\"#jdk6\" class=\"headerlink\" title=\"jdk6\"></a>jdk6</h2><ol>\n<li>上面的常量池</li>\n<li>类信息（动态的Class对象，Method，Field等对象，<strong>jit编译优化过后的机器码存储在native内存</strong>）</li>\n<li>静态变量</li>\n</ol>\n<h2 id=\"jdk7\"><a href=\"#jdk7\" class=\"headerlink\" title=\"jdk7\"></a>jdk7</h2><ol>\n<li>符号\u001e引用移动到native heap（8中的元数据区）</li>\n<li>字面量移动到java heap（\b包含StringTable）</li>\n<li>静态变量移到java heap</li>\n</ol>\n<h2 id=\"jdk8\"><a href=\"#jdk8\" class=\"headerlink\" title=\"jdk8\"></a>jdk8</h2><p>彻底移除永久代，取而代之产生了MetaSpace</p>\n<h2 id=\"jmm\"><a href=\"#jmm\" class=\"headerlink\" title=\"jmm\"></a>jmm</h2><h3 id=\"主内存和工作内存\"><a href=\"#主内存和工作内存\" class=\"headerlink\" title=\"主内存和工作内存\"></a>主内存和工作内存</h3><p>主内存，对标内存，工作内存对标cpu缓存（或者寄存器）。</p>\n<h3 id=\"内存操作指令\"><a href=\"#内存操作指令\" class=\"headerlink\" title=\"内存操作指令\"></a>内存操作指令</h3><ol>\n<li>read，从主内存传输到工作内存</li>\n<li>load，从read回来的数据装载到工作内存中的副本</li>\n<li>write，将传输回来的值，写入到主内存</li>\n<li>store，从工作内存传输回主内存，供write操作使用</li>\n<li>lock，对变量加锁</li>\n<li>unlock，对变量解锁</li>\n<li>use，使用变量</li>\n<li>assign，对变量复制</li>\n</ol>"},{"title":"synchronized","date":"2018-06-23T07:59:24.000Z","toc":true,"_content":"# 原理\n1. 每个对象其实并不是一把监视器锁，这是一个概念上的误区，只不过是用起来像监视器锁\n2. 主要是monitorEnter，monitorExit实现的\n3. monitorEnter是查看自己能否获取当前\b对象，\u001b根据对象MarkWord来的，如果不能获取，则把自己加入到monitor record链表中，并且park当前线程\n4. monitorExit和AQS类似，释放对象头当中的标记位置，然后唤醒monitor record中的第一个线程\n5. monitorExit不会插入内存屏障\n\n# 详解\n对象头里面包好MarkWord，如下图：\n![\u001bMarkWord](/images/MarkWord.png)\n\n<!-- more -->\n\n# 加锁\n只有**第一个线程**可以成功以偏向锁模式加锁。\n## 偏向锁加锁\n1. 发现锁标志位为00，并且偏向标记为1，并且线程ID为0，即可进行偏向加锁。\n2. 尝试CAS操作对象头，更新为线程ID即可，并且更新进入偏向模式，即成功获取偏向锁。\n\n## 偏向锁唤醒\n1. 发现还是偏向模式，不需要做任何操作。\n2. 非偏向模式，并且存在线程在等待，则唤醒MarkWord中的等待线程。\n\n## 轻量级锁加锁\n1. \b\b发现已经偏向锁模式开启，并且不偏向自己，退出偏向模式。\n2. 已经加锁，那就直接进入重量级锁加锁。\n3. 未加锁，进入轻量级锁加锁模式，将MarkWord拷贝到当前线程栈中作为LockRecord\n4. CAS更新MarkWord为指向LockRecord\n\n## 轻量级锁解锁\n1. 如果MarkWord还保存当前线程的LockRecord指针，则CAS替换为原来的LockRecord\n2. 否则，唤醒当前加锁线程\n\n## 重量解锁加锁\n1. 当前MarkWord是轻量级加锁并且自旋一段时间之后无法获取轻量级锁，则进入重量级锁加锁\n2. 将MarkWord保存到栈，进入重量级锁等待，更新MarkWord为指向重量级锁的指针\n\n## 重量级锁级解锁\n1. 直接唤醒重量级锁对象。\n\n## tip\n1. 偏向锁的存在是为了消除锁以及CAS操作  \n2. 轻量级锁的存在是为了消除重量级锁，并且加入了适应性自旋  \n3. 重量级锁我个人则感觉和`LockSupport.park()`一样的效果","source":"_posts/synchronized.md","raw":"---\ntitle: synchronized\ndate: 2018-06-23 15:59:24\ntags:\n- java\n- jvm\n- 关键字\ncategories:\n- java\n- jvm\ntoc: true\n---\n# 原理\n1. 每个对象其实并不是一把监视器锁，这是一个概念上的误区，只不过是用起来像监视器锁\n2. 主要是monitorEnter，monitorExit实现的\n3. monitorEnter是查看自己能否获取当前\b对象，\u001b根据对象MarkWord来的，如果不能获取，则把自己加入到monitor record链表中，并且park当前线程\n4. monitorExit和AQS类似，释放对象头当中的标记位置，然后唤醒monitor record中的第一个线程\n5. monitorExit不会插入内存屏障\n\n# 详解\n对象头里面包好MarkWord，如下图：\n![\u001bMarkWord](/images/MarkWord.png)\n\n<!-- more -->\n\n# 加锁\n只有**第一个线程**可以成功以偏向锁模式加锁。\n## 偏向锁加锁\n1. 发现锁标志位为00，并且偏向标记为1，并且线程ID为0，即可进行偏向加锁。\n2. 尝试CAS操作对象头，更新为线程ID即可，并且更新进入偏向模式，即成功获取偏向锁。\n\n## 偏向锁唤醒\n1. 发现还是偏向模式，不需要做任何操作。\n2. 非偏向模式，并且存在线程在等待，则唤醒MarkWord中的等待线程。\n\n## 轻量级锁加锁\n1. \b\b发现已经偏向锁模式开启，并且不偏向自己，退出偏向模式。\n2. 已经加锁，那就直接进入重量级锁加锁。\n3. 未加锁，进入轻量级锁加锁模式，将MarkWord拷贝到当前线程栈中作为LockRecord\n4. CAS更新MarkWord为指向LockRecord\n\n## 轻量级锁解锁\n1. 如果MarkWord还保存当前线程的LockRecord指针，则CAS替换为原来的LockRecord\n2. 否则，唤醒当前加锁线程\n\n## 重量解锁加锁\n1. 当前MarkWord是轻量级加锁并且自旋一段时间之后无法获取轻量级锁，则进入重量级锁加锁\n2. 将MarkWord保存到栈，进入重量级锁等待，更新MarkWord为指向重量级锁的指针\n\n## 重量级锁级解锁\n1. 直接唤醒重量级锁对象。\n\n## tip\n1. 偏向锁的存在是为了消除锁以及CAS操作  \n2. 轻量级锁的存在是为了消除重量级锁，并且加入了适应性自旋  \n3. 重量级锁我个人则感觉和`LockSupport.park()`一样的效果","slug":"synchronized","published":1,"updated":"2018-06-23T09:55:17.379Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5u1tw2002d1av8v0xccdy7","content":"<h1 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h1><ol>\n<li>每个对象其实并不是一把监视器锁，这是一个概念上的误区，只不过是用起来像监视器锁</li>\n<li>主要是monitorEnter，monitorExit实现的</li>\n<li>monitorEnter是查看自己能否获取当前\b对象，\u001b根据对象MarkWord来的，如果不能获取，则把自己加入到monitor record链表中，并且park当前线程</li>\n<li>monitorExit和AQS类似，释放对象头当中的标记位置，然后唤醒monitor record中的第一个线程</li>\n<li>monitorExit不会插入内存屏障</li>\n</ol>\n<h1 id=\"详解\"><a href=\"#详解\" class=\"headerlink\" title=\"详解\"></a>详解</h1><p>对象头里面包好MarkWord，如下图：<br><img src=\"/images/MarkWord.png\" alt=\"\u001bMarkWord\"></p>\n<a id=\"more\"></a>\n<h1 id=\"加锁\"><a href=\"#加锁\" class=\"headerlink\" title=\"加锁\"></a>加锁</h1><p>只有<strong>第一个线程</strong>可以成功以偏向锁模式加锁。</p>\n<h2 id=\"偏向锁加锁\"><a href=\"#偏向锁加锁\" class=\"headerlink\" title=\"偏向锁加锁\"></a>偏向锁加锁</h2><ol>\n<li>发现锁标志位为00，并且偏向标记为1，并且线程ID为0，即可进行偏向加锁。</li>\n<li>尝试CAS操作对象头，更新为线程ID即可，并且更新进入偏向模式，即成功获取偏向锁。</li>\n</ol>\n<h2 id=\"偏向锁唤醒\"><a href=\"#偏向锁唤醒\" class=\"headerlink\" title=\"偏向锁唤醒\"></a>偏向锁唤醒</h2><ol>\n<li>发现还是偏向模式，不需要做任何操作。</li>\n<li>非偏向模式，并且存在线程在等待，则唤醒MarkWord中的等待线程。</li>\n</ol>\n<h2 id=\"轻量级锁加锁\"><a href=\"#轻量级锁加锁\" class=\"headerlink\" title=\"轻量级锁加锁\"></a>轻量级锁加锁</h2><ol>\n<li>\b\b发现已经偏向锁模式开启，并且不偏向自己，退出偏向模式。</li>\n<li>已经加锁，那就直接进入重量级锁加锁。</li>\n<li>未加锁，进入轻量级锁加锁模式，将MarkWord拷贝到当前线程栈中作为LockRecord</li>\n<li>CAS更新MarkWord为指向LockRecord</li>\n</ol>\n<h2 id=\"轻量级锁解锁\"><a href=\"#轻量级锁解锁\" class=\"headerlink\" title=\"轻量级锁解锁\"></a>轻量级锁解锁</h2><ol>\n<li>如果MarkWord还保存当前线程的LockRecord指针，则CAS替换为原来的LockRecord</li>\n<li>否则，唤醒当前加锁线程</li>\n</ol>\n<h2 id=\"重量解锁加锁\"><a href=\"#重量解锁加锁\" class=\"headerlink\" title=\"重量解锁加锁\"></a>重量解锁加锁</h2><ol>\n<li>当前MarkWord是轻量级加锁并且自旋一段时间之后无法获取轻量级锁，则进入重量级锁加锁</li>\n<li>将MarkWord保存到栈，进入重量级锁等待，更新MarkWord为指向重量级锁的指针</li>\n</ol>\n<h2 id=\"重量级锁级解锁\"><a href=\"#重量级锁级解锁\" class=\"headerlink\" title=\"重量级锁级解锁\"></a>重量级锁级解锁</h2><ol>\n<li>直接唤醒重量级锁对象。</li>\n</ol>\n<h2 id=\"tip\"><a href=\"#tip\" class=\"headerlink\" title=\"tip\"></a>tip</h2><ol>\n<li>偏向锁的存在是为了消除锁以及CAS操作  </li>\n<li>轻量级锁的存在是为了消除重量级锁，并且加入了适应性自旋  </li>\n<li>重量级锁我个人则感觉和<code>LockSupport.park()</code>一样的效果</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h1 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h1><ol>\n<li>每个对象其实并不是一把监视器锁，这是一个概念上的误区，只不过是用起来像监视器锁</li>\n<li>主要是monitorEnter，monitorExit实现的</li>\n<li>monitorEnter是查看自己能否获取当前\b对象，\u001b根据对象MarkWord来的，如果不能获取，则把自己加入到monitor record链表中，并且park当前线程</li>\n<li>monitorExit和AQS类似，释放对象头当中的标记位置，然后唤醒monitor record中的第一个线程</li>\n<li>monitorExit不会插入内存屏障</li>\n</ol>\n<h1 id=\"详解\"><a href=\"#详解\" class=\"headerlink\" title=\"详解\"></a>详解</h1><p>对象头里面包好MarkWord，如下图：<br><img src=\"/images/MarkWord.png\" alt=\"\u001bMarkWord\"></p>","more":"<h1 id=\"加锁\"><a href=\"#加锁\" class=\"headerlink\" title=\"加锁\"></a>加锁</h1><p>只有<strong>第一个线程</strong>可以成功以偏向锁模式加锁。</p>\n<h2 id=\"偏向锁加锁\"><a href=\"#偏向锁加锁\" class=\"headerlink\" title=\"偏向锁加锁\"></a>偏向锁加锁</h2><ol>\n<li>发现锁标志位为00，并且偏向标记为1，并且线程ID为0，即可进行偏向加锁。</li>\n<li>尝试CAS操作对象头，更新为线程ID即可，并且更新进入偏向模式，即成功获取偏向锁。</li>\n</ol>\n<h2 id=\"偏向锁唤醒\"><a href=\"#偏向锁唤醒\" class=\"headerlink\" title=\"偏向锁唤醒\"></a>偏向锁唤醒</h2><ol>\n<li>发现还是偏向模式，不需要做任何操作。</li>\n<li>非偏向模式，并且存在线程在等待，则唤醒MarkWord中的等待线程。</li>\n</ol>\n<h2 id=\"轻量级锁加锁\"><a href=\"#轻量级锁加锁\" class=\"headerlink\" title=\"轻量级锁加锁\"></a>轻量级锁加锁</h2><ol>\n<li>\b\b发现已经偏向锁模式开启，并且不偏向自己，退出偏向模式。</li>\n<li>已经加锁，那就直接进入重量级锁加锁。</li>\n<li>未加锁，进入轻量级锁加锁模式，将MarkWord拷贝到当前线程栈中作为LockRecord</li>\n<li>CAS更新MarkWord为指向LockRecord</li>\n</ol>\n<h2 id=\"轻量级锁解锁\"><a href=\"#轻量级锁解锁\" class=\"headerlink\" title=\"轻量级锁解锁\"></a>轻量级锁解锁</h2><ol>\n<li>如果MarkWord还保存当前线程的LockRecord指针，则CAS替换为原来的LockRecord</li>\n<li>否则，唤醒当前加锁线程</li>\n</ol>\n<h2 id=\"重量解锁加锁\"><a href=\"#重量解锁加锁\" class=\"headerlink\" title=\"重量解锁加锁\"></a>重量解锁加锁</h2><ol>\n<li>当前MarkWord是轻量级加锁并且自旋一段时间之后无法获取轻量级锁，则进入重量级锁加锁</li>\n<li>将MarkWord保存到栈，进入重量级锁等待，更新MarkWord为指向重量级锁的指针</li>\n</ol>\n<h2 id=\"重量级锁级解锁\"><a href=\"#重量级锁级解锁\" class=\"headerlink\" title=\"重量级锁级解锁\"></a>重量级锁级解锁</h2><ol>\n<li>直接唤醒重量级锁对象。</li>\n</ol>\n<h2 id=\"tip\"><a href=\"#tip\" class=\"headerlink\" title=\"tip\"></a>tip</h2><ol>\n<li>偏向锁的存在是为了消除锁以及CAS操作  </li>\n<li>轻量级锁的存在是为了消除重量级锁，并且加入了适应性自旋  </li>\n<li>重量级锁我个人则感觉和<code>LockSupport.park()</code>一样的效果</li>\n</ol>"},{"title":"分布式理论","date":"2018-06-24T08:03:45.000Z","catrgories":["分布式"],"toc":true,"_content":"#### CAP\nconsistency，availbility，partion tolerance，通常是cp，或者ap\n#### BASE\nBasic Available，Soft State，Eventually consistency\n<!-- more -->\n\n#### 2pc\n先发送prepare请求，参与者都回复ok，则进行提交，某个参与者不ok，则进行全局回滚。\n\n#### tcc\n1. try阶段，业务系统做检测，以及资源预留\n2. Confirm阶段，对业务系统做提交确认（默认confrim阶段不会出错）\n3. Cancel阶段，主要是Confirm阶段执行错误，回滚更改，资源释放\n\n转账例子：\n1. try阶段，把A和B的账户冻结\n2. confirm阶段，A中扣钱，再转给B，并且完成之后会释放资源\n3. cancel阶段，如果confirm中转账失败，则调用远程的cancel方法\ntcc是一种业务的补偿，不是数据库底层的支持。\n\n#### 分布式一致性\n1. gossip，Cassandra使用\n2. paxos，zk，ob使用","source":"_posts/分布式理论.md","raw":"---\ntitle: 分布式理论\ndate: 2018-06-24 16:03:45\ntags:\n- 分布式\ncatrgories:\n- 分布式\ntoc: true\n---\n#### CAP\nconsistency，availbility，partion tolerance，通常是cp，或者ap\n#### BASE\nBasic Available，Soft State，Eventually consistency\n<!-- more -->\n\n#### 2pc\n先发送prepare请求，参与者都回复ok，则进行提交，某个参与者不ok，则进行全局回滚。\n\n#### tcc\n1. try阶段，业务系统做检测，以及资源预留\n2. Confirm阶段，对业务系统做提交确认（默认confrim阶段不会出错）\n3. Cancel阶段，主要是Confirm阶段执行错误，回滚更改，资源释放\n\n转账例子：\n1. try阶段，把A和B的账户冻结\n2. confirm阶段，A中扣钱，再转给B，并且完成之后会释放资源\n3. cancel阶段，如果confirm中转账失败，则调用远程的cancel方法\ntcc是一种业务的补偿，不是数据库底层的支持。\n\n#### 分布式一致性\n1. gossip，Cassandra使用\n2. paxos，zk，ob使用","slug":"分布式理论","published":1,"updated":"2018-06-24T08:12:39.305Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5u1tw5002g1av8dqtmm0hf","content":"<h4 id=\"CAP\"><a href=\"#CAP\" class=\"headerlink\" title=\"CAP\"></a>CAP</h4><p>consistency，availbility，partion tolerance，通常是cp，或者ap</p>\n<h4 id=\"BASE\"><a href=\"#BASE\" class=\"headerlink\" title=\"BASE\"></a>BASE</h4><p>Basic Available，Soft State，Eventually consistency<br><a id=\"more\"></a></p>\n<h4 id=\"2pc\"><a href=\"#2pc\" class=\"headerlink\" title=\"2pc\"></a>2pc</h4><p>先发送prepare请求，参与者都回复ok，则进行提交，某个参与者不ok，则进行全局回滚。</p>\n<h4 id=\"tcc\"><a href=\"#tcc\" class=\"headerlink\" title=\"tcc\"></a>tcc</h4><ol>\n<li>try阶段，业务系统做检测，以及资源预留</li>\n<li>Confirm阶段，对业务系统做提交确认（默认confrim阶段不会出错）</li>\n<li>Cancel阶段，主要是Confirm阶段执行错误，回滚更改，资源释放</li>\n</ol>\n<p>转账例子：</p>\n<ol>\n<li>try阶段，把A和B的账户冻结</li>\n<li>confirm阶段，A中扣钱，再转给B，并且完成之后会释放资源</li>\n<li>cancel阶段，如果confirm中转账失败，则调用远程的cancel方法<br>tcc是一种业务的补偿，不是数据库底层的支持。</li>\n</ol>\n<h4 id=\"分布式一致性\"><a href=\"#分布式一致性\" class=\"headerlink\" title=\"分布式一致性\"></a>分布式一致性</h4><ol>\n<li>gossip，Cassandra使用</li>\n<li>paxos，zk，ob使用</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h4 id=\"CAP\"><a href=\"#CAP\" class=\"headerlink\" title=\"CAP\"></a>CAP</h4><p>consistency，availbility，partion tolerance，通常是cp，或者ap</p>\n<h4 id=\"BASE\"><a href=\"#BASE\" class=\"headerlink\" title=\"BASE\"></a>BASE</h4><p>Basic Available，Soft State，Eventually consistency<br>","more":"</p>\n<h4 id=\"2pc\"><a href=\"#2pc\" class=\"headerlink\" title=\"2pc\"></a>2pc</h4><p>先发送prepare请求，参与者都回复ok，则进行提交，某个参与者不ok，则进行全局回滚。</p>\n<h4 id=\"tcc\"><a href=\"#tcc\" class=\"headerlink\" title=\"tcc\"></a>tcc</h4><ol>\n<li>try阶段，业务系统做检测，以及资源预留</li>\n<li>Confirm阶段，对业务系统做提交确认（默认confrim阶段不会出错）</li>\n<li>Cancel阶段，主要是Confirm阶段执行错误，回滚更改，资源释放</li>\n</ol>\n<p>转账例子：</p>\n<ol>\n<li>try阶段，把A和B的账户冻结</li>\n<li>confirm阶段，A中扣钱，再转给B，并且完成之后会释放资源</li>\n<li>cancel阶段，如果confirm中转账失败，则调用远程的cancel方法<br>tcc是一种业务的补偿，不是数据库底层的支持。</li>\n</ol>\n<h4 id=\"分布式一致性\"><a href=\"#分布式一致性\" class=\"headerlink\" title=\"分布式一致性\"></a>分布式一致性</h4><ol>\n<li>gossip，Cassandra使用</li>\n<li>paxos，zk，ob使用</li>\n</ol>"},{"title":"代码优化.md","date":"2018-06-23T08:03:02.000Z","toc":true,"_content":"java代码执行过程中，主要分为以下三块优化：\n1. javac优化(词法分析，分词；\b语法分析，用法是否正确；语义分析，代码到底是什么含义)\n   ![](/images/javac流程.gif)\n<!-- more -->\n2. jit优化，just in time compilation\n   ![](/images/jit流程.gif)\n3. cpu优化，重排序等等\n\nlombok的原理是在语义分析完成生成语法树之后，\b修改了生成后的语法树","source":"_posts/代码优化.md","raw":"---\ntitle: 代码优化.md\ndate: 2018-06-23 16:03:02\ntags:\n- java\n- jvm\n- jit\ncategories:\n- java\n- jvm\ntoc: true\n---\njava代码执行过程中，主要分为以下三块优化：\n1. javac优化(词法分析，分词；\b语法分析，用法是否正确；语义分析，代码到底是什么含义)\n   ![](/images/javac流程.gif)\n<!-- more -->\n2. jit优化，just in time compilation\n   ![](/images/jit流程.gif)\n3. cpu优化，重排序等等\n\nlombok的原理是在语义分析完成生成语法树之后，\b修改了生成后的语法树","slug":"代码优化","published":1,"updated":"2018-06-23T09:55:22.096Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5u1tw7002k1av8iqu3uc0z","content":"<p>java代码执行过程中，主要分为以下三块优化：</p>\n<ol>\n<li>javac优化(词法分析，分词；\b语法分析，用法是否正确；语义分析，代码到底是什么含义)<br><img src=\"/images/javac流程.gif\" alt=\"\"><a id=\"more\"></a></li>\n<li>jit优化，just in time compilation<br><img src=\"/images/jit流程.gif\" alt=\"\"></li>\n<li>cpu优化，重排序等等</li>\n</ol>\n<p>lombok的原理是在语义分析完成生成语法树之后，\b修改了生成后的语法树</p>\n","site":{"data":{}},"excerpt":"<p>java代码执行过程中，主要分为以下三块优化：</p>\n<ol>\n<li>javac优化(词法分析，分词；\b语法分析，用法是否正确；语义分析，代码到底是什么含义)<br><img src=\"/images/javac流程.gif\" alt=\"\">","more":"</li>\n<li>jit优化，just in time compilation<br><img src=\"/images/jit流程.gif\" alt=\"\"></li>\n<li>cpu优化，重排序等等</li>\n</ol>\n<p>lombok的原理是在语义分析完成生成语法树之后，\b修改了生成后的语法树</p>"},{"title":"分布式锁","date":"2018-06-24T08:04:56.000Z","toc":true,"_content":"#### 数据库锁\nselect for update\n##### 优点\n1. 借助数据库行锁机制容易理解\n2. 宕机自动释放\n\n##### 缺点\n1. 性能不高\n2. 不支持重入\n3. 长时间占有锁可能会导致连接池打爆\n4. 并不一定是锁行，如果表比较小的情况下，可能会直接锁表\n<!-- more -->\n\n#### redis\nkey -> 主机id + 线程id + 重入数量，随便添加一个过期时间\n判断一下前面是否相同\nredisson通过lua脚本，完成以上功能，然后应该是利用redis的key notification功能\n##### 优点\n1. 单次加锁性能好\n2. 实现起来方便\n\n##### 缺点\n1. 超时控制锁的释放有问题，不能宕机自动释放\n\n#### zookeeper\n利用zk的临时节点的特性，在某个目录下面生成瞬时有序的临时节点，然后判断下节点是否是最小的。释放时候，只要将当前节点删除即可。\n##### 优点\n1. 锁可以自动释放，客户端断开连接，临时节点会自动删除\n2. 可以利用zk的监听机制，实现阻塞锁\n3. 可重入，将当前线程信息写入到节点中\n4. zk集群部署，避免单点问题\n##### 缺点\n1. 性能不如redis\n\n可靠性\nzk > redis > mysql\n\n性能\nredis > zk > mysql\n\n实现难度\nmysql > redis > zk","source":"_posts/分布式锁.md","raw":"---\ntitle: 分布式锁\ndate: 2018-06-24 16:04:56\ntags:\n- 分布式\n- 锁\ncategories:\n- 分布式\ntoc: true\n---\n#### 数据库锁\nselect for update\n##### 优点\n1. 借助数据库行锁机制容易理解\n2. 宕机自动释放\n\n##### 缺点\n1. 性能不高\n2. 不支持重入\n3. 长时间占有锁可能会导致连接池打爆\n4. 并不一定是锁行，如果表比较小的情况下，可能会直接锁表\n<!-- more -->\n\n#### redis\nkey -> 主机id + 线程id + 重入数量，随便添加一个过期时间\n判断一下前面是否相同\nredisson通过lua脚本，完成以上功能，然后应该是利用redis的key notification功能\n##### 优点\n1. 单次加锁性能好\n2. 实现起来方便\n\n##### 缺点\n1. 超时控制锁的释放有问题，不能宕机自动释放\n\n#### zookeeper\n利用zk的临时节点的特性，在某个目录下面生成瞬时有序的临时节点，然后判断下节点是否是最小的。释放时候，只要将当前节点删除即可。\n##### 优点\n1. 锁可以自动释放，客户端断开连接，临时节点会自动删除\n2. 可以利用zk的监听机制，实现阻塞锁\n3. 可重入，将当前线程信息写入到节点中\n4. zk集群部署，避免单点问题\n##### 缺点\n1. 性能不如redis\n\n可靠性\nzk > redis > mysql\n\n性能\nredis > zk > mysql\n\n实现难度\nmysql > redis > zk","slug":"分布式锁","published":1,"updated":"2018-06-24T08:13:34.320Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5u1tw9002m1av8l3w2cd9n","content":"<h4 id=\"数据库锁\"><a href=\"#数据库锁\" class=\"headerlink\" title=\"数据库锁\"></a>数据库锁</h4><p>select for update</p>\n<h5 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h5><ol>\n<li>借助数据库行锁机制容易理解</li>\n<li>宕机自动释放</li>\n</ol>\n<h5 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5><ol>\n<li>性能不高</li>\n<li>不支持重入</li>\n<li>长时间占有锁可能会导致连接池打爆</li>\n<li>并不一定是锁行，如果表比较小的情况下，可能会直接锁表<a id=\"more\"></a>\n</li>\n</ol>\n<h4 id=\"redis\"><a href=\"#redis\" class=\"headerlink\" title=\"redis\"></a>redis</h4><p>key -&gt; 主机id + 线程id + 重入数量，随便添加一个过期时间<br>判断一下前面是否相同<br>redisson通过lua脚本，完成以上功能，然后应该是利用redis的key notification功能</p>\n<h5 id=\"优点-1\"><a href=\"#优点-1\" class=\"headerlink\" title=\"优点\"></a>优点</h5><ol>\n<li>单次加锁性能好</li>\n<li>实现起来方便</li>\n</ol>\n<h5 id=\"缺点-1\"><a href=\"#缺点-1\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5><ol>\n<li>超时控制锁的释放有问题，不能宕机自动释放</li>\n</ol>\n<h4 id=\"zookeeper\"><a href=\"#zookeeper\" class=\"headerlink\" title=\"zookeeper\"></a>zookeeper</h4><p>利用zk的临时节点的特性，在某个目录下面生成瞬时有序的临时节点，然后判断下节点是否是最小的。释放时候，只要将当前节点删除即可。</p>\n<h5 id=\"优点-2\"><a href=\"#优点-2\" class=\"headerlink\" title=\"优点\"></a>优点</h5><ol>\n<li>锁可以自动释放，客户端断开连接，临时节点会自动删除</li>\n<li>可以利用zk的监听机制，实现阻塞锁</li>\n<li>可重入，将当前线程信息写入到节点中</li>\n<li>zk集群部署，避免单点问题<h5 id=\"缺点-2\"><a href=\"#缺点-2\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5></li>\n<li>性能不如redis</li>\n</ol>\n<p>可靠性<br>zk &gt; redis &gt; mysql</p>\n<p>性能<br>redis &gt; zk &gt; mysql</p>\n<p>实现难度<br>mysql &gt; redis &gt; zk</p>\n","site":{"data":{}},"excerpt":"<h4 id=\"数据库锁\"><a href=\"#数据库锁\" class=\"headerlink\" title=\"数据库锁\"></a>数据库锁</h4><p>select for update</p>\n<h5 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h5><ol>\n<li>借助数据库行锁机制容易理解</li>\n<li>宕机自动释放</li>\n</ol>\n<h5 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5><ol>\n<li>性能不高</li>\n<li>不支持重入</li>\n<li>长时间占有锁可能会导致连接池打爆</li>\n<li>并不一定是锁行，如果表比较小的情况下，可能会直接锁表","more":"</li>\n</ol>\n<h4 id=\"redis\"><a href=\"#redis\" class=\"headerlink\" title=\"redis\"></a>redis</h4><p>key -&gt; 主机id + 线程id + 重入数量，随便添加一个过期时间<br>判断一下前面是否相同<br>redisson通过lua脚本，完成以上功能，然后应该是利用redis的key notification功能</p>\n<h5 id=\"优点-1\"><a href=\"#优点-1\" class=\"headerlink\" title=\"优点\"></a>优点</h5><ol>\n<li>单次加锁性能好</li>\n<li>实现起来方便</li>\n</ol>\n<h5 id=\"缺点-1\"><a href=\"#缺点-1\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5><ol>\n<li>超时控制锁的释放有问题，不能宕机自动释放</li>\n</ol>\n<h4 id=\"zookeeper\"><a href=\"#zookeeper\" class=\"headerlink\" title=\"zookeeper\"></a>zookeeper</h4><p>利用zk的临时节点的特性，在某个目录下面生成瞬时有序的临时节点，然后判断下节点是否是最小的。释放时候，只要将当前节点删除即可。</p>\n<h5 id=\"优点-2\"><a href=\"#优点-2\" class=\"headerlink\" title=\"优点\"></a>优点</h5><ol>\n<li>锁可以自动释放，客户端断开连接，临时节点会自动删除</li>\n<li>可以利用zk的监听机制，实现阻塞锁</li>\n<li>可重入，将当前线程信息写入到节点中</li>\n<li>zk集群部署，避免单点问题<h5 id=\"缺点-2\"><a href=\"#缺点-2\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5></li>\n<li>性能不如redis</li>\n</ol>\n<p>可靠性<br>zk &gt; redis &gt; mysql</p>\n<p>性能<br>redis &gt; zk &gt; mysql</p>\n<p>实现难度<br>mysql &gt; redis &gt; zk</p>"},{"title":"微服务","date":"2018-06-24T08:06:15.000Z","toc":true,"_content":"# kubernetes\n容器集群管理工具，容器管理的标准\n1. master 进程，kubectl\n2. node 进程，kubelet\n3. proxy 进程，kube-proxy\n4. etcd 进程，注册中心\n<!-- more -->\n\n为什么需要微服务？\n早期系统，所有的开发都是在一个系统中开发的，造成了不良影响。\n1. 学习上，成本过大，学习曲线陡峭，需要完整的了解所有的业务逻辑才可以。\n2. 开发上，开发周期比较长，各模块代码耦合，功能没办法拆解的很细\n3. 测试上，测试难度也会加大，因为功能都是一起上线的\n4. 运维上，上线风险大大加强，要上就要一起上\n5. 系统上，可拓展性低下，性能比较差，风险大大加强，属于要挂大家一起挂的地步\n6. 管理上，管理起来比较麻烦，需要有一个人或者多个人精通所有的业务逻辑","source":"_posts/微服务.md","raw":"---\ntitle: 微服务\ndate: 2018-06-24 16:06:15\ntags:\n- 分布式\n- 微服务\ncategories:\n- 分布式\n- 微服务\ntoc: true\n---\n# kubernetes\n容器集群管理工具，容器管理的标准\n1. master 进程，kubectl\n2. node 进程，kubelet\n3. proxy 进程，kube-proxy\n4. etcd 进程，注册中心\n<!-- more -->\n\n为什么需要微服务？\n早期系统，所有的开发都是在一个系统中开发的，造成了不良影响。\n1. 学习上，成本过大，学习曲线陡峭，需要完整的了解所有的业务逻辑才可以。\n2. 开发上，开发周期比较长，各模块代码耦合，功能没办法拆解的很细\n3. 测试上，测试难度也会加大，因为功能都是一起上线的\n4. 运维上，上线风险大大加强，要上就要一起上\n5. 系统上，可拓展性低下，性能比较差，风险大大加强，属于要挂大家一起挂的地步\n6. 管理上，管理起来比较麻烦，需要有一个人或者多个人精通所有的业务逻辑","slug":"微服务","published":1,"updated":"2018-06-24T08:08:22.387Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5u1twb002q1av8xww3f68i","content":"<h1 id=\"kubernetes\"><a href=\"#kubernetes\" class=\"headerlink\" title=\"kubernetes\"></a>kubernetes</h1><p>容器集群管理工具，容器管理的标准</p>\n<ol>\n<li>master 进程，kubectl</li>\n<li>node 进程，kubelet</li>\n<li>proxy 进程，kube-proxy</li>\n<li>etcd 进程，注册中心<a id=\"more\"></a>\n</li>\n</ol>\n<p>为什么需要微服务？<br>早期系统，所有的开发都是在一个系统中开发的，造成了不良影响。</p>\n<ol>\n<li>学习上，成本过大，学习曲线陡峭，需要完整的了解所有的业务逻辑才可以。</li>\n<li>开发上，开发周期比较长，各模块代码耦合，功能没办法拆解的很细</li>\n<li>测试上，测试难度也会加大，因为功能都是一起上线的</li>\n<li>运维上，上线风险大大加强，要上就要一起上</li>\n<li>系统上，可拓展性低下，性能比较差，风险大大加强，属于要挂大家一起挂的地步</li>\n<li>管理上，管理起来比较麻烦，需要有一个人或者多个人精通所有的业务逻辑</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h1 id=\"kubernetes\"><a href=\"#kubernetes\" class=\"headerlink\" title=\"kubernetes\"></a>kubernetes</h1><p>容器集群管理工具，容器管理的标准</p>\n<ol>\n<li>master 进程，kubectl</li>\n<li>node 进程，kubelet</li>\n<li>proxy 进程，kube-proxy</li>\n<li>etcd 进程，注册中心","more":"</li>\n</ol>\n<p>为什么需要微服务？<br>早期系统，所有的开发都是在一个系统中开发的，造成了不良影响。</p>\n<ol>\n<li>学习上，成本过大，学习曲线陡峭，需要完整的了解所有的业务逻辑才可以。</li>\n<li>开发上，开发周期比较长，各模块代码耦合，功能没办法拆解的很细</li>\n<li>测试上，测试难度也会加大，因为功能都是一起上线的</li>\n<li>运维上，上线风险大大加强，要上就要一起上</li>\n<li>系统上，可拓展性低下，性能比较差，风险大大加强，属于要挂大家一起挂的地步</li>\n<li>管理上，管理起来比较麻烦，需要有一个人或者多个人精通所有的业务逻辑</li>\n</ol>"},{"title":"包装类型","date":"2018-06-23T08:19:40.000Z","toc":true,"_content":"## IntegerCache\n1. 范围：  \n从-128到127（最大），可配置(≤127)\n2. 使用方式：  \n`Integer a = 12;` ----> 被编译成 `Integer a = Integer.valueOf(12)`\n3. 优化点   \n少用`new Integer(n)`，多使用`Integer.valueOf`\n\n## CharacterCache\n1. 范围：\n从0~127，不可配置，其余同上","source":"_posts/包装类型.md","raw":"---\ntitle: 包装类型\ndate: 2018-06-23 16:19:40\ntags:\n- java\n- 基础\ncategories:\n- java\n- 基础\ntoc: true\n---\n## IntegerCache\n1. 范围：  \n从-128到127（最大），可配置(≤127)\n2. 使用方式：  \n`Integer a = 12;` ----> 被编译成 `Integer a = Integer.valueOf(12)`\n3. 优化点   \n少用`new Integer(n)`，多使用`Integer.valueOf`\n\n## CharacterCache\n1. 范围：\n从0~127，不可配置，其余同上","slug":"包装类型","published":1,"updated":"2018-06-23T09:55:24.327Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5u1twd002t1av8w4wzdf56","content":"<h2 id=\"IntegerCache\"><a href=\"#IntegerCache\" class=\"headerlink\" title=\"IntegerCache\"></a>IntegerCache</h2><ol>\n<li>范围：<br>从-128到127（最大），可配置(≤127)</li>\n<li>使用方式：<br><code>Integer a = 12;</code> —-&gt; 被编译成 <code>Integer a = Integer.valueOf(12)</code></li>\n<li>优化点<br>少用<code>new Integer(n)</code>，多使用<code>Integer.valueOf</code></li>\n</ol>\n<h2 id=\"CharacterCache\"><a href=\"#CharacterCache\" class=\"headerlink\" title=\"CharacterCache\"></a>CharacterCache</h2><ol>\n<li>范围：<br>从0~127，不可配置，其余同上</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"IntegerCache\"><a href=\"#IntegerCache\" class=\"headerlink\" title=\"IntegerCache\"></a>IntegerCache</h2><ol>\n<li>范围：<br>从-128到127（最大），可配置(≤127)</li>\n<li>使用方式：<br><code>Integer a = 12;</code> —-&gt; 被编译成 <code>Integer a = Integer.valueOf(12)</code></li>\n<li>优化点<br>少用<code>new Integer(n)</code>，多使用<code>Integer.valueOf</code></li>\n</ol>\n<h2 id=\"CharacterCache\"><a href=\"#CharacterCache\" class=\"headerlink\" title=\"CharacterCache\"></a>CharacterCache</h2><ol>\n<li>范围：<br>从0~127，不可配置，其余同上</li>\n</ol>\n"},{"title":"攻击防范","date":"2018-06-23T08:19:56.000Z","toc":true,"_content":"# XSS\ncross site scripting，跨站脚本攻击\n这是一种方法，通常所说的网页挂马\n用于评论时将脚本输入进去，网站展示的时候，没有做转义处理，对访问页面的用户造成恶略影响。\n\n# CSRF\ncross site request forgery，跨站请求伪造\n这是一种攻击结果\n通过XSS，我们可以进行CSRF，然后偷偷访问其他网站，或者操作用户财产。\n\n<!-- more -->\n\n# Hash碰撞\n1. hashCode算法问题\n2. 通过制造出一模一样的hashCode的数据，攻击网站。\n3. String的hashCode算法数学表达式是`Hash = Hash * 31 + val[i]`。\n4. 通过这个算式可以反推，从而攻击服务器，让服务器CPU打满。\n\n# DDOS\n拒绝服务攻击，通过控制大量肉鸡，模拟用户请求访问目标网站，拖垮对方网站的服务。","source":"_posts/攻击防范.md","raw":"---\ntitle: 攻击防范\ndate: 2018-06-23 16:19:56\ntags:\n- java\n- 基础\n- 攻击\ncategories:\n- java\n- 基础\ntoc: true\n---\n# XSS\ncross site scripting，跨站脚本攻击\n这是一种方法，通常所说的网页挂马\n用于评论时将脚本输入进去，网站展示的时候，没有做转义处理，对访问页面的用户造成恶略影响。\n\n# CSRF\ncross site request forgery，跨站请求伪造\n这是一种攻击结果\n通过XSS，我们可以进行CSRF，然后偷偷访问其他网站，或者操作用户财产。\n\n<!-- more -->\n\n# Hash碰撞\n1. hashCode算法问题\n2. 通过制造出一模一样的hashCode的数据，攻击网站。\n3. String的hashCode算法数学表达式是`Hash = Hash * 31 + val[i]`。\n4. 通过这个算式可以反推，从而攻击服务器，让服务器CPU打满。\n\n# DDOS\n拒绝服务攻击，通过控制大量肉鸡，模拟用户请求访问目标网站，拖垮对方网站的服务。","slug":"攻击防范","published":1,"updated":"2018-06-23T09:55:27.130Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5u1twf002y1av83m52y3ue","content":"<h1 id=\"XSS\"><a href=\"#XSS\" class=\"headerlink\" title=\"XSS\"></a>XSS</h1><p>cross site scripting，跨站脚本攻击<br>这是一种方法，通常所说的网页挂马<br>用于评论时将脚本输入进去，网站展示的时候，没有做转义处理，对访问页面的用户造成恶略影响。</p>\n<h1 id=\"CSRF\"><a href=\"#CSRF\" class=\"headerlink\" title=\"CSRF\"></a>CSRF</h1><p>cross site request forgery，跨站请求伪造<br>这是一种攻击结果<br>通过XSS，我们可以进行CSRF，然后偷偷访问其他网站，或者操作用户财产。</p>\n<a id=\"more\"></a>\n<h1 id=\"Hash碰撞\"><a href=\"#Hash碰撞\" class=\"headerlink\" title=\"Hash碰撞\"></a>Hash碰撞</h1><ol>\n<li>hashCode算法问题</li>\n<li>通过制造出一模一样的hashCode的数据，攻击网站。</li>\n<li>String的hashCode算法数学表达式是<code>Hash = Hash * 31 + val[i]</code>。</li>\n<li>通过这个算式可以反推，从而攻击服务器，让服务器CPU打满。</li>\n</ol>\n<h1 id=\"DDOS\"><a href=\"#DDOS\" class=\"headerlink\" title=\"DDOS\"></a>DDOS</h1><p>拒绝服务攻击，通过控制大量肉鸡，模拟用户请求访问目标网站，拖垮对方网站的服务。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"XSS\"><a href=\"#XSS\" class=\"headerlink\" title=\"XSS\"></a>XSS</h1><p>cross site scripting，跨站脚本攻击<br>这是一种方法，通常所说的网页挂马<br>用于评论时将脚本输入进去，网站展示的时候，没有做转义处理，对访问页面的用户造成恶略影响。</p>\n<h1 id=\"CSRF\"><a href=\"#CSRF\" class=\"headerlink\" title=\"CSRF\"></a>CSRF</h1><p>cross site request forgery，跨站请求伪造<br>这是一种攻击结果<br>通过XSS，我们可以进行CSRF，然后偷偷访问其他网站，或者操作用户财产。</p>","more":"<h1 id=\"Hash碰撞\"><a href=\"#Hash碰撞\" class=\"headerlink\" title=\"Hash碰撞\"></a>Hash碰撞</h1><ol>\n<li>hashCode算法问题</li>\n<li>通过制造出一模一样的hashCode的数据，攻击网站。</li>\n<li>String的hashCode算法数学表达式是<code>Hash = Hash * 31 + val[i]</code>。</li>\n<li>通过这个算式可以反推，从而攻击服务器，让服务器CPU打满。</li>\n</ol>\n<h1 id=\"DDOS\"><a href=\"#DDOS\" class=\"headerlink\" title=\"DDOS\"></a>DDOS</h1><p>拒绝服务攻击，通过控制大量肉鸡，模拟用户请求访问目标网站，拖垮对方网站的服务。</p>"},{"title":"死锁","date":"2018-06-23T10:27:13.000Z","toc":true,"_content":"# 必要条件\n1. 资源竞争\n2. 请求和保持\n3. 不可剥夺\n4. 循环等待\n<!-- more -->\n\n# 如何避免死锁：\n1. \u001b\u001b最大的一点，避免使用锁\n2. 资源竞争，使用ThreadLocal\n3. 请求与保持，缩短锁的使用时间\n4. 不可剥夺，\u001b获取锁的时候加上\u001b超时机制\n5. 循环等待，保证获取锁的\u001b顺序是一样的","source":"_posts/死锁.md","raw":"---\ntitle: 死锁\ndate: 2018-06-23 18:27:13\ntags:\n- java\n- 并发\ncategories:\n- java\n- 并发\ntoc: true\n---\n# 必要条件\n1. 资源竞争\n2. 请求和保持\n3. 不可剥夺\n4. 循环等待\n<!-- more -->\n\n# 如何避免死锁：\n1. \u001b\u001b最大的一点，避免使用锁\n2. 资源竞争，使用ThreadLocal\n3. 请求与保持，缩短锁的使用时间\n4. 不可剥夺，\u001b获取锁的时候加上\u001b超时机制\n5. 循环等待，保证获取锁的\u001b顺序是一样的","slug":"死锁","published":1,"updated":"2018-06-23T11:00:21.706Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5u1twi00311av83ji17c86","content":"<h1 id=\"必要条件\"><a href=\"#必要条件\" class=\"headerlink\" title=\"必要条件\"></a>必要条件</h1><ol>\n<li>资源竞争</li>\n<li>请求和保持</li>\n<li>不可剥夺</li>\n<li>循环等待<a id=\"more\"></a>\n</li>\n</ol>\n<h1 id=\"如何避免死锁：\"><a href=\"#如何避免死锁：\" class=\"headerlink\" title=\"如何避免死锁：\"></a>如何避免死锁：</h1><ol>\n<li>\u001b\u001b最大的一点，避免使用锁</li>\n<li>资源竞争，使用ThreadLocal</li>\n<li>请求与保持，缩短锁的使用时间</li>\n<li>不可剥夺，\u001b获取锁的时候加上\u001b超时机制</li>\n<li>循环等待，保证获取锁的\u001b顺序是一样的</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h1 id=\"必要条件\"><a href=\"#必要条件\" class=\"headerlink\" title=\"必要条件\"></a>必要条件</h1><ol>\n<li>资源竞争</li>\n<li>请求和保持</li>\n<li>不可剥夺</li>\n<li>循环等待","more":"</li>\n</ol>\n<h1 id=\"如何避免死锁：\"><a href=\"#如何避免死锁：\" class=\"headerlink\" title=\"如何避免死锁：\"></a>如何避免死锁：</h1><ol>\n<li>\u001b\u001b最大的一点，避免使用锁</li>\n<li>资源竞争，使用ThreadLocal</li>\n<li>请求与保持，缩短锁的使用时间</li>\n<li>不可剥夺，\u001b获取锁的时候加上\u001b超时机制</li>\n<li>循环等待，保证获取锁的\u001b顺序是一样的</li>\n</ol>"},{"title":"编码","date":"2018-06-23T08:20:05.000Z","toc":true,"_content":"#### unicode\n俗称万国码，是一种编码规范，只是规定了字符的数值表示，并没有规定字符的具体编码存储。\n#### utf-8\n是unicode一种具体的存储实现，字节可能被存储为1，2，3个字节。\n#### gbk\n也是一种编码规范，gb2312 -> gbk1.0 -> gbk18030","source":"_posts/编码.md","raw":"---\ntitle: 编码\ndate: 2018-06-23 16:20:05\ntags:\n- java\n- 基础\ncategories:\n- java\n- 基础\ntoc: true\n---\n#### unicode\n俗称万国码，是一种编码规范，只是规定了字符的数值表示，并没有规定字符的具体编码存储。\n#### utf-8\n是unicode一种具体的存储实现，字节可能被存储为1，2，3个字节。\n#### gbk\n也是一种编码规范，gb2312 -> gbk1.0 -> gbk18030","slug":"编码","published":1,"updated":"2018-06-23T09:55:34.630Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5u1twl00351av8cjjzdt33","content":"<h4 id=\"unicode\"><a href=\"#unicode\" class=\"headerlink\" title=\"unicode\"></a>unicode</h4><p>俗称万国码，是一种编码规范，只是规定了字符的数值表示，并没有规定字符的具体编码存储。</p>\n<h4 id=\"utf-8\"><a href=\"#utf-8\" class=\"headerlink\" title=\"utf-8\"></a>utf-8</h4><p>是unicode一种具体的存储实现，字节可能被存储为1，2，3个字节。</p>\n<h4 id=\"gbk\"><a href=\"#gbk\" class=\"headerlink\" title=\"gbk\"></a>gbk</h4><p>也是一种编码规范，gb2312 -&gt; gbk1.0 -&gt; gbk18030</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"unicode\"><a href=\"#unicode\" class=\"headerlink\" title=\"unicode\"></a>unicode</h4><p>俗称万国码，是一种编码规范，只是规定了字符的数值表示，并没有规定字符的具体编码存储。</p>\n<h4 id=\"utf-8\"><a href=\"#utf-8\" class=\"headerlink\" title=\"utf-8\"></a>utf-8</h4><p>是unicode一种具体的存储实现，字节可能被存储为1，2，3个字节。</p>\n<h4 id=\"gbk\"><a href=\"#gbk\" class=\"headerlink\" title=\"gbk\"></a>gbk</h4><p>也是一种编码规范，gb2312 -&gt; gbk1.0 -&gt; gbk18030</p>\n"},{"title":"缓存预热，缓存穿透，缓存雪崩","date":"2018-06-24T07:56:46.000Z","toc":true,"_content":"#### 缓存预热\n通过手动触发的方式，将一些热点数据提前加载到数据库中，防止请求大量到来时候导致数据库压力过大。\n\n####  缓存穿透\n数据在数据库中不存在，导致每次都去重新查询数据库（需要将查询结果作为一个默认值保存到数据库中）\n\n#### 缓存雪崩\n由于缓存穿透，或者是短时间之内key大量过期，导致数据库压力过大，数据库操作时延过长，带来的一系列其他问题","source":"_posts/缓存预热，缓存穿透，缓存雪崩.md","raw":"---\ntitle: 缓存预热，缓存穿透，缓存雪崩\ndate: 2018-06-24 15:56:46\ntags:\n- 中间件\n- redis\ncategories:\n- 中间件\ntoc: true\n---\n#### 缓存预热\n通过手动触发的方式，将一些热点数据提前加载到数据库中，防止请求大量到来时候导致数据库压力过大。\n\n####  缓存穿透\n数据在数据库中不存在，导致每次都去重新查询数据库（需要将查询结果作为一个默认值保存到数据库中）\n\n#### 缓存雪崩\n由于缓存穿透，或者是短时间之内key大量过期，导致数据库压力过大，数据库操作时延过长，带来的一系列其他问题","slug":"缓存预热，缓存穿透，缓存雪崩","published":1,"updated":"2018-06-24T08:12:51.671Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5u1twn00381av871642n7p","content":"<h4 id=\"缓存预热\"><a href=\"#缓存预热\" class=\"headerlink\" title=\"缓存预热\"></a>缓存预热</h4><p>通过手动触发的方式，将一些热点数据提前加载到数据库中，防止请求大量到来时候导致数据库压力过大。</p>\n<h4 id=\"缓存穿透\"><a href=\"#缓存穿透\" class=\"headerlink\" title=\"缓存穿透\"></a>缓存穿透</h4><p>数据在数据库中不存在，导致每次都去重新查询数据库（需要将查询结果作为一个默认值保存到数据库中）</p>\n<h4 id=\"缓存雪崩\"><a href=\"#缓存雪崩\" class=\"headerlink\" title=\"缓存雪崩\"></a>缓存雪崩</h4><p>由于缓存穿透，或者是短时间之内key大量过期，导致数据库压力过大，数据库操作时延过长，带来的一系列其他问题</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"缓存预热\"><a href=\"#缓存预热\" class=\"headerlink\" title=\"缓存预热\"></a>缓存预热</h4><p>通过手动触发的方式，将一些热点数据提前加载到数据库中，防止请求大量到来时候导致数据库压力过大。</p>\n<h4 id=\"缓存穿透\"><a href=\"#缓存穿透\" class=\"headerlink\" title=\"缓存穿透\"></a>缓存穿透</h4><p>数据在数据库中不存在，导致每次都去重新查询数据库（需要将查询结果作为一个默认值保存到数据库中）</p>\n<h4 id=\"缓存雪崩\"><a href=\"#缓存雪崩\" class=\"headerlink\" title=\"缓存雪崩\"></a>缓存雪崩</h4><p>由于缓存穿透，或者是短时间之内key大量过期，导致数据库压力过大，数据库操作时延过长，带来的一系列其他问题</p>\n"},{"title":"类加载","date":"2018-06-23T08:07:40.000Z","toc":true,"_content":"\n#### 流程\n1. 加载\n    - 通过类名寻找到class文件 \n    - 构建class对象\n    - 将class文件变为运行时数据结构\n2. 验证\n    - 文件格式验证，文件格式是不是符合当前虚拟机规范\n    - 元数据验证，语义分析 \n    - 字节码验证，字节码是否符合规范，是否会对虚拟机造成危害\n    - 符号引用验证，\n3. 准备\n    - 为变量分配内存，并且赋默认值（0，null，false）\n4. 解析\n    - 类和接口的解析，这边可能涉及到其他类的加载\n    - 字段解析（静态，非静态）\n    - 方法解析\n5. 初始化\n    - 执行静态变量的初始赋值，和类内静态代码块\n6. 使用\n7. 卸载\n\n<!-- more -->\n#### 加载器\n1. bootstrap，加载JDK\\jre\\lib或者-Xbootclasspath下面的类，如rt.jar，java.*开头的类\n2. extension，加载JDK\\jre\\lib\\ext或者由java.ext.dirs系统变量\n3. system，加载classpath下面的所有路径\n\n#### 父类委托\n1. 更安全，这样防止自定义ClassLoader加载系统类\n2. 防止同一个class被加载两次\n\n#### tip\n1. 类内代码块的执行早过构造函数，因为编译的时候把类内代码块移到了构造函数首部。\n2. 如何解决jar包冲突，具体是类隔离，不同的jar包通过不同的技术加载","source":"_posts/类加载.md","raw":"---\ntitle: 类加载\ndate: 2018-06-23 16:07:40\ntags:\n- java\n- jvm\ncategories:\n- java\n- jvm\ntoc: true\n---\n\n#### 流程\n1. 加载\n    - 通过类名寻找到class文件 \n    - 构建class对象\n    - 将class文件变为运行时数据结构\n2. 验证\n    - 文件格式验证，文件格式是不是符合当前虚拟机规范\n    - 元数据验证，语义分析 \n    - 字节码验证，字节码是否符合规范，是否会对虚拟机造成危害\n    - 符号引用验证，\n3. 准备\n    - 为变量分配内存，并且赋默认值（0，null，false）\n4. 解析\n    - 类和接口的解析，这边可能涉及到其他类的加载\n    - 字段解析（静态，非静态）\n    - 方法解析\n5. 初始化\n    - 执行静态变量的初始赋值，和类内静态代码块\n6. 使用\n7. 卸载\n\n<!-- more -->\n#### 加载器\n1. bootstrap，加载JDK\\jre\\lib或者-Xbootclasspath下面的类，如rt.jar，java.*开头的类\n2. extension，加载JDK\\jre\\lib\\ext或者由java.ext.dirs系统变量\n3. system，加载classpath下面的所有路径\n\n#### 父类委托\n1. 更安全，这样防止自定义ClassLoader加载系统类\n2. 防止同一个class被加载两次\n\n#### tip\n1. 类内代码块的执行早过构造函数，因为编译的时候把类内代码块移到了构造函数首部。\n2. 如何解决jar包冲突，具体是类隔离，不同的jar包通过不同的技术加载","slug":"类加载","published":1,"updated":"2018-06-23T11:00:28.426Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5u1twq003d1av8ce8i0lv0","content":"<h4 id=\"流程\"><a href=\"#流程\" class=\"headerlink\" title=\"流程\"></a>流程</h4><ol>\n<li>加载<ul>\n<li>通过类名寻找到class文件 </li>\n<li>构建class对象</li>\n<li>将class文件变为运行时数据结构</li>\n</ul>\n</li>\n<li>验证<ul>\n<li>文件格式验证，文件格式是不是符合当前虚拟机规范</li>\n<li>元数据验证，语义分析 </li>\n<li>字节码验证，字节码是否符合规范，是否会对虚拟机造成危害</li>\n<li>符号引用验证，</li>\n</ul>\n</li>\n<li>准备<ul>\n<li>为变量分配内存，并且赋默认值（0，null，false）</li>\n</ul>\n</li>\n<li>解析<ul>\n<li>类和接口的解析，这边可能涉及到其他类的加载</li>\n<li>字段解析（静态，非静态）</li>\n<li>方法解析</li>\n</ul>\n</li>\n<li>初始化<ul>\n<li>执行静态变量的初始赋值，和类内静态代码块</li>\n</ul>\n</li>\n<li>使用</li>\n<li>卸载</li>\n</ol>\n<a id=\"more\"></a>\n<h4 id=\"加载器\"><a href=\"#加载器\" class=\"headerlink\" title=\"加载器\"></a>加载器</h4><ol>\n<li>bootstrap，加载JDK\\jre\\lib或者-Xbootclasspath下面的类，如rt.jar，java.*开头的类</li>\n<li>extension，加载JDK\\jre\\lib\\ext或者由java.ext.dirs系统变量</li>\n<li>system，加载classpath下面的所有路径</li>\n</ol>\n<h4 id=\"父类委托\"><a href=\"#父类委托\" class=\"headerlink\" title=\"父类委托\"></a>父类委托</h4><ol>\n<li>更安全，这样防止自定义ClassLoader加载系统类</li>\n<li>防止同一个class被加载两次</li>\n</ol>\n<h4 id=\"tip\"><a href=\"#tip\" class=\"headerlink\" title=\"tip\"></a>tip</h4><ol>\n<li>类内代码块的执行早过构造函数，因为编译的时候把类内代码块移到了构造函数首部。</li>\n<li>如何解决jar包冲突，具体是类隔离，不同的jar包通过不同的技术加载</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h4 id=\"流程\"><a href=\"#流程\" class=\"headerlink\" title=\"流程\"></a>流程</h4><ol>\n<li>加载<ul>\n<li>通过类名寻找到class文件 </li>\n<li>构建class对象</li>\n<li>将class文件变为运行时数据结构</li>\n</ul>\n</li>\n<li>验证<ul>\n<li>文件格式验证，文件格式是不是符合当前虚拟机规范</li>\n<li>元数据验证，语义分析 </li>\n<li>字节码验证，字节码是否符合规范，是否会对虚拟机造成危害</li>\n<li>符号引用验证，</li>\n</ul>\n</li>\n<li>准备<ul>\n<li>为变量分配内存，并且赋默认值（0，null，false）</li>\n</ul>\n</li>\n<li>解析<ul>\n<li>类和接口的解析，这边可能涉及到其他类的加载</li>\n<li>字段解析（静态，非静态）</li>\n<li>方法解析</li>\n</ul>\n</li>\n<li>初始化<ul>\n<li>执行静态变量的初始赋值，和类内静态代码块</li>\n</ul>\n</li>\n<li>使用</li>\n<li>卸载</li>\n</ol>","more":"<h4 id=\"加载器\"><a href=\"#加载器\" class=\"headerlink\" title=\"加载器\"></a>加载器</h4><ol>\n<li>bootstrap，加载JDK\\jre\\lib或者-Xbootclasspath下面的类，如rt.jar，java.*开头的类</li>\n<li>extension，加载JDK\\jre\\lib\\ext或者由java.ext.dirs系统变量</li>\n<li>system，加载classpath下面的所有路径</li>\n</ol>\n<h4 id=\"父类委托\"><a href=\"#父类委托\" class=\"headerlink\" title=\"父类委托\"></a>父类委托</h4><ol>\n<li>更安全，这样防止自定义ClassLoader加载系统类</li>\n<li>防止同一个class被加载两次</li>\n</ol>\n<h4 id=\"tip\"><a href=\"#tip\" class=\"headerlink\" title=\"tip\"></a>tip</h4><ol>\n<li>类内代码块的执行早过构造函数，因为编译的时候把类内代码块移到了构造函数首部。</li>\n<li>如何解决jar包冲突，具体是类隔离，不同的jar包通过不同的技术加载</li>\n</ol>"},{"title":"重排序","date":"2018-06-23T08:09:49.000Z","toc":true,"_content":"## 分类\n1. 编译器重排序\n2. 处理器重排序\n3. 内存重排序\n\n## 目的\n重排序存在的目的是为了更好的执行性能优化\n<!-- more -->\n## 屏障\n名称|含义|作用|实现\n:--:|:--:|:--:|:--:\nloadLoad|load1; loadLoad; load2|所有的load2操作都发生在|sfence\nstoreStore|store1; storeStore; store2;|所有的store1都在store2之前|lfence\nloadStore|load1; loadStore; store|所有的load操作发生在store之前\nstoreLoad|store1; storeLoad; load1|所有的store1操作发生在load1之前|mfence\n**tip:**\n1. \u001fstoreLoad是全能型屏障，但是需要刷新缓存，性能损耗较大。\n2. mfence和lock的区别，作用类似，但是\block可能会锁住内存总线。\n3. MESI协议，缓存一致性\b协议，\u001bstoreLoad需要。   \n\n# 内存结构\n![处理器内存结构](/images/处理器内存.png)\n\n# MESI\n是Cache一致性协议，缓存行里面有两个bit，表示当前缓存行是否有效。\n\n状态|描述\n:-|:-\nModified|数据有效，但是和内存中的不一致\nExclusive|数据有效，并且只有当前一个副本\nShared|数据有效，但是有多个副本\nInvalid|数据无效，需要重新从内存读取\n\n# long，double\njvm规范中，针对于非volatile类型修饰的long，double的写入，jmm是分为两次32字节操作的。\n但是在目前的商用虚拟机中，64字节的\u001b写入操作是**原子的**，不需要担心此类问题。\n\n# volatile\n## 作用\n保证可见性，以及防止重排序\n## 原理\n```java\nvolatile int count = 0;\n\nstoreStore\ncount=10;\nstoreLoad // sfence\n\nloadLoad\nif (count > 10) {}\nloadStore\n```\n\n# final\n1. final域的写入操作之后插入了storeStore，\b禁止重排序到构造函数之外，**为了防止对象引用逃逸**\n2. \b读对象的引用和\b对象final域操作\u001b之间插入loadLoad屏障，**为了防止读到未完全初始化的对象**\n\n# synchronized\nsynchronized也是有同步作用存在，退出同步块之前，会把object对象刷新回主内存。\n```java\nsynchronized (object) {\n}\n```\n\n# 思考题\n问: \n下面的输出是什么？\n答:\n输出是40000。\n```java\npublic class VariableTest {\n    static int count = 0;\n    static int max = 20_000;\n\n    public static void main(String[] args) throws InterruptedException {\n        Thread thread1 = new Thread(() -> {\n            for (int i = 0; i < max; i++) {\n                while (System.currentTimeMillis() % 2 == 0)\n                    Thread.yield();\n\n                count += 1;\n                LockSupport.parkNanos(1000_000);\n            }\n        });\n        thread1.start();\n\n        Thread thread2 = new Thread(() -> {\n            for (int i = 0; i < max; i++) {\n                while (System.currentTimeMillis() % 2 == 1)\n                    Thread.yield();\n\n                count += 1;\n                LockSupport.parkNanos(1000_000);\n            }\n        });\n        thread2.start();\n\n        thread1.join();\n        thread2.join();\n        System.out.println(count);\n    }\n}\n```","source":"_posts/重排序.md","raw":"---\ntitle: 重排序\ndate: 2018-06-23 16:09:49\ntags:\n- java\n- jvm\ncategories:\n- java\n- jvm\ntoc: true\n---\n## 分类\n1. 编译器重排序\n2. 处理器重排序\n3. 内存重排序\n\n## 目的\n重排序存在的目的是为了更好的执行性能优化\n<!-- more -->\n## 屏障\n名称|含义|作用|实现\n:--:|:--:|:--:|:--:\nloadLoad|load1; loadLoad; load2|所有的load2操作都发生在|sfence\nstoreStore|store1; storeStore; store2;|所有的store1都在store2之前|lfence\nloadStore|load1; loadStore; store|所有的load操作发生在store之前\nstoreLoad|store1; storeLoad; load1|所有的store1操作发生在load1之前|mfence\n**tip:**\n1. \u001fstoreLoad是全能型屏障，但是需要刷新缓存，性能损耗较大。\n2. mfence和lock的区别，作用类似，但是\block可能会锁住内存总线。\n3. MESI协议，缓存一致性\b协议，\u001bstoreLoad需要。   \n\n# 内存结构\n![处理器内存结构](/images/处理器内存.png)\n\n# MESI\n是Cache一致性协议，缓存行里面有两个bit，表示当前缓存行是否有效。\n\n状态|描述\n:-|:-\nModified|数据有效，但是和内存中的不一致\nExclusive|数据有效，并且只有当前一个副本\nShared|数据有效，但是有多个副本\nInvalid|数据无效，需要重新从内存读取\n\n# long，double\njvm规范中，针对于非volatile类型修饰的long，double的写入，jmm是分为两次32字节操作的。\n但是在目前的商用虚拟机中，64字节的\u001b写入操作是**原子的**，不需要担心此类问题。\n\n# volatile\n## 作用\n保证可见性，以及防止重排序\n## 原理\n```java\nvolatile int count = 0;\n\nstoreStore\ncount=10;\nstoreLoad // sfence\n\nloadLoad\nif (count > 10) {}\nloadStore\n```\n\n# final\n1. final域的写入操作之后插入了storeStore，\b禁止重排序到构造函数之外，**为了防止对象引用逃逸**\n2. \b读对象的引用和\b对象final域操作\u001b之间插入loadLoad屏障，**为了防止读到未完全初始化的对象**\n\n# synchronized\nsynchronized也是有同步作用存在，退出同步块之前，会把object对象刷新回主内存。\n```java\nsynchronized (object) {\n}\n```\n\n# 思考题\n问: \n下面的输出是什么？\n答:\n输出是40000。\n```java\npublic class VariableTest {\n    static int count = 0;\n    static int max = 20_000;\n\n    public static void main(String[] args) throws InterruptedException {\n        Thread thread1 = new Thread(() -> {\n            for (int i = 0; i < max; i++) {\n                while (System.currentTimeMillis() % 2 == 0)\n                    Thread.yield();\n\n                count += 1;\n                LockSupport.parkNanos(1000_000);\n            }\n        });\n        thread1.start();\n\n        Thread thread2 = new Thread(() -> {\n            for (int i = 0; i < max; i++) {\n                while (System.currentTimeMillis() % 2 == 1)\n                    Thread.yield();\n\n                count += 1;\n                LockSupport.parkNanos(1000_000);\n            }\n        });\n        thread2.start();\n\n        thread1.join();\n        thread2.join();\n        System.out.println(count);\n    }\n}\n```","slug":"重排序","published":1,"updated":"2018-06-23T09:55:43.635Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5u1tws003g1av8byy9kz6u","content":"<h2 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h2><ol>\n<li>编译器重排序</li>\n<li>处理器重排序</li>\n<li>内存重排序</li>\n</ol>\n<h2 id=\"目的\"><a href=\"#目的\" class=\"headerlink\" title=\"目的\"></a>目的</h2><p>重排序存在的目的是为了更好的执行性能优化<br><a id=\"more\"></a></p>\n<h2 id=\"屏障\"><a href=\"#屏障\" class=\"headerlink\" title=\"屏障\"></a>屏障</h2><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">名称</th>\n<th style=\"text-align:center\">含义</th>\n<th style=\"text-align:center\">作用</th>\n<th style=\"text-align:center\">实现</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">loadLoad</td>\n<td style=\"text-align:center\">load1; loadLoad; load2</td>\n<td style=\"text-align:center\">所有的load2操作都发生在</td>\n<td style=\"text-align:center\">sfence</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">storeStore</td>\n<td style=\"text-align:center\">store1; storeStore; store2;</td>\n<td style=\"text-align:center\">所有的store1都在store2之前</td>\n<td style=\"text-align:center\">lfence</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">loadStore</td>\n<td style=\"text-align:center\">load1; loadStore; store</td>\n<td style=\"text-align:center\">所有的load操作发生在store之前</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">storeLoad</td>\n<td style=\"text-align:center\">store1; storeLoad; load1</td>\n<td style=\"text-align:center\">所有的store1操作发生在load1之前</td>\n<td style=\"text-align:center\">mfence</td>\n</tr>\n</tbody>\n</table>\n<p><strong>tip:</strong></p>\n<ol>\n<li>\u001fstoreLoad是全能型屏障，但是需要刷新缓存，性能损耗较大。</li>\n<li>mfence和lock的区别，作用类似，但是\block可能会锁住内存总线。</li>\n<li>MESI协议，缓存一致性\b协议，\u001bstoreLoad需要。   </li>\n</ol>\n<h1 id=\"内存结构\"><a href=\"#内存结构\" class=\"headerlink\" title=\"内存结构\"></a>内存结构</h1><p><img src=\"/images/处理器内存.png\" alt=\"处理器内存结构\"></p>\n<h1 id=\"MESI\"><a href=\"#MESI\" class=\"headerlink\" title=\"MESI\"></a>MESI</h1><p>是Cache一致性协议，缓存行里面有两个bit，表示当前缓存行是否有效。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">状态</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">Modified</td>\n<td style=\"text-align:left\">数据有效，但是和内存中的不一致</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Exclusive</td>\n<td style=\"text-align:left\">数据有效，并且只有当前一个副本</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Shared</td>\n<td style=\"text-align:left\">数据有效，但是有多个副本</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Invalid</td>\n<td style=\"text-align:left\">数据无效，需要重新从内存读取</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"long，double\"><a href=\"#long，double\" class=\"headerlink\" title=\"long，double\"></a>long，double</h1><p>jvm规范中，针对于非volatile类型修饰的long，double的写入，jmm是分为两次32字节操作的。<br>但是在目前的商用虚拟机中，64字节的\u001b写入操作是<strong>原子的</strong>，不需要担心此类问题。</p>\n<h1 id=\"volatile\"><a href=\"#volatile\" class=\"headerlink\" title=\"volatile\"></a>volatile</h1><h2 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h2><p>保证可见性，以及防止重排序</p>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">storeStore</span><br><span class=\"line\">count=<span class=\"number\">10</span>;</span><br><span class=\"line\">storeLoad <span class=\"comment\">// sfence</span></span><br><span class=\"line\"></span><br><span class=\"line\">loadLoad</span><br><span class=\"line\"><span class=\"keyword\">if</span> (count &gt; <span class=\"number\">10</span>) &#123;&#125;</span><br><span class=\"line\">loadStore</span><br></pre></td></tr></table></figure>\n<h1 id=\"final\"><a href=\"#final\" class=\"headerlink\" title=\"final\"></a>final</h1><ol>\n<li>final域的写入操作之后插入了storeStore，\b禁止重排序到构造函数之外，<strong>为了防止对象引用逃逸</strong></li>\n<li>\b读对象的引用和\b对象final域操作\u001b之间插入loadLoad屏障，<strong>为了防止读到未完全初始化的对象</strong></li>\n</ol>\n<h1 id=\"synchronized\"><a href=\"#synchronized\" class=\"headerlink\" title=\"synchronized\"></a>synchronized</h1><p>synchronized也是有同步作用存在，退出同步块之前，会把object对象刷新回主内存。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">synchronized</span> (object) &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"思考题\"><a href=\"#思考题\" class=\"headerlink\" title=\"思考题\"></a>思考题</h1><p>问:<br>下面的输出是什么？<br>答:<br>输出是40000。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">VariableTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> max = <span class=\"number\">20_000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        Thread thread1 = <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; max; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (System.currentTimeMillis() % <span class=\"number\">2</span> == <span class=\"number\">0</span>)</span><br><span class=\"line\">                    Thread.yield();</span><br><span class=\"line\"></span><br><span class=\"line\">                count += <span class=\"number\">1</span>;</span><br><span class=\"line\">                LockSupport.parkNanos(<span class=\"number\">1000_000</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        thread1.start();</span><br><span class=\"line\"></span><br><span class=\"line\">        Thread thread2 = <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; max; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (System.currentTimeMillis() % <span class=\"number\">2</span> == <span class=\"number\">1</span>)</span><br><span class=\"line\">                    Thread.yield();</span><br><span class=\"line\"></span><br><span class=\"line\">                count += <span class=\"number\">1</span>;</span><br><span class=\"line\">                LockSupport.parkNanos(<span class=\"number\">1000_000</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        thread2.start();</span><br><span class=\"line\"></span><br><span class=\"line\">        thread1.join();</span><br><span class=\"line\">        thread2.join();</span><br><span class=\"line\">        System.out.println(count);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h2><ol>\n<li>编译器重排序</li>\n<li>处理器重排序</li>\n<li>内存重排序</li>\n</ol>\n<h2 id=\"目的\"><a href=\"#目的\" class=\"headerlink\" title=\"目的\"></a>目的</h2><p>重排序存在的目的是为了更好的执行性能优化<br>","more":"</p>\n<h2 id=\"屏障\"><a href=\"#屏障\" class=\"headerlink\" title=\"屏障\"></a>屏障</h2><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">名称</th>\n<th style=\"text-align:center\">含义</th>\n<th style=\"text-align:center\">作用</th>\n<th style=\"text-align:center\">实现</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">loadLoad</td>\n<td style=\"text-align:center\">load1; loadLoad; load2</td>\n<td style=\"text-align:center\">所有的load2操作都发生在</td>\n<td style=\"text-align:center\">sfence</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">storeStore</td>\n<td style=\"text-align:center\">store1; storeStore; store2;</td>\n<td style=\"text-align:center\">所有的store1都在store2之前</td>\n<td style=\"text-align:center\">lfence</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">loadStore</td>\n<td style=\"text-align:center\">load1; loadStore; store</td>\n<td style=\"text-align:center\">所有的load操作发生在store之前</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">storeLoad</td>\n<td style=\"text-align:center\">store1; storeLoad; load1</td>\n<td style=\"text-align:center\">所有的store1操作发生在load1之前</td>\n<td style=\"text-align:center\">mfence</td>\n</tr>\n</tbody>\n</table>\n<p><strong>tip:</strong></p>\n<ol>\n<li>\u001fstoreLoad是全能型屏障，但是需要刷新缓存，性能损耗较大。</li>\n<li>mfence和lock的区别，作用类似，但是\block可能会锁住内存总线。</li>\n<li>MESI协议，缓存一致性\b协议，\u001bstoreLoad需要。   </li>\n</ol>\n<h1 id=\"内存结构\"><a href=\"#内存结构\" class=\"headerlink\" title=\"内存结构\"></a>内存结构</h1><p><img src=\"/images/处理器内存.png\" alt=\"处理器内存结构\"></p>\n<h1 id=\"MESI\"><a href=\"#MESI\" class=\"headerlink\" title=\"MESI\"></a>MESI</h1><p>是Cache一致性协议，缓存行里面有两个bit，表示当前缓存行是否有效。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">状态</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">Modified</td>\n<td style=\"text-align:left\">数据有效，但是和内存中的不一致</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Exclusive</td>\n<td style=\"text-align:left\">数据有效，并且只有当前一个副本</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Shared</td>\n<td style=\"text-align:left\">数据有效，但是有多个副本</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Invalid</td>\n<td style=\"text-align:left\">数据无效，需要重新从内存读取</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"long，double\"><a href=\"#long，double\" class=\"headerlink\" title=\"long，double\"></a>long，double</h1><p>jvm规范中，针对于非volatile类型修饰的long，double的写入，jmm是分为两次32字节操作的。<br>但是在目前的商用虚拟机中，64字节的\u001b写入操作是<strong>原子的</strong>，不需要担心此类问题。</p>\n<h1 id=\"volatile\"><a href=\"#volatile\" class=\"headerlink\" title=\"volatile\"></a>volatile</h1><h2 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h2><p>保证可见性，以及防止重排序</p>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">storeStore</span><br><span class=\"line\">count=<span class=\"number\">10</span>;</span><br><span class=\"line\">storeLoad <span class=\"comment\">// sfence</span></span><br><span class=\"line\"></span><br><span class=\"line\">loadLoad</span><br><span class=\"line\"><span class=\"keyword\">if</span> (count &gt; <span class=\"number\">10</span>) &#123;&#125;</span><br><span class=\"line\">loadStore</span><br></pre></td></tr></table></figure>\n<h1 id=\"final\"><a href=\"#final\" class=\"headerlink\" title=\"final\"></a>final</h1><ol>\n<li>final域的写入操作之后插入了storeStore，\b禁止重排序到构造函数之外，<strong>为了防止对象引用逃逸</strong></li>\n<li>\b读对象的引用和\b对象final域操作\u001b之间插入loadLoad屏障，<strong>为了防止读到未完全初始化的对象</strong></li>\n</ol>\n<h1 id=\"synchronized\"><a href=\"#synchronized\" class=\"headerlink\" title=\"synchronized\"></a>synchronized</h1><p>synchronized也是有同步作用存在，退出同步块之前，会把object对象刷新回主内存。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">synchronized</span> (object) &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"思考题\"><a href=\"#思考题\" class=\"headerlink\" title=\"思考题\"></a>思考题</h1><p>问:<br>下面的输出是什么？<br>答:<br>输出是40000。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">VariableTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> max = <span class=\"number\">20_000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        Thread thread1 = <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; max; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (System.currentTimeMillis() % <span class=\"number\">2</span> == <span class=\"number\">0</span>)</span><br><span class=\"line\">                    Thread.yield();</span><br><span class=\"line\"></span><br><span class=\"line\">                count += <span class=\"number\">1</span>;</span><br><span class=\"line\">                LockSupport.parkNanos(<span class=\"number\">1000_000</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        thread1.start();</span><br><span class=\"line\"></span><br><span class=\"line\">        Thread thread2 = <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; max; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (System.currentTimeMillis() % <span class=\"number\">2</span> == <span class=\"number\">1</span>)</span><br><span class=\"line\">                    Thread.yield();</span><br><span class=\"line\"></span><br><span class=\"line\">                count += <span class=\"number\">1</span>;</span><br><span class=\"line\">                LockSupport.parkNanos(<span class=\"number\">1000_000</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        thread2.start();</span><br><span class=\"line\"></span><br><span class=\"line\">        thread1.join();</span><br><span class=\"line\">        thread2.join();</span><br><span class=\"line\">        System.out.println(count);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>"},{"title":"设计模式","date":"2018-06-23T08:20:13.000Z","toc":true,"_content":"序号|类型|名称|介绍|jdk|spring\n:--:|:--:|:--:|:--:|:-:|:--:\n1|结构型|Facade（表象）模式||`java.lang.Class`|\n2|结构型|FlyWeight（享元）模式||`java.lang.Byte#valueOf(byte)`|\n3|结构型|Adapter（适配器）模式||`java.io.InputStreamReader(InputStream)`|\n4|结构型|Bridge（桥接）模式||`JDBC`|\n5|结构型|Composite（组合）模式||`java.util.Map#putAll(Map)`|\n6|结构型|Proxy（适配器）模式||`java.lang.reflect.Proxy`|\n7|结构型|Decorator（外观）模式||`java.io.BufferedInputStream(InputStream)`|\n<!-- more -->\n序号|类型|名称|介绍|jdk|spring\n:--:|:--:|:--:|:--:|:-:|:--:\n8|创建型|Singleton（单例）模式||`java.lang.Runtime#getRuntime()`|\n9|创建型|SimpleFactory（简单工厂）模式||`java.util.concurrent.ThreadFactory`|\n10|创建型|AbstractFactory（抽象工厂）模式||`java.util.Arrays#asList()`|\n11|创建型|Prototype（原型）模式||`java.lang.Object#clone()`|\n12|创建型|Builder（建造者）模式||`java.lang.StringBuilder#append()`|\n\n序号|类型|名称|介绍|jdk|spring\n:--:|:--:|:--:|:--:|:-:|:--:\n13|行为型|Iterator（迭代器）模式||`java.util.Iterator`\n14|行为型|Observer（观察者）模式||暂时未找到\n15|行为型|Strategy（策略）模式||`java.util.Arrays.sort()`\n16|行为型|Template（模板方法）模式||`java.util.concurrent.AbstractQueuedSynchronizer`\n17|行为型|Command（命令）模式||`java.lang.Runnable`\n18|行为型|Medaitor（中介）模式||`java.lang.reflect.Method#invoke()`\n19|行为型|Memento（备忘录）模式||`java.util.Date`\n20|行为型|Interpreter（解析器）模式||`java.util.Pattern`\n21|行为型|State（状态）模式||`java.util.Iterator`\n22|行为型|ChainOfResponsiblity（责任链）模式||`javax.servlet.Filter#doFilter()`|\n23|行为型|Visitor（访问者）模式||`javax.lang.model.element.ElementVisitor`","source":"_posts/设计模式.md","raw":"---\ntitle: 设计模式\ndate: 2018-06-23 16:20:13\ntags:\n- java\n- 基础\n- 设计模式\ncategories:\n- java\n- 基础\ntoc: true\n---\n序号|类型|名称|介绍|jdk|spring\n:--:|:--:|:--:|:--:|:-:|:--:\n1|结构型|Facade（表象）模式||`java.lang.Class`|\n2|结构型|FlyWeight（享元）模式||`java.lang.Byte#valueOf(byte)`|\n3|结构型|Adapter（适配器）模式||`java.io.InputStreamReader(InputStream)`|\n4|结构型|Bridge（桥接）模式||`JDBC`|\n5|结构型|Composite（组合）模式||`java.util.Map#putAll(Map)`|\n6|结构型|Proxy（适配器）模式||`java.lang.reflect.Proxy`|\n7|结构型|Decorator（外观）模式||`java.io.BufferedInputStream(InputStream)`|\n<!-- more -->\n序号|类型|名称|介绍|jdk|spring\n:--:|:--:|:--:|:--:|:-:|:--:\n8|创建型|Singleton（单例）模式||`java.lang.Runtime#getRuntime()`|\n9|创建型|SimpleFactory（简单工厂）模式||`java.util.concurrent.ThreadFactory`|\n10|创建型|AbstractFactory（抽象工厂）模式||`java.util.Arrays#asList()`|\n11|创建型|Prototype（原型）模式||`java.lang.Object#clone()`|\n12|创建型|Builder（建造者）模式||`java.lang.StringBuilder#append()`|\n\n序号|类型|名称|介绍|jdk|spring\n:--:|:--:|:--:|:--:|:-:|:--:\n13|行为型|Iterator（迭代器）模式||`java.util.Iterator`\n14|行为型|Observer（观察者）模式||暂时未找到\n15|行为型|Strategy（策略）模式||`java.util.Arrays.sort()`\n16|行为型|Template（模板方法）模式||`java.util.concurrent.AbstractQueuedSynchronizer`\n17|行为型|Command（命令）模式||`java.lang.Runnable`\n18|行为型|Medaitor（中介）模式||`java.lang.reflect.Method#invoke()`\n19|行为型|Memento（备忘录）模式||`java.util.Date`\n20|行为型|Interpreter（解析器）模式||`java.util.Pattern`\n21|行为型|State（状态）模式||`java.util.Iterator`\n22|行为型|ChainOfResponsiblity（责任链）模式||`javax.servlet.Filter#doFilter()`|\n23|行为型|Visitor（访问者）模式||`javax.lang.model.element.ElementVisitor`","slug":"设计模式","published":1,"updated":"2018-06-23T09:55:37.247Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5u1twu003k1av8dhz3wwgh","content":"<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">序号</th>\n<th style=\"text-align:center\">类型</th>\n<th style=\"text-align:center\">名称</th>\n<th style=\"text-align:center\">介绍</th>\n<th style=\"text-align:center\">jdk</th>\n<th style=\"text-align:center\">spring</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">结构型</td>\n<td style=\"text-align:center\">Facade（表象）模式</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"><code>java.lang.Class</code></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">结构型</td>\n<td style=\"text-align:center\">FlyWeight（享元）模式</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"><code>java.lang.Byte#valueOf(byte)</code></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">结构型</td>\n<td style=\"text-align:center\">Adapter（适配器）模式</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"><code>java.io.InputStreamReader(InputStream)</code></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:center\">结构型</td>\n<td style=\"text-align:center\">Bridge（桥接）模式</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"><code>JDBC</code></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">5</td>\n<td style=\"text-align:center\">结构型</td>\n<td style=\"text-align:center\">Composite（组合）模式</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"><code>java.util.Map#putAll(Map)</code></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">6</td>\n<td style=\"text-align:center\">结构型</td>\n<td style=\"text-align:center\">Proxy（适配器）模式</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"><code>java.lang.reflect.Proxy</code></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">7</td>\n<td style=\"text-align:center\">结构型</td>\n<td style=\"text-align:center\">Decorator（外观）模式</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"><code>java.io.BufferedInputStream(InputStream)</code></td>\n<td style=\"text-align:center\"></td>\n</tr>\n</tbody>\n</table>\n<a id=\"more\"></a>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">序号</th>\n<th style=\"text-align:center\">类型</th>\n<th style=\"text-align:center\">名称</th>\n<th style=\"text-align:center\">介绍</th>\n<th style=\"text-align:center\">jdk</th>\n<th style=\"text-align:center\">spring</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">8</td>\n<td style=\"text-align:center\">创建型</td>\n<td style=\"text-align:center\">Singleton（单例）模式</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"><code>java.lang.Runtime#getRuntime()</code></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">9</td>\n<td style=\"text-align:center\">创建型</td>\n<td style=\"text-align:center\">SimpleFactory（简单工厂）模式</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"><code>java.util.concurrent.ThreadFactory</code></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">10</td>\n<td style=\"text-align:center\">创建型</td>\n<td style=\"text-align:center\">AbstractFactory（抽象工厂）模式</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"><code>java.util.Arrays#asList()</code></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">11</td>\n<td style=\"text-align:center\">创建型</td>\n<td style=\"text-align:center\">Prototype（原型）模式</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"><code>java.lang.Object#clone()</code></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">12</td>\n<td style=\"text-align:center\">创建型</td>\n<td style=\"text-align:center\">Builder（建造者）模式</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"><code>java.lang.StringBuilder#append()</code></td>\n<td style=\"text-align:center\"></td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">序号</th>\n<th style=\"text-align:center\">类型</th>\n<th style=\"text-align:center\">名称</th>\n<th style=\"text-align:center\">介绍</th>\n<th style=\"text-align:center\">jdk</th>\n<th style=\"text-align:center\">spring</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">13</td>\n<td style=\"text-align:center\">行为型</td>\n<td style=\"text-align:center\">Iterator（迭代器）模式</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"><code>java.util.Iterator</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">14</td>\n<td style=\"text-align:center\">行为型</td>\n<td style=\"text-align:center\">Observer（观察者）模式</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">暂时未找到</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">15</td>\n<td style=\"text-align:center\">行为型</td>\n<td style=\"text-align:center\">Strategy（策略）模式</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"><code>java.util.Arrays.sort()</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">16</td>\n<td style=\"text-align:center\">行为型</td>\n<td style=\"text-align:center\">Template（模板方法）模式</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"><code>java.util.concurrent.AbstractQueuedSynchronizer</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">17</td>\n<td style=\"text-align:center\">行为型</td>\n<td style=\"text-align:center\">Command（命令）模式</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"><code>java.lang.Runnable</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">18</td>\n<td style=\"text-align:center\">行为型</td>\n<td style=\"text-align:center\">Medaitor（中介）模式</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"><code>java.lang.reflect.Method#invoke()</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">19</td>\n<td style=\"text-align:center\">行为型</td>\n<td style=\"text-align:center\">Memento（备忘录）模式</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"><code>java.util.Date</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">20</td>\n<td style=\"text-align:center\">行为型</td>\n<td style=\"text-align:center\">Interpreter（解析器）模式</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"><code>java.util.Pattern</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">21</td>\n<td style=\"text-align:center\">行为型</td>\n<td style=\"text-align:center\">State（状态）模式</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"><code>java.util.Iterator</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">22</td>\n<td style=\"text-align:center\">行为型</td>\n<td style=\"text-align:center\">ChainOfResponsiblity（责任链）模式</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"><code>javax.servlet.Filter#doFilter()</code></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">23</td>\n<td style=\"text-align:center\">行为型</td>\n<td style=\"text-align:center\">Visitor（访问者）模式</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"><code>javax.lang.model.element.ElementVisitor</code></td>\n</tr>\n</tbody>\n</table>\n","site":{"data":{}},"excerpt":"<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">序号</th>\n<th style=\"text-align:center\">类型</th>\n<th style=\"text-align:center\">名称</th>\n<th style=\"text-align:center\">介绍</th>\n<th style=\"text-align:center\">jdk</th>\n<th style=\"text-align:center\">spring</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">结构型</td>\n<td style=\"text-align:center\">Facade（表象）模式</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"><code>java.lang.Class</code></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">结构型</td>\n<td style=\"text-align:center\">FlyWeight（享元）模式</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"><code>java.lang.Byte#valueOf(byte)</code></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">结构型</td>\n<td style=\"text-align:center\">Adapter（适配器）模式</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"><code>java.io.InputStreamReader(InputStream)</code></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:center\">结构型</td>\n<td style=\"text-align:center\">Bridge（桥接）模式</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"><code>JDBC</code></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">5</td>\n<td style=\"text-align:center\">结构型</td>\n<td style=\"text-align:center\">Composite（组合）模式</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"><code>java.util.Map#putAll(Map)</code></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">6</td>\n<td style=\"text-align:center\">结构型</td>\n<td style=\"text-align:center\">Proxy（适配器）模式</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"><code>java.lang.reflect.Proxy</code></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">7</td>\n<td style=\"text-align:center\">结构型</td>\n<td style=\"text-align:center\">Decorator（外观）模式</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"><code>java.io.BufferedInputStream(InputStream)</code></td>\n<td style=\"text-align:center\"></td>\n</tr>\n</tbody>\n</table>","more":"<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">序号</th>\n<th style=\"text-align:center\">类型</th>\n<th style=\"text-align:center\">名称</th>\n<th style=\"text-align:center\">介绍</th>\n<th style=\"text-align:center\">jdk</th>\n<th style=\"text-align:center\">spring</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">8</td>\n<td style=\"text-align:center\">创建型</td>\n<td style=\"text-align:center\">Singleton（单例）模式</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"><code>java.lang.Runtime#getRuntime()</code></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">9</td>\n<td style=\"text-align:center\">创建型</td>\n<td style=\"text-align:center\">SimpleFactory（简单工厂）模式</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"><code>java.util.concurrent.ThreadFactory</code></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">10</td>\n<td style=\"text-align:center\">创建型</td>\n<td style=\"text-align:center\">AbstractFactory（抽象工厂）模式</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"><code>java.util.Arrays#asList()</code></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">11</td>\n<td style=\"text-align:center\">创建型</td>\n<td style=\"text-align:center\">Prototype（原型）模式</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"><code>java.lang.Object#clone()</code></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">12</td>\n<td style=\"text-align:center\">创建型</td>\n<td style=\"text-align:center\">Builder（建造者）模式</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"><code>java.lang.StringBuilder#append()</code></td>\n<td style=\"text-align:center\"></td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">序号</th>\n<th style=\"text-align:center\">类型</th>\n<th style=\"text-align:center\">名称</th>\n<th style=\"text-align:center\">介绍</th>\n<th style=\"text-align:center\">jdk</th>\n<th style=\"text-align:center\">spring</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">13</td>\n<td style=\"text-align:center\">行为型</td>\n<td style=\"text-align:center\">Iterator（迭代器）模式</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"><code>java.util.Iterator</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">14</td>\n<td style=\"text-align:center\">行为型</td>\n<td style=\"text-align:center\">Observer（观察者）模式</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">暂时未找到</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">15</td>\n<td style=\"text-align:center\">行为型</td>\n<td style=\"text-align:center\">Strategy（策略）模式</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"><code>java.util.Arrays.sort()</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">16</td>\n<td style=\"text-align:center\">行为型</td>\n<td style=\"text-align:center\">Template（模板方法）模式</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"><code>java.util.concurrent.AbstractQueuedSynchronizer</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">17</td>\n<td style=\"text-align:center\">行为型</td>\n<td style=\"text-align:center\">Command（命令）模式</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"><code>java.lang.Runnable</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">18</td>\n<td style=\"text-align:center\">行为型</td>\n<td style=\"text-align:center\">Medaitor（中介）模式</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"><code>java.lang.reflect.Method#invoke()</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">19</td>\n<td style=\"text-align:center\">行为型</td>\n<td style=\"text-align:center\">Memento（备忘录）模式</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"><code>java.util.Date</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">20</td>\n<td style=\"text-align:center\">行为型</td>\n<td style=\"text-align:center\">Interpreter（解析器）模式</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"><code>java.util.Pattern</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">21</td>\n<td style=\"text-align:center\">行为型</td>\n<td style=\"text-align:center\">State（状态）模式</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"><code>java.util.Iterator</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">22</td>\n<td style=\"text-align:center\">行为型</td>\n<td style=\"text-align:center\">ChainOfResponsiblity（责任链）模式</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"><code>javax.servlet.Filter#doFilter()</code></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">23</td>\n<td style=\"text-align:center\">行为型</td>\n<td style=\"text-align:center\">Visitor（访问者）模式</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"><code>javax.lang.model.element.ElementVisitor</code></td>\n</tr>\n</tbody>\n</table>"},{"title":"锁分类","date":"2018-06-23T10:27:59.000Z","toc":true,"_content":"### 悲观锁\n数据库中常用，select for update，加入的就是悲观锁\n\n### 乐观锁\n更新的时候，会比较版本号，如果当前数据的版本号与期望的一致，则写入数据\n\n### 可重入锁\n代表加锁之后可以多次进行加锁\n<!-- more -->\n### 监视器锁\n每个对象都是一把监视器锁\n\n### 自旋锁\n加锁的时候以自旋的方式加锁\n\n### 偏向锁，轻量级锁，重量级锁\n监视器锁，加锁先以偏向锁模式加锁，偏向模式被取消后，则以轻量级锁模式加锁，多个线程通知加轻量级锁，则轻量级锁会膨胀为重量级锁\n\n### 公平锁，非公平锁\n代表是否按顺序获取锁","source":"_posts/锁分类.md","raw":"---\ntitle: 锁分类\ndate: 2018-06-23 18:27:59\ntags:\n- java\n- 并发\ncategories:\n- java\n- 并发\ntoc: true\n---\n### 悲观锁\n数据库中常用，select for update，加入的就是悲观锁\n\n### 乐观锁\n更新的时候，会比较版本号，如果当前数据的版本号与期望的一致，则写入数据\n\n### 可重入锁\n代表加锁之后可以多次进行加锁\n<!-- more -->\n### 监视器锁\n每个对象都是一把监视器锁\n\n### 自旋锁\n加锁的时候以自旋的方式加锁\n\n### 偏向锁，轻量级锁，重量级锁\n监视器锁，加锁先以偏向锁模式加锁，偏向模式被取消后，则以轻量级锁模式加锁，多个线程通知加轻量级锁，则轻量级锁会膨胀为重量级锁\n\n### 公平锁，非公平锁\n代表是否按顺序获取锁","slug":"锁分类","published":1,"updated":"2018-06-23T10:29:23.786Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5u1tww003o1av800ukry70","content":"<h3 id=\"悲观锁\"><a href=\"#悲观锁\" class=\"headerlink\" title=\"悲观锁\"></a>悲观锁</h3><p>数据库中常用，select for update，加入的就是悲观锁</p>\n<h3 id=\"乐观锁\"><a href=\"#乐观锁\" class=\"headerlink\" title=\"乐观锁\"></a>乐观锁</h3><p>更新的时候，会比较版本号，如果当前数据的版本号与期望的一致，则写入数据</p>\n<h3 id=\"可重入锁\"><a href=\"#可重入锁\" class=\"headerlink\" title=\"可重入锁\"></a>可重入锁</h3><p>代表加锁之后可以多次进行加锁<br><a id=\"more\"></a></p>\n<h3 id=\"监视器锁\"><a href=\"#监视器锁\" class=\"headerlink\" title=\"监视器锁\"></a>监视器锁</h3><p>每个对象都是一把监视器锁</p>\n<h3 id=\"自旋锁\"><a href=\"#自旋锁\" class=\"headerlink\" title=\"自旋锁\"></a>自旋锁</h3><p>加锁的时候以自旋的方式加锁</p>\n<h3 id=\"偏向锁，轻量级锁，重量级锁\"><a href=\"#偏向锁，轻量级锁，重量级锁\" class=\"headerlink\" title=\"偏向锁，轻量级锁，重量级锁\"></a>偏向锁，轻量级锁，重量级锁</h3><p>监视器锁，加锁先以偏向锁模式加锁，偏向模式被取消后，则以轻量级锁模式加锁，多个线程通知加轻量级锁，则轻量级锁会膨胀为重量级锁</p>\n<h3 id=\"公平锁，非公平锁\"><a href=\"#公平锁，非公平锁\" class=\"headerlink\" title=\"公平锁，非公平锁\"></a>公平锁，非公平锁</h3><p>代表是否按顺序获取锁</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"悲观锁\"><a href=\"#悲观锁\" class=\"headerlink\" title=\"悲观锁\"></a>悲观锁</h3><p>数据库中常用，select for update，加入的就是悲观锁</p>\n<h3 id=\"乐观锁\"><a href=\"#乐观锁\" class=\"headerlink\" title=\"乐观锁\"></a>乐观锁</h3><p>更新的时候，会比较版本号，如果当前数据的版本号与期望的一致，则写入数据</p>\n<h3 id=\"可重入锁\"><a href=\"#可重入锁\" class=\"headerlink\" title=\"可重入锁\"></a>可重入锁</h3><p>代表加锁之后可以多次进行加锁<br>","more":"</p>\n<h3 id=\"监视器锁\"><a href=\"#监视器锁\" class=\"headerlink\" title=\"监视器锁\"></a>监视器锁</h3><p>每个对象都是一把监视器锁</p>\n<h3 id=\"自旋锁\"><a href=\"#自旋锁\" class=\"headerlink\" title=\"自旋锁\"></a>自旋锁</h3><p>加锁的时候以自旋的方式加锁</p>\n<h3 id=\"偏向锁，轻量级锁，重量级锁\"><a href=\"#偏向锁，轻量级锁，重量级锁\" class=\"headerlink\" title=\"偏向锁，轻量级锁，重量级锁\"></a>偏向锁，轻量级锁，重量级锁</h3><p>监视器锁，加锁先以偏向锁模式加锁，偏向模式被取消后，则以轻量级锁模式加锁，多个线程通知加轻量级锁，则轻量级锁会膨胀为重量级锁</p>\n<h3 id=\"公平锁，非公平锁\"><a href=\"#公平锁，非公平锁\" class=\"headerlink\" title=\"公平锁，非公平锁\"></a>公平锁，非公平锁</h3><p>代表是否按顺序获取锁</p>"},{"title":"集合","date":"2018-06-23T10:38:18.000Z","toc":true,"_content":"## 继承关系\n![继承关系](/images/常用集合.png)\n<!-- more -->\n\n## 重要方法\n### Arrays.sort()\n#### 优点\n1. 时间复杂度更低\n2. 稳定排序\n3. 针对于基本有序序列，时间复杂度接近O(n)\n4. 整合了归并排序（直接插入排序），双轴快排排序和TimSort\n\n#### 分析\n1. char和int排序，并且长度小于3200，会使用计数排序\n2. 剩下的所有类型，数组长度<286，使用快排，<47，使用插入排序，>=286且连续性比较好的话，使用快排，不然则使用双轴快排\n3. Comparable排序，使用TimSort（归并和插入排序的结合）\n4. 除非使用jvm参数指定，不会使用传统的归并排序（长度<7，使用插入排序)\n\n### Collections.sort()\n调用了`Arrays.sort()`实现其功能\n\n### Arrays.copyOf()\n1. 调用了System.arraycopy()来实现其方法\n2. 会返回一个全新的数组\n\n### System.arraycopy()\n1. native方法，性能较高\n2. 将元素从src的from地址复制到dst的to地址，复制n个，需要传入两个数组\n3. 这个方法在所有的不可变长的Queue，List都用到了","source":"_posts/集合.md","raw":"---\ntitle: 集合\ndate: 2018-06-23 18:38:18\ntags:\n- java\n- 集合\ncategories:\n- java\n- 集合\ntoc: true\n---\n## 继承关系\n![继承关系](/images/常用集合.png)\n<!-- more -->\n\n## 重要方法\n### Arrays.sort()\n#### 优点\n1. 时间复杂度更低\n2. 稳定排序\n3. 针对于基本有序序列，时间复杂度接近O(n)\n4. 整合了归并排序（直接插入排序），双轴快排排序和TimSort\n\n#### 分析\n1. char和int排序，并且长度小于3200，会使用计数排序\n2. 剩下的所有类型，数组长度<286，使用快排，<47，使用插入排序，>=286且连续性比较好的话，使用快排，不然则使用双轴快排\n3. Comparable排序，使用TimSort（归并和插入排序的结合）\n4. 除非使用jvm参数指定，不会使用传统的归并排序（长度<7，使用插入排序)\n\n### Collections.sort()\n调用了`Arrays.sort()`实现其功能\n\n### Arrays.copyOf()\n1. 调用了System.arraycopy()来实现其方法\n2. 会返回一个全新的数组\n\n### System.arraycopy()\n1. native方法，性能较高\n2. 将元素从src的from地址复制到dst的to地址，复制n个，需要传入两个数组\n3. 这个方法在所有的不可变长的Queue，List都用到了","slug":"集合","published":1,"updated":"2018-06-23T11:00:52.710Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5u1twy003r1av8wlzofjfa","content":"<h2 id=\"继承关系\"><a href=\"#继承关系\" class=\"headerlink\" title=\"继承关系\"></a>继承关系</h2><p><img src=\"/images/常用集合.png\" alt=\"继承关系\"><br><a id=\"more\"></a></p>\n<h2 id=\"重要方法\"><a href=\"#重要方法\" class=\"headerlink\" title=\"重要方法\"></a>重要方法</h2><h3 id=\"Arrays-sort\"><a href=\"#Arrays-sort\" class=\"headerlink\" title=\"Arrays.sort()\"></a>Arrays.sort()</h3><h4 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h4><ol>\n<li>时间复杂度更低</li>\n<li>稳定排序</li>\n<li>针对于基本有序序列，时间复杂度接近O(n)</li>\n<li>整合了归并排序（直接插入排序），双轴快排排序和TimSort</li>\n</ol>\n<h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><ol>\n<li>char和int排序，并且长度小于3200，会使用计数排序</li>\n<li>剩下的所有类型，数组长度&lt;286，使用快排，&lt;47，使用插入排序，&gt;=286且连续性比较好的话，使用快排，不然则使用双轴快排</li>\n<li>Comparable排序，使用TimSort（归并和插入排序的结合）</li>\n<li>除非使用jvm参数指定，不会使用传统的归并排序（长度&lt;7，使用插入排序)</li>\n</ol>\n<h3 id=\"Collections-sort\"><a href=\"#Collections-sort\" class=\"headerlink\" title=\"Collections.sort()\"></a>Collections.sort()</h3><p>调用了<code>Arrays.sort()</code>实现其功能</p>\n<h3 id=\"Arrays-copyOf\"><a href=\"#Arrays-copyOf\" class=\"headerlink\" title=\"Arrays.copyOf()\"></a>Arrays.copyOf()</h3><ol>\n<li>调用了System.arraycopy()来实现其方法</li>\n<li>会返回一个全新的数组</li>\n</ol>\n<h3 id=\"System-arraycopy\"><a href=\"#System-arraycopy\" class=\"headerlink\" title=\"System.arraycopy()\"></a>System.arraycopy()</h3><ol>\n<li>native方法，性能较高</li>\n<li>将元素从src的from地址复制到dst的to地址，复制n个，需要传入两个数组</li>\n<li>这个方法在所有的不可变长的Queue，List都用到了</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h2 id=\"继承关系\"><a href=\"#继承关系\" class=\"headerlink\" title=\"继承关系\"></a>继承关系</h2><p><img src=\"/images/常用集合.png\" alt=\"继承关系\"><br>","more":"</p>\n<h2 id=\"重要方法\"><a href=\"#重要方法\" class=\"headerlink\" title=\"重要方法\"></a>重要方法</h2><h3 id=\"Arrays-sort\"><a href=\"#Arrays-sort\" class=\"headerlink\" title=\"Arrays.sort()\"></a>Arrays.sort()</h3><h4 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h4><ol>\n<li>时间复杂度更低</li>\n<li>稳定排序</li>\n<li>针对于基本有序序列，时间复杂度接近O(n)</li>\n<li>整合了归并排序（直接插入排序），双轴快排排序和TimSort</li>\n</ol>\n<h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><ol>\n<li>char和int排序，并且长度小于3200，会使用计数排序</li>\n<li>剩下的所有类型，数组长度&lt;286，使用快排，&lt;47，使用插入排序，&gt;=286且连续性比较好的话，使用快排，不然则使用双轴快排</li>\n<li>Comparable排序，使用TimSort（归并和插入排序的结合）</li>\n<li>除非使用jvm参数指定，不会使用传统的归并排序（长度&lt;7，使用插入排序)</li>\n</ol>\n<h3 id=\"Collections-sort\"><a href=\"#Collections-sort\" class=\"headerlink\" title=\"Collections.sort()\"></a>Collections.sort()</h3><p>调用了<code>Arrays.sort()</code>实现其功能</p>\n<h3 id=\"Arrays-copyOf\"><a href=\"#Arrays-copyOf\" class=\"headerlink\" title=\"Arrays.copyOf()\"></a>Arrays.copyOf()</h3><ol>\n<li>调用了System.arraycopy()来实现其方法</li>\n<li>会返回一个全新的数组</li>\n</ol>\n<h3 id=\"System-arraycopy\"><a href=\"#System-arraycopy\" class=\"headerlink\" title=\"System.arraycopy()\"></a>System.arraycopy()</h3><ol>\n<li>native方法，性能较高</li>\n<li>将元素从src的from地址复制到dst的to地址，复制n个，需要传入两个数组</li>\n<li>这个方法在所有的不可变长的Queue，List都用到了</li>\n</ol>"},{"title":"语法糖","date":"2018-06-23T08:20:25.000Z","toc":true,"_content":"## 1. switch支持String\n通过String对象的hashCode以及equals来实现\n\n## 2. 泛型\n泛型的支持有两种方案`code specialization`和`code sharing`\nC++和C#是实现的第一种方式，编译出来的代码生成了很多的模板类\njava使用的是code sharing，编译器在编译的时候，执行了泛型擦除（type erasure)\n\n## 3. 自动装箱与拆箱\n自动装箱是插入`Integer.valueOf(123)`实现的\n自动拆箱是插入`new Integer(123).intValue()`实现的\n<!-- more -->\n## 4. 方法变长参数\n通过数组来实现的\n\n## 5. 枚举\nenum枚举通过继承Enum类来完成的\n\n## 6. 匿名内部类\n匿名内部类在编译之后是一个完全独立的类，例子BeanContext中的第一个内部类就是BeanContext$1.class\n\n## 7. 条件编译\n编译器优化，把那些100%不会执行的代码优化掉。\n```java\nint a = 0;\nif (a > 0) {\n} else if (a >= 0) {\n}\n```\n编译过后，代码块1不会被编译进去。\n\n## 8. 断言\n`assert a == b;`  \n被编译成下面类似代码段\n```\nif(!$assertionsDisabled && a != b) \n    throw new AssertionError(); \n```\n\n## 9. 数值字面量\n`100_000`编译后会成为`100000`\n\n## 10. for-each\n```java\nList<String> list = Arrays.asList(\"1\", \"2\", \"3\");\nfor (String str : list) {\n} \n```\n编译为\n```\nString str;\nfor (Iterator<String> ite = list.iterator(); ite.hasNext(); str = ite.next()) {\n\n}\n```\n11. try-with-resource\n```\ntry (InputStream inputStream = new FileInputStream(\"test.txt\")) {\n    // doSomething\n} catch (Exception e) {\n    // doSomething too\n} \n```\n编译后\n```\nThrowable t;\ntry {\n    InputStream inputStream = new FileInputStream(\"test.txt\");\n    try {\n        // doSomething\n    } catch (Throwable t1) {\n        t = t1;\n        throw t;\n    } finally {\n        if (inputStream != null) {\n            if (t != null) {\n                try {\n                    inputStream.close();\n                } catch (Throwable t2) {\n                    t1.addSuppressed(t2);\n                }\n            } else {\n                inputStream.close()\n            }\n        }\n    }\n} catch (IOException e1) {\n}\n```\n\n\n## 11. Lambda表达式\nlambda其实是个static方法\n`new Thread(() -> {})` \n编译后\n```java\nclass SomeClass {\n    void someFunc() {\n        new Thread(SomeClass::someFunction);\n    }\n\n    private static void someFunction() {\n        \n    }\n}\n```\n\n## 12. foreach循环\n目标类实现Iterable接口\n```java\nClass A implements Iterable<String>{}\n    void someFunc() {\n        for (String str : new A()) {\n        }\n    }\n```\n被编译为\n```java\nStringvar2;\nfor(Iteratorvar1=(new A()).iterator(); var1.hasNext(); var2=(String)var1.next()) {\n}\n```\n","source":"_posts/语法糖.md","raw":"---\ntitle: 语法糖\ndate: 2018-06-23 16:20:25\ntags:\n- java\n- 基础\ncategories:\n- java\n- 基础\ntoc: true\n---\n## 1. switch支持String\n通过String对象的hashCode以及equals来实现\n\n## 2. 泛型\n泛型的支持有两种方案`code specialization`和`code sharing`\nC++和C#是实现的第一种方式，编译出来的代码生成了很多的模板类\njava使用的是code sharing，编译器在编译的时候，执行了泛型擦除（type erasure)\n\n## 3. 自动装箱与拆箱\n自动装箱是插入`Integer.valueOf(123)`实现的\n自动拆箱是插入`new Integer(123).intValue()`实现的\n<!-- more -->\n## 4. 方法变长参数\n通过数组来实现的\n\n## 5. 枚举\nenum枚举通过继承Enum类来完成的\n\n## 6. 匿名内部类\n匿名内部类在编译之后是一个完全独立的类，例子BeanContext中的第一个内部类就是BeanContext$1.class\n\n## 7. 条件编译\n编译器优化，把那些100%不会执行的代码优化掉。\n```java\nint a = 0;\nif (a > 0) {\n} else if (a >= 0) {\n}\n```\n编译过后，代码块1不会被编译进去。\n\n## 8. 断言\n`assert a == b;`  \n被编译成下面类似代码段\n```\nif(!$assertionsDisabled && a != b) \n    throw new AssertionError(); \n```\n\n## 9. 数值字面量\n`100_000`编译后会成为`100000`\n\n## 10. for-each\n```java\nList<String> list = Arrays.asList(\"1\", \"2\", \"3\");\nfor (String str : list) {\n} \n```\n编译为\n```\nString str;\nfor (Iterator<String> ite = list.iterator(); ite.hasNext(); str = ite.next()) {\n\n}\n```\n11. try-with-resource\n```\ntry (InputStream inputStream = new FileInputStream(\"test.txt\")) {\n    // doSomething\n} catch (Exception e) {\n    // doSomething too\n} \n```\n编译后\n```\nThrowable t;\ntry {\n    InputStream inputStream = new FileInputStream(\"test.txt\");\n    try {\n        // doSomething\n    } catch (Throwable t1) {\n        t = t1;\n        throw t;\n    } finally {\n        if (inputStream != null) {\n            if (t != null) {\n                try {\n                    inputStream.close();\n                } catch (Throwable t2) {\n                    t1.addSuppressed(t2);\n                }\n            } else {\n                inputStream.close()\n            }\n        }\n    }\n} catch (IOException e1) {\n}\n```\n\n\n## 11. Lambda表达式\nlambda其实是个static方法\n`new Thread(() -> {})` \n编译后\n```java\nclass SomeClass {\n    void someFunc() {\n        new Thread(SomeClass::someFunction);\n    }\n\n    private static void someFunction() {\n        \n    }\n}\n```\n\n## 12. foreach循环\n目标类实现Iterable接口\n```java\nClass A implements Iterable<String>{}\n    void someFunc() {\n        for (String str : new A()) {\n        }\n    }\n```\n被编译为\n```java\nStringvar2;\nfor(Iteratorvar1=(new A()).iterator(); var1.hasNext(); var2=(String)var1.next()) {\n}\n```\n","slug":"语法糖","published":1,"updated":"2018-06-23T09:55:40.859Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj5u1tx0003w1av8zcn9jaf9","content":"<h2 id=\"1-switch支持String\"><a href=\"#1-switch支持String\" class=\"headerlink\" title=\"1. switch支持String\"></a>1. switch支持String</h2><p>通过String对象的hashCode以及equals来实现</p>\n<h2 id=\"2-泛型\"><a href=\"#2-泛型\" class=\"headerlink\" title=\"2. 泛型\"></a>2. 泛型</h2><p>泛型的支持有两种方案<code>code specialization</code>和<code>code sharing</code><br>C++和C#是实现的第一种方式，编译出来的代码生成了很多的模板类<br>java使用的是code sharing，编译器在编译的时候，执行了泛型擦除（type erasure)</p>\n<h2 id=\"3-自动装箱与拆箱\"><a href=\"#3-自动装箱与拆箱\" class=\"headerlink\" title=\"3. 自动装箱与拆箱\"></a>3. 自动装箱与拆箱</h2><p>自动装箱是插入<code>Integer.valueOf(123)</code>实现的<br>自动拆箱是插入<code>new Integer(123).intValue()</code>实现的<br><a id=\"more\"></a></p>\n<h2 id=\"4-方法变长参数\"><a href=\"#4-方法变长参数\" class=\"headerlink\" title=\"4. 方法变长参数\"></a>4. 方法变长参数</h2><p>通过数组来实现的</p>\n<h2 id=\"5-枚举\"><a href=\"#5-枚举\" class=\"headerlink\" title=\"5. 枚举\"></a>5. 枚举</h2><p>enum枚举通过继承Enum类来完成的</p>\n<h2 id=\"6-匿名内部类\"><a href=\"#6-匿名内部类\" class=\"headerlink\" title=\"6. 匿名内部类\"></a>6. 匿名内部类</h2><p>匿名内部类在编译之后是一个完全独立的类，例子BeanContext中的第一个内部类就是BeanContext$1.class</p>\n<h2 id=\"7-条件编译\"><a href=\"#7-条件编译\" class=\"headerlink\" title=\"7. 条件编译\"></a>7. 条件编译</h2><p>编译器优化，把那些100%不会执行的代码优化掉。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (a &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (a &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>编译过后，代码块1不会被编译进去。</p>\n<h2 id=\"8-断言\"><a href=\"#8-断言\" class=\"headerlink\" title=\"8. 断言\"></a>8. 断言</h2><p><code>assert a == b;</code><br>被编译成下面类似代码段<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(!$assertionsDisabled &amp;&amp; a != b) </span><br><span class=\"line\">    throw new AssertionError();</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"9-数值字面量\"><a href=\"#9-数值字面量\" class=\"headerlink\" title=\"9. 数值字面量\"></a>9. 数值字面量</h2><p><code>100_000</code>编译后会成为<code>100000</code></p>\n<h2 id=\"10-for-each\"><a href=\"#10-for-each\" class=\"headerlink\" title=\"10. for-each\"></a>10. for-each</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; list = Arrays.asList(<span class=\"string\">\"1\"</span>, <span class=\"string\">\"2\"</span>, <span class=\"string\">\"3\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (String str : list) &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>编译为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String str;</span><br><span class=\"line\">for (Iterator&lt;String&gt; ite = list.iterator(); ite.hasNext(); str = ite.next()) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ol start=\"11\">\n<li>try-with-resource<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">try (InputStream inputStream = new FileInputStream(&quot;test.txt&quot;)) &#123;</span><br><span class=\"line\">    // doSomething</span><br><span class=\"line\">&#125; catch (Exception e) &#123;</span><br><span class=\"line\">    // doSomething too</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>编译后<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Throwable t;</span><br><span class=\"line\">try &#123;</span><br><span class=\"line\">    InputStream inputStream = new FileInputStream(&quot;test.txt&quot;);</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        // doSomething</span><br><span class=\"line\">    &#125; catch (Throwable t1) &#123;</span><br><span class=\"line\">        t = t1;</span><br><span class=\"line\">        throw t;</span><br><span class=\"line\">    &#125; finally &#123;</span><br><span class=\"line\">        if (inputStream != null) &#123;</span><br><span class=\"line\">            if (t != null) &#123;</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    inputStream.close();</span><br><span class=\"line\">                &#125; catch (Throwable t2) &#123;</span><br><span class=\"line\">                    t1.addSuppressed(t2);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                inputStream.close()</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; catch (IOException e1) &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"11-Lambda表达式\"><a href=\"#11-Lambda表达式\" class=\"headerlink\" title=\"11. Lambda表达式\"></a>11. Lambda表达式</h2><p>lambda其实是个static方法<br><code>new Thread(() -&gt; {})</code><br>编译后<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomeClass</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">someFunc</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(SomeClass::someFunction);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">someFunction</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"12-foreach循环\"><a href=\"#12-foreach循环\" class=\"headerlink\" title=\"12. foreach循环\"></a>12. foreach循环</h2><p>目标类实现Iterable接口<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class A implements Iterable&lt;String&gt;&#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">someFunc</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String str : <span class=\"keyword\">new</span> A()) &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>被编译为<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stringvar2;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(Iteratorvar1=(<span class=\"keyword\">new</span> A()).iterator(); var1.hasNext(); var2=(String)var1.next()) &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"1-switch支持String\"><a href=\"#1-switch支持String\" class=\"headerlink\" title=\"1. switch支持String\"></a>1. switch支持String</h2><p>通过String对象的hashCode以及equals来实现</p>\n<h2 id=\"2-泛型\"><a href=\"#2-泛型\" class=\"headerlink\" title=\"2. 泛型\"></a>2. 泛型</h2><p>泛型的支持有两种方案<code>code specialization</code>和<code>code sharing</code><br>C++和C#是实现的第一种方式，编译出来的代码生成了很多的模板类<br>java使用的是code sharing，编译器在编译的时候，执行了泛型擦除（type erasure)</p>\n<h2 id=\"3-自动装箱与拆箱\"><a href=\"#3-自动装箱与拆箱\" class=\"headerlink\" title=\"3. 自动装箱与拆箱\"></a>3. 自动装箱与拆箱</h2><p>自动装箱是插入<code>Integer.valueOf(123)</code>实现的<br>自动拆箱是插入<code>new Integer(123).intValue()</code>实现的<br>","more":"</p>\n<h2 id=\"4-方法变长参数\"><a href=\"#4-方法变长参数\" class=\"headerlink\" title=\"4. 方法变长参数\"></a>4. 方法变长参数</h2><p>通过数组来实现的</p>\n<h2 id=\"5-枚举\"><a href=\"#5-枚举\" class=\"headerlink\" title=\"5. 枚举\"></a>5. 枚举</h2><p>enum枚举通过继承Enum类来完成的</p>\n<h2 id=\"6-匿名内部类\"><a href=\"#6-匿名内部类\" class=\"headerlink\" title=\"6. 匿名内部类\"></a>6. 匿名内部类</h2><p>匿名内部类在编译之后是一个完全独立的类，例子BeanContext中的第一个内部类就是BeanContext$1.class</p>\n<h2 id=\"7-条件编译\"><a href=\"#7-条件编译\" class=\"headerlink\" title=\"7. 条件编译\"></a>7. 条件编译</h2><p>编译器优化，把那些100%不会执行的代码优化掉。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (a &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (a &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>编译过后，代码块1不会被编译进去。</p>\n<h2 id=\"8-断言\"><a href=\"#8-断言\" class=\"headerlink\" title=\"8. 断言\"></a>8. 断言</h2><p><code>assert a == b;</code><br>被编译成下面类似代码段<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(!$assertionsDisabled &amp;&amp; a != b) </span><br><span class=\"line\">    throw new AssertionError();</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"9-数值字面量\"><a href=\"#9-数值字面量\" class=\"headerlink\" title=\"9. 数值字面量\"></a>9. 数值字面量</h2><p><code>100_000</code>编译后会成为<code>100000</code></p>\n<h2 id=\"10-for-each\"><a href=\"#10-for-each\" class=\"headerlink\" title=\"10. for-each\"></a>10. for-each</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; list = Arrays.asList(<span class=\"string\">\"1\"</span>, <span class=\"string\">\"2\"</span>, <span class=\"string\">\"3\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (String str : list) &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>编译为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String str;</span><br><span class=\"line\">for (Iterator&lt;String&gt; ite = list.iterator(); ite.hasNext(); str = ite.next()) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ol start=\"11\">\n<li>try-with-resource<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">try (InputStream inputStream = new FileInputStream(&quot;test.txt&quot;)) &#123;</span><br><span class=\"line\">    // doSomething</span><br><span class=\"line\">&#125; catch (Exception e) &#123;</span><br><span class=\"line\">    // doSomething too</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>编译后<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Throwable t;</span><br><span class=\"line\">try &#123;</span><br><span class=\"line\">    InputStream inputStream = new FileInputStream(&quot;test.txt&quot;);</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        // doSomething</span><br><span class=\"line\">    &#125; catch (Throwable t1) &#123;</span><br><span class=\"line\">        t = t1;</span><br><span class=\"line\">        throw t;</span><br><span class=\"line\">    &#125; finally &#123;</span><br><span class=\"line\">        if (inputStream != null) &#123;</span><br><span class=\"line\">            if (t != null) &#123;</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    inputStream.close();</span><br><span class=\"line\">                &#125; catch (Throwable t2) &#123;</span><br><span class=\"line\">                    t1.addSuppressed(t2);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                inputStream.close()</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; catch (IOException e1) &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"11-Lambda表达式\"><a href=\"#11-Lambda表达式\" class=\"headerlink\" title=\"11. Lambda表达式\"></a>11. Lambda表达式</h2><p>lambda其实是个static方法<br><code>new Thread(() -&gt; {})</code><br>编译后<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomeClass</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">someFunc</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(SomeClass::someFunction);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">someFunction</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"12-foreach循环\"><a href=\"#12-foreach循环\" class=\"headerlink\" title=\"12. foreach循环\"></a>12. foreach循环</h2><p>目标类实现Iterable接口<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class A implements Iterable&lt;String&gt;&#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">someFunc</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String str : <span class=\"keyword\">new</span> A()) &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>被编译为<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stringvar2;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(Iteratorvar1=(<span class=\"keyword\">new</span> A()).iterator(); var1.hasNext(); var2=(String)var1.next()) &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>"}],"PostAsset":[],"PostCategory":[{"post_id":"cjj5u1tun00041av8wg3mkdgx","category_id":"cjj5u1tuv000b1av8gnq4j3j7","_id":"cjj5u1tv3000k1av8jtljmjj6"},{"post_id":"cjj5u1tv0000h1av8dna6uff4","category_id":"cjj5u1tuv000b1av8gnq4j3j7","_id":"cjj5u1tv7000r1av8cg5vsmam"},{"post_id":"cjj5u1tup00051av8msiweghp","category_id":"cjj5u1tuz000f1av8o16h8vra","_id":"cjj5u1tv9000v1av849uye978"},{"post_id":"cjj5u1tud00001av8z7l81cof","category_id":"cjj5u1tul00021av8z20dc4b5","_id":"cjj5u1tvb000y1av8fgovljgn"},{"post_id":"cjj5u1tud00001av8z7l81cof","category_id":"cjj5u1tv3000m1av8wezuswre","_id":"cjj5u1tvc00121av8ty9vjctu"},{"post_id":"cjj5u1tv8000u1av8g1d75qm8","category_id":"cjj5u1tuv000b1av8gnq4j3j7","_id":"cjj5u1tve00151av8nmedrbh1"},{"post_id":"cjj5u1tv9000w1av89r2c4y3w","category_id":"cjj5u1tuv000b1av8gnq4j3j7","_id":"cjj5u1tvf001a1av8i2ofpzjy"},{"post_id":"cjj5u1tut00091av8bxi52m3g","category_id":"cjj5u1tul00021av8z20dc4b5","_id":"cjj5u1tvh001d1av8zcg8l3no"},{"post_id":"cjj5u1tut00091av8bxi52m3g","category_id":"cjj5u1tv8000t1av8hzpcp59g","_id":"cjj5u1tvj001i1av8kp13a53u"},{"post_id":"cjj5u1tui00011av8ntuhsfkz","category_id":"cjj5u1tul00021av8z20dc4b5","_id":"cjj5u1tvk001l1av8ptapdxbd"},{"post_id":"cjj5u1tui00011av8ntuhsfkz","category_id":"cjj5u1tv3000m1av8wezuswre","_id":"cjj5u1tvn001q1av8wpt1maxy"},{"post_id":"cjj5u1tve00171av88ehgb92z","category_id":"cjj5u1tul00021av8z20dc4b5","_id":"cjj5u1tvo001t1av8fg6rognq"},{"post_id":"cjj5u1tve00171av88ehgb92z","category_id":"cjj5u1tv3000m1av8wezuswre","_id":"cjj5u1tvs001x1av8gzjm86v1"},{"post_id":"cjj5u1tvf001b1av8ql775z3o","category_id":"cjj5u1tul00021av8z20dc4b5","_id":"cjj5u1tvu00201av8oi4l606j"},{"post_id":"cjj5u1tvf001b1av8ql775z3o","category_id":"cjj5u1tvf00181av8yqj0wlnm","_id":"cjj5u1tvy00251av8pkwssoih"},{"post_id":"cjj5u1tuu000a1av8r9preyjc","category_id":"cjj5u1tul00021av8z20dc4b5","_id":"cjj5u1tw000271av8hrak9knq"},{"post_id":"cjj5u1tuu000a1av8r9preyjc","category_id":"cjj5u1tvf00181av8yqj0wlnm","_id":"cjj5u1tw2002b1av8mwg9qsb5"},{"post_id":"cjj5u1tuw000d1av8do69ij6h","category_id":"cjj5u1tvi001g1av8jvxcu66s","_id":"cjj5u1tw4002e1av8v2hw3kmq"},{"post_id":"cjj5u1tux000e1av8z9d2s3j3","category_id":"cjj5u1tul00021av8z20dc4b5","_id":"cjj5u1tw7002j1av8gc0e5flm"},{"post_id":"cjj5u1tux000e1av8z9d2s3j3","category_id":"cjj5u1tv8000t1av8hzpcp59g","_id":"cjj5u1tw9002l1av8plgtfs02"},{"post_id":"cjj5u1tv2000j1av8a61xtctn","category_id":"cjj5u1tul00021av8z20dc4b5","_id":"cjj5u1twb002p1av8zask0td0"},{"post_id":"cjj5u1tv2000j1av8a61xtctn","category_id":"cjj5u1tv8000t1av8hzpcp59g","_id":"cjj5u1twd002s1av8cco1i2dk"},{"post_id":"cjj5u1tv4000o1av8fyy1qwzk","category_id":"cjj5u1tul00021av8z20dc4b5","_id":"cjj5u1twf002x1av8tpmeijuc"},{"post_id":"cjj5u1tv4000o1av8fyy1qwzk","category_id":"cjj5u1tvf00181av8yqj0wlnm","_id":"cjj5u1twh00301av8r68wsnp7"},{"post_id":"cjj5u1tv6000q1av8tl4swwjm","category_id":"cjj5u1tul00021av8z20dc4b5","_id":"cjj5u1twk00341av8rd7ik57z"},{"post_id":"cjj5u1tv6000q1av8tl4swwjm","category_id":"cjj5u1tv8000t1av8hzpcp59g","_id":"cjj5u1twn00371av80ayfai0y"},{"post_id":"cjj5u1tvb000z1av82xzgf7qp","category_id":"cjj5u1tul00021av8z20dc4b5","_id":"cjj5u1twq003b1av88l93sjh7"},{"post_id":"cjj5u1tvb000z1av82xzgf7qp","category_id":"cjj5u1tvf00181av8yqj0wlnm","_id":"cjj5u1tws003f1av8kf208la1"},{"post_id":"cjj5u1tvc00131av8ot72cpf4","category_id":"cjj5u1tul00021av8z20dc4b5","_id":"cjj5u1twt003j1av8h2zwwush"},{"post_id":"cjj5u1tvc00131av8ot72cpf4","category_id":"cjj5u1tvf00181av8yqj0wlnm","_id":"cjj5u1twv003n1av826t44y5u"},{"post_id":"cjj5u1tvh001e1av88o3v6fb6","category_id":"cjj5u1tul00021av8z20dc4b5","_id":"cjj5u1twy003q1av8jealmo6g"},{"post_id":"cjj5u1tvh001e1av88o3v6fb6","category_id":"cjj5u1twe002v1av8ksgzk38n","_id":"cjj5u1tx0003v1av8ce90u1av"},{"post_id":"cjj5u1twi00311av83ji17c86","category_id":"cjj5u1tul00021av8z20dc4b5","_id":"cjj5u1tx1003y1av844mbupll"},{"post_id":"cjj5u1twi00311av83ji17c86","category_id":"cjj5u1tv3000m1av8wezuswre","_id":"cjj5u1tx200421av892xacshe"},{"post_id":"cjj5u1tvj001j1av8trgj8igr","category_id":"cjj5u1tul00021av8z20dc4b5","_id":"cjj5u1tx300441av8iy78oits"},{"post_id":"cjj5u1tvj001j1av8trgj8igr","category_id":"cjj5u1twe002v1av8ksgzk38n","_id":"cjj5u1tx400481av8b186jusm"},{"post_id":"cjj5u1twn00381av871642n7p","category_id":"cjj5u1tuv000b1av8gnq4j3j7","_id":"cjj5u1tx4004a1av8i6euvhlk"},{"post_id":"cjj5u1twq003d1av8ce8i0lv0","category_id":"cjj5u1tul00021av8z20dc4b5","_id":"cjj5u1tx5004e1av8rfvsw9hr"},{"post_id":"cjj5u1twq003d1av8ce8i0lv0","category_id":"cjj5u1twe002v1av8ksgzk38n","_id":"cjj5u1tx6004g1av80hjpu8kw"},{"post_id":"cjj5u1tvl001m1av8u7znswe5","category_id":"cjj5u1tul00021av8z20dc4b5","_id":"cjj5u1tx7004k1av8ovqwj5u2"},{"post_id":"cjj5u1tvl001m1av8u7znswe5","category_id":"cjj5u1twe002v1av8ksgzk38n","_id":"cjj5u1tx7004m1av8t02b1br0"},{"post_id":"cjj5u1tws003g1av8byy9kz6u","category_id":"cjj5u1tul00021av8z20dc4b5","_id":"cjj5u1tx8004q1av85nsadevv"},{"post_id":"cjj5u1tws003g1av8byy9kz6u","category_id":"cjj5u1twe002v1av8ksgzk38n","_id":"cjj5u1tx9004s1av89d9mac0h"},{"post_id":"cjj5u1tvn001r1av82eq9lzq8","category_id":"cjj5u1twt003i1av8u7wedllg","_id":"cjj5u1txa004w1av8i6xs5wov"},{"post_id":"cjj5u1tww003o1av800ukry70","category_id":"cjj5u1tul00021av8z20dc4b5","_id":"cjj5u1txa004y1av89hsz16vq"},{"post_id":"cjj5u1tww003o1av800ukry70","category_id":"cjj5u1tv3000m1av8wezuswre","_id":"cjj5u1txb00521av8aek4oscu"},{"post_id":"cjj5u1twy003r1av8wlzofjfa","category_id":"cjj5u1tul00021av8z20dc4b5","_id":"cjj5u1txb00541av8eqo1xbiy"},{"post_id":"cjj5u1twy003r1av8wlzofjfa","category_id":"cjj5u1tv8000t1av8hzpcp59g","_id":"cjj5u1txc00581av8243mxoib"},{"post_id":"cjj5u1tvp001u1av8tlgocts3","category_id":"cjj5u1tul00021av8z20dc4b5","_id":"cjj5u1txc005a1av8sr3uq3lk"},{"post_id":"cjj5u1tvp001u1av8tlgocts3","category_id":"cjj5u1twe002v1av8ksgzk38n","_id":"cjj5u1txd005d1av8d44m3gou"},{"post_id":"cjj5u1tvt001z1av8it10kkqv","category_id":"cjj5u1tul00021av8z20dc4b5","_id":"cjj5u1txe005g1av8xiptlm70"},{"post_id":"cjj5u1tvt001z1av8it10kkqv","category_id":"cjj5u1tx2003z1av8h1k98g1d","_id":"cjj5u1txe005j1av88ad78kd6"},{"post_id":"cjj5u1tvv00221av8rllf1ygn","category_id":"cjj5u1tul00021av8z20dc4b5","_id":"cjj5u1txf005m1av8iwh9tk9u"},{"post_id":"cjj5u1tvv00221av8rllf1ygn","category_id":"cjj5u1tx2003z1av8h1k98g1d","_id":"cjj5u1txg005p1av86gp2c665"},{"post_id":"cjj5u1tvy00261av8bjq3tin6","category_id":"cjj5u1tul00021av8z20dc4b5","_id":"cjj5u1txi005s1av8hqq1hg7o"},{"post_id":"cjj5u1tvy00261av8bjq3tin6","category_id":"cjj5u1tx2003z1av8h1k98g1d","_id":"cjj5u1txj005v1av8nzjr5cns"},{"post_id":"cjj5u1tw000281av88w7v0oba","category_id":"cjj5u1tul00021av8z20dc4b5","_id":"cjj5u1txl005y1av8dov98e8q"},{"post_id":"cjj5u1tw000281av88w7v0oba","category_id":"cjj5u1twe002v1av8ksgzk38n","_id":"cjj5u1txm00611av8d2hs0azz"},{"post_id":"cjj5u1tw2002d1av8v0xccdy7","category_id":"cjj5u1tul00021av8z20dc4b5","_id":"cjj5u1txn00641av8vfjmzj4k"},{"post_id":"cjj5u1tw2002d1av8v0xccdy7","category_id":"cjj5u1twe002v1av8ksgzk38n","_id":"cjj5u1txn00671av8795462oe"},{"post_id":"cjj5u1tw7002k1av8iqu3uc0z","category_id":"cjj5u1tul00021av8z20dc4b5","_id":"cjj5u1txo006a1av8otwiqsgs"},{"post_id":"cjj5u1tw7002k1av8iqu3uc0z","category_id":"cjj5u1twe002v1av8ksgzk38n","_id":"cjj5u1txo006c1av8vvsz4hex"},{"post_id":"cjj5u1tw9002m1av8l3w2cd9n","category_id":"cjj5u1txa004z1av8j1fu2cet","_id":"cjj5u1txo006f1av8tldmodpv"},{"post_id":"cjj5u1twd002t1av8w4wzdf56","category_id":"cjj5u1tul00021av8z20dc4b5","_id":"cjj5u1txp006g1av8q3va5fek"},{"post_id":"cjj5u1twd002t1av8w4wzdf56","category_id":"cjj5u1tx2003z1av8h1k98g1d","_id":"cjj5u1txp006h1av8a7qei5z0"},{"post_id":"cjj5u1twf002y1av83m52y3ue","category_id":"cjj5u1tul00021av8z20dc4b5","_id":"cjj5u1txq006k1av86p3513et"},{"post_id":"cjj5u1twf002y1av83m52y3ue","category_id":"cjj5u1tx2003z1av8h1k98g1d","_id":"cjj5u1txq006m1av84aik7itg"},{"post_id":"cjj5u1twl00351av8cjjzdt33","category_id":"cjj5u1tul00021av8z20dc4b5","_id":"cjj5u1txq006p1av83emgv2iw"},{"post_id":"cjj5u1twl00351av8cjjzdt33","category_id":"cjj5u1tx2003z1av8h1k98g1d","_id":"cjj5u1txq006r1av8yfz2y386"},{"post_id":"cjj5u1twu003k1av8dhz3wwgh","category_id":"cjj5u1tul00021av8z20dc4b5","_id":"cjj5u1txr006t1av8cizzfkzc"},{"post_id":"cjj5u1twu003k1av8dhz3wwgh","category_id":"cjj5u1tx2003z1av8h1k98g1d","_id":"cjj5u1txr006u1av8vm56gebw"},{"post_id":"cjj5u1tx0003w1av8zcn9jaf9","category_id":"cjj5u1tul00021av8z20dc4b5","_id":"cjj5u1txs006w1av8m46ej3k5"},{"post_id":"cjj5u1tx0003w1av8zcn9jaf9","category_id":"cjj5u1tx2003z1av8h1k98g1d","_id":"cjj5u1txs006x1av8gcthnle9"},{"post_id":"cjj5u1twb002q1av8xww3f68i","category_id":"cjj5u1txa004z1av8j1fu2cet","_id":"cjj5u1txt00701av81ve1k5ov"},{"post_id":"cjj5u1twb002q1av8xww3f68i","category_id":"cjj5u1txn00661av8ptyprwo2","_id":"cjj5u1txt00721av8p16whss2"}],"PostTag":[{"post_id":"cjj5u1tud00001av8z7l81cof","tag_id":"cjj5u1tum00031av8plpe12yy","_id":"cjj5u1tv1000i1av85f11vdj5"},{"post_id":"cjj5u1tud00001av8z7l81cof","tag_id":"cjj5u1tur00081av852okvumz","_id":"cjj5u1tv3000l1av8nchartz7"},{"post_id":"cjj5u1tud00001av8z7l81cof","tag_id":"cjj5u1tuw000c1av835qpn1u7","_id":"cjj5u1tv5000p1av8hyqxn7ts"},{"post_id":"cjj5u1tui00011av8ntuhsfkz","tag_id":"cjj5u1tum00031av8plpe12yy","_id":"cjj5u1tvc00111av8r2l7e6n2"},{"post_id":"cjj5u1tui00011av8ntuhsfkz","tag_id":"cjj5u1tur00081av852okvumz","_id":"cjj5u1tvd00141av82qkscly2"},{"post_id":"cjj5u1tui00011av8ntuhsfkz","tag_id":"cjj5u1tuw000c1av835qpn1u7","_id":"cjj5u1tvf00191av84kukh60c"},{"post_id":"cjj5u1tve00171av88ehgb92z","tag_id":"cjj5u1tum00031av8plpe12yy","_id":"cjj5u1tvh001c1av84h4pny7d"},{"post_id":"cjj5u1tve00171av88ehgb92z","tag_id":"cjj5u1tur00081av852okvumz","_id":"cjj5u1tvj001h1av8jn6oukgf"},{"post_id":"cjj5u1tve00171av88ehgb92z","tag_id":"cjj5u1tuw000c1av835qpn1u7","_id":"cjj5u1tvk001k1av8v55xby99"},{"post_id":"cjj5u1tun00041av8wg3mkdgx","tag_id":"cjj5u1tva000x1av8e4d3f2wu","_id":"cjj5u1tvm001p1av8kwpcqnve"},{"post_id":"cjj5u1tun00041av8wg3mkdgx","tag_id":"cjj5u1tve00161av8mm42b7iu","_id":"cjj5u1tvo001s1av8xg0qufwt"},{"post_id":"cjj5u1tup00051av8msiweghp","tag_id":"cjj5u1tva000x1av8e4d3f2wu","_id":"cjj5u1tvt001y1av8ffswxg6x"},{"post_id":"cjj5u1tup00051av8msiweghp","tag_id":"cjj5u1tve00161av8mm42b7iu","_id":"cjj5u1tvu00211av8grc6axcs"},{"post_id":"cjj5u1tuq00061av8ag56afj9","tag_id":"cjj5u1tva000x1av8e4d3f2wu","_id":"cjj5u1tw2002c1av8q3qvvgui"},{"post_id":"cjj5u1tuq00061av8ag56afj9","tag_id":"cjj5u1tve00161av8mm42b7iu","_id":"cjj5u1tw4002f1av83e1ho0kt"},{"post_id":"cjj5u1tut00091av8bxi52m3g","tag_id":"cjj5u1tum00031av8plpe12yy","_id":"cjj5u1twc002r1av8jsyrisol"},{"post_id":"cjj5u1tut00091av8bxi52m3g","tag_id":"cjj5u1tw100291av83jem3l8t","_id":"cjj5u1twe002u1av8sdgo94e9"},{"post_id":"cjj5u1tut00091av8bxi52m3g","tag_id":"cjj5u1tuw000c1av835qpn1u7","_id":"cjj5u1twh002z1av8p7h7ce5t"},{"post_id":"cjj5u1tuu000a1av8r9preyjc","tag_id":"cjj5u1tum00031av8plpe12yy","_id":"cjj5u1twn00361av8kkxa82kb"},{"post_id":"cjj5u1tuu000a1av8r9preyjc","tag_id":"cjj5u1twa002n1av80sacuahj","_id":"cjj5u1twp00391av8iiikatrm"},{"post_id":"cjj5u1tuu000a1av8r9preyjc","tag_id":"cjj5u1tuw000c1av835qpn1u7","_id":"cjj5u1tws003e1av8m4aqamhr"},{"post_id":"cjj5u1twi00311av83ji17c86","tag_id":"cjj5u1tum00031av8plpe12yy","_id":"cjj5u1twt003h1av8h4qxmk4b"},{"post_id":"cjj5u1twi00311av83ji17c86","tag_id":"cjj5u1tur00081av852okvumz","_id":"cjj5u1twv003m1av8e8vr01bc"},{"post_id":"cjj5u1tuw000d1av8do69ij6h","tag_id":"cjj5u1twj00321av8g9ekeeaq","_id":"cjj5u1twx003p1av89na7x9i1"},{"post_id":"cjj5u1tuw000d1av8do69ij6h","tag_id":"cjj5u1twq003c1av8nsn407k1","_id":"cjj5u1tx0003u1av89tfe2u50"},{"post_id":"cjj5u1tww003o1av800ukry70","tag_id":"cjj5u1tum00031av8plpe12yy","_id":"cjj5u1tx1003x1av844zkd4dt"},{"post_id":"cjj5u1tww003o1av800ukry70","tag_id":"cjj5u1tur00081av852okvumz","_id":"cjj5u1tx200411av8dpc3omi4"},{"post_id":"cjj5u1tux000e1av8z9d2s3j3","tag_id":"cjj5u1tum00031av8plpe12yy","_id":"cjj5u1tx200431av80w7wuiyg"},{"post_id":"cjj5u1tux000e1av8z9d2s3j3","tag_id":"cjj5u1tw100291av83jem3l8t","_id":"cjj5u1tx300471av88b8rjda4"},{"post_id":"cjj5u1tux000e1av8z9d2s3j3","tag_id":"cjj5u1tuw000c1av835qpn1u7","_id":"cjj5u1tx400491av8z2257cxp"},{"post_id":"cjj5u1twy003r1av8wlzofjfa","tag_id":"cjj5u1tum00031av8plpe12yy","_id":"cjj5u1tx5004d1av8kj4sudcw"},{"post_id":"cjj5u1twy003r1av8wlzofjfa","tag_id":"cjj5u1tw100291av83jem3l8t","_id":"cjj5u1tx6004f1av8cosows6m"},{"post_id":"cjj5u1tv0000h1av8dna6uff4","tag_id":"cjj5u1tva000x1av8e4d3f2wu","_id":"cjj5u1tx6004j1av8yspvhdut"},{"post_id":"cjj5u1tv0000h1av8dna6uff4","tag_id":"cjj5u1tx200401av8jgcu5nwq","_id":"cjj5u1tx7004l1av8w99b8xh6"},{"post_id":"cjj5u1tv2000j1av8a61xtctn","tag_id":"cjj5u1tum00031av8plpe12yy","_id":"cjj5u1tx8004p1av8incbov0t"},{"post_id":"cjj5u1tv2000j1av8a61xtctn","tag_id":"cjj5u1tw100291av83jem3l8t","_id":"cjj5u1tx8004r1av84mqlrojx"},{"post_id":"cjj5u1tv2000j1av8a61xtctn","tag_id":"cjj5u1tuw000c1av835qpn1u7","_id":"cjj5u1tx9004v1av8wtggmh1p"},{"post_id":"cjj5u1tv4000o1av8fyy1qwzk","tag_id":"cjj5u1tum00031av8plpe12yy","_id":"cjj5u1txa004x1av8h28vc740"},{"post_id":"cjj5u1tv4000o1av8fyy1qwzk","tag_id":"cjj5u1twa002n1av80sacuahj","_id":"cjj5u1txa00501av85krc6hs6"},{"post_id":"cjj5u1tv4000o1av8fyy1qwzk","tag_id":"cjj5u1tuw000c1av835qpn1u7","_id":"cjj5u1txb00531av8hwgpwk5n"},{"post_id":"cjj5u1tv6000q1av8tl4swwjm","tag_id":"cjj5u1tum00031av8plpe12yy","_id":"cjj5u1txb00551av85dfvuixw"},{"post_id":"cjj5u1tv6000q1av8tl4swwjm","tag_id":"cjj5u1tw100291av83jem3l8t","_id":"cjj5u1txc00591av83uhaiued"},{"post_id":"cjj5u1tv6000q1av8tl4swwjm","tag_id":"cjj5u1tuw000c1av835qpn1u7","_id":"cjj5u1txc005b1av89ftsulcm"},{"post_id":"cjj5u1tv8000u1av8g1d75qm8","tag_id":"cjj5u1tva000x1av8e4d3f2wu","_id":"cjj5u1txe005f1av8c7p5u8yk"},{"post_id":"cjj5u1tv8000u1av8g1d75qm8","tag_id":"cjj5u1tx9004u1av84h375ana","_id":"cjj5u1txe005h1av8wv8bwwx9"},{"post_id":"cjj5u1tv9000w1av89r2c4y3w","tag_id":"cjj5u1tva000x1av8e4d3f2wu","_id":"cjj5u1txf005l1av8aexso7xh"},{"post_id":"cjj5u1tv9000w1av89r2c4y3w","tag_id":"cjj5u1txc00571av816oyf6e7","_id":"cjj5u1txg005n1av8fc8ixyzj"},{"post_id":"cjj5u1tvb000z1av82xzgf7qp","tag_id":"cjj5u1tum00031av8plpe12yy","_id":"cjj5u1txi005r1av8curoef9u"},{"post_id":"cjj5u1tvb000z1av82xzgf7qp","tag_id":"cjj5u1twa002n1av80sacuahj","_id":"cjj5u1txj005t1av8y4mfpqsa"},{"post_id":"cjj5u1tvb000z1av82xzgf7qp","tag_id":"cjj5u1tuw000c1av835qpn1u7","_id":"cjj5u1txl005x1av82atmvoww"},{"post_id":"cjj5u1tvc00131av8ot72cpf4","tag_id":"cjj5u1tum00031av8plpe12yy","_id":"cjj5u1txl005z1av8395ad50l"},{"post_id":"cjj5u1tvc00131av8ot72cpf4","tag_id":"cjj5u1twa002n1av80sacuahj","_id":"cjj5u1txm00631av8q9vgzza8"},{"post_id":"cjj5u1tvc00131av8ot72cpf4","tag_id":"cjj5u1tuw000c1av835qpn1u7","_id":"cjj5u1txn00651av8rm2agt3j"},{"post_id":"cjj5u1tvf001b1av8ql775z3o","tag_id":"cjj5u1tum00031av8plpe12yy","_id":"cjj5u1txn00691av87z4wcgau"},{"post_id":"cjj5u1tvf001b1av8ql775z3o","tag_id":"cjj5u1twa002n1av80sacuahj","_id":"cjj5u1txo006b1av8gwsy1rbt"},{"post_id":"cjj5u1tvf001b1av8ql775z3o","tag_id":"cjj5u1tuw000c1av835qpn1u7","_id":"cjj5u1txo006d1av8sp8r4e6r"},{"post_id":"cjj5u1tvh001e1av88o3v6fb6","tag_id":"cjj5u1txj005w1av8no87cudo","_id":"cjj5u1txp006j1av835y4mbr0"},{"post_id":"cjj5u1tvh001e1av88o3v6fb6","tag_id":"cjj5u1txm00621av8fnwg9wqn","_id":"cjj5u1txq006l1av8ajad9wu6"},{"post_id":"cjj5u1tvh001e1av88o3v6fb6","tag_id":"cjj5u1txn00681av8quz6ikek","_id":"cjj5u1txq006o1av87nsgatwa"},{"post_id":"cjj5u1tvh001e1av88o3v6fb6","tag_id":"cjj5u1txo006e1av8pmiu0e7l","_id":"cjj5u1txq006q1av8zo52ptvg"},{"post_id":"cjj5u1tvj001j1av8trgj8igr","tag_id":"cjj5u1txj005w1av8no87cudo","_id":"cjj5u1txt006z1av8ni4we19i"},{"post_id":"cjj5u1tvj001j1av8trgj8igr","tag_id":"cjj5u1txm00621av8fnwg9wqn","_id":"cjj5u1txt00711av89cvjrt7s"},{"post_id":"cjj5u1tvj001j1av8trgj8igr","tag_id":"cjj5u1txo006e1av8pmiu0e7l","_id":"cjj5u1txt00741av8qt138mrk"},{"post_id":"cjj5u1tvj001j1av8trgj8igr","tag_id":"cjj5u1txn00681av8quz6ikek","_id":"cjj5u1txt00751av8yqeer9om"},{"post_id":"cjj5u1tvl001m1av8u7znswe5","tag_id":"cjj5u1txj005w1av8no87cudo","_id":"cjj5u1txu00771av8kx5cthqv"},{"post_id":"cjj5u1tvl001m1av8u7znswe5","tag_id":"cjj5u1txt00731av8npjuf7fo","_id":"cjj5u1txu00781av8f54w01cq"},{"post_id":"cjj5u1tvn001r1av82eq9lzq8","tag_id":"cjj5u1txt00761av89eutbedt","_id":"cjj5u1txu007a1av8k7osqhx1"},{"post_id":"cjj5u1tvp001u1av8tlgocts3","tag_id":"cjj5u1tum00031av8plpe12yy","_id":"cjj5u1txv007c1av80u2fix36"},{"post_id":"cjj5u1tvp001u1av8tlgocts3","tag_id":"cjj5u1txj005w1av8no87cudo","_id":"cjj5u1txv007d1av87520k04j"},{"post_id":"cjj5u1tvt001z1av8it10kkqv","tag_id":"cjj5u1tum00031av8plpe12yy","_id":"cjj5u1txw007g1av891l0igs4"},{"post_id":"cjj5u1tvt001z1av8it10kkqv","tag_id":"cjj5u1txv007b1av8hbnzpi0d","_id":"cjj5u1txw007h1av8dpgxvlvy"},{"post_id":"cjj5u1tvt001z1av8it10kkqv","tag_id":"cjj5u1txv007e1av8r7yw3d0m","_id":"cjj5u1txw007j1av8ssxgv8s8"},{"post_id":"cjj5u1tvv00221av8rllf1ygn","tag_id":"cjj5u1tum00031av8plpe12yy","_id":"cjj5u1txx007l1av8zxjm9juz"},{"post_id":"cjj5u1tvv00221av8rllf1ygn","tag_id":"cjj5u1txv007b1av8hbnzpi0d","_id":"cjj5u1txx007m1av8x8240h6g"},{"post_id":"cjj5u1tvv00221av8rllf1ygn","tag_id":"cjj5u1txw007i1av8i0buzciz","_id":"cjj5u1txx007o1av8xf5rhp1y"},{"post_id":"cjj5u1tvy00261av8bjq3tin6","tag_id":"cjj5u1tum00031av8plpe12yy","_id":"cjj5u1txz007r1av8ahqu5l7x"},{"post_id":"cjj5u1tvy00261av8bjq3tin6","tag_id":"cjj5u1txv007b1av8hbnzpi0d","_id":"cjj5u1txz007s1av82t3fe69x"},{"post_id":"cjj5u1tvy00261av8bjq3tin6","tag_id":"cjj5u1txx007n1av8yx2iia5p","_id":"cjj5u1txz007u1av8blkgbz9c"},{"post_id":"cjj5u1tvy00261av8bjq3tin6","tag_id":"cjj5u1txy007p1av80pkl036g","_id":"cjj5u1txz007v1av8ktmepzs0"},{"post_id":"cjj5u1tw000281av88w7v0oba","tag_id":"cjj5u1tum00031av8plpe12yy","_id":"cjj5u1ty1007x1av8in2k4xho"},{"post_id":"cjj5u1tw000281av88w7v0oba","tag_id":"cjj5u1txj005w1av8no87cudo","_id":"cjj5u1ty2007y1av85ythe4xy"},{"post_id":"cjj5u1tw000281av88w7v0oba","tag_id":"cjj5u1txt00731av8npjuf7fo","_id":"cjj5u1ty200801av8otvf0b74"},{"post_id":"cjj5u1tw2002d1av8v0xccdy7","tag_id":"cjj5u1tum00031av8plpe12yy","_id":"cjj5u1ty300821av8zzkb8pjc"},{"post_id":"cjj5u1tw2002d1av8v0xccdy7","tag_id":"cjj5u1txj005w1av8no87cudo","_id":"cjj5u1ty300831av8bauad8ej"},{"post_id":"cjj5u1tw2002d1av8v0xccdy7","tag_id":"cjj5u1txv007e1av8r7yw3d0m","_id":"cjj5u1ty300851av8usvvds8o"},{"post_id":"cjj5u1tw5002g1av8dqtmm0hf","tag_id":"cjj5u1ty200811av8bbifkinl","_id":"cjj5u1ty400861av8e204a440"},{"post_id":"cjj5u1tw7002k1av8iqu3uc0z","tag_id":"cjj5u1tum00031av8plpe12yy","_id":"cjj5u1ty500891av82pzckqtz"},{"post_id":"cjj5u1tw7002k1av8iqu3uc0z","tag_id":"cjj5u1txj005w1av8no87cudo","_id":"cjj5u1ty5008a1av8puysi9v8"},{"post_id":"cjj5u1tw7002k1av8iqu3uc0z","tag_id":"cjj5u1ty400871av8mtygm8bu","_id":"cjj5u1ty5008c1av8fcjjpyvx"},{"post_id":"cjj5u1tw9002m1av8l3w2cd9n","tag_id":"cjj5u1ty200811av8bbifkinl","_id":"cjj5u1ty6008e1av8m8mvom0q"},{"post_id":"cjj5u1tw9002m1av8l3w2cd9n","tag_id":"cjj5u1ty5008b1av8vho4lfmp","_id":"cjj5u1ty6008f1av8ia5umygd"},{"post_id":"cjj5u1twb002q1av8xww3f68i","tag_id":"cjj5u1ty200811av8bbifkinl","_id":"cjj5u1ty7008i1av8lr5vkrbv"},{"post_id":"cjj5u1twb002q1av8xww3f68i","tag_id":"cjj5u1ty6008g1av89qhh796b","_id":"cjj5u1ty7008j1av8brkkz6xa"},{"post_id":"cjj5u1twd002t1av8w4wzdf56","tag_id":"cjj5u1tum00031av8plpe12yy","_id":"cjj5u1ty8008l1av8cfnvpm9e"},{"post_id":"cjj5u1twd002t1av8w4wzdf56","tag_id":"cjj5u1txv007b1av8hbnzpi0d","_id":"cjj5u1ty8008m1av87h54e83v"},{"post_id":"cjj5u1twf002y1av83m52y3ue","tag_id":"cjj5u1tum00031av8plpe12yy","_id":"cjj5u1ty9008p1av8j3qs8b0o"},{"post_id":"cjj5u1twf002y1av83m52y3ue","tag_id":"cjj5u1txv007b1av8hbnzpi0d","_id":"cjj5u1ty9008q1av8kuc4efmm"},{"post_id":"cjj5u1twf002y1av83m52y3ue","tag_id":"cjj5u1ty8008n1av8aqz4fp0d","_id":"cjj5u1tya008s1av8bxfznwf7"},{"post_id":"cjj5u1twl00351av8cjjzdt33","tag_id":"cjj5u1tum00031av8plpe12yy","_id":"cjj5u1tya008t1av8e237x497"},{"post_id":"cjj5u1twl00351av8cjjzdt33","tag_id":"cjj5u1txv007b1av8hbnzpi0d","_id":"cjj5u1tya008v1av8ihuu9my7"},{"post_id":"cjj5u1twn00381av871642n7p","tag_id":"cjj5u1tva000x1av8e4d3f2wu","_id":"cjj5u1tya008w1av8kgvnv0cm"},{"post_id":"cjj5u1twn00381av871642n7p","tag_id":"cjj5u1txc00571av816oyf6e7","_id":"cjj5u1tyb008y1av8yqchlaom"},{"post_id":"cjj5u1twq003d1av8ce8i0lv0","tag_id":"cjj5u1tum00031av8plpe12yy","_id":"cjj5u1tyb008z1av8fpnwr2ff"},{"post_id":"cjj5u1twq003d1av8ce8i0lv0","tag_id":"cjj5u1txj005w1av8no87cudo","_id":"cjj5u1tyc00911av84wuavg1f"},{"post_id":"cjj5u1tws003g1av8byy9kz6u","tag_id":"cjj5u1tum00031av8plpe12yy","_id":"cjj5u1tyc00921av8ova9kp1k"},{"post_id":"cjj5u1tws003g1av8byy9kz6u","tag_id":"cjj5u1txj005w1av8no87cudo","_id":"cjj5u1tyc00941av8kzlvvib5"},{"post_id":"cjj5u1twu003k1av8dhz3wwgh","tag_id":"cjj5u1tum00031av8plpe12yy","_id":"cjj5u1tyd00961av8x0v90qvc"},{"post_id":"cjj5u1twu003k1av8dhz3wwgh","tag_id":"cjj5u1txv007b1av8hbnzpi0d","_id":"cjj5u1tyd00971av83s5sk659"},{"post_id":"cjj5u1twu003k1av8dhz3wwgh","tag_id":"cjj5u1tyc00931av89xo4bhgx","_id":"cjj5u1tyd00981av8taa0kfxr"},{"post_id":"cjj5u1tx0003w1av8zcn9jaf9","tag_id":"cjj5u1tum00031av8plpe12yy","_id":"cjj5u1tye00991av80hdhjo4r"},{"post_id":"cjj5u1tx0003w1av8zcn9jaf9","tag_id":"cjj5u1txv007b1av8hbnzpi0d","_id":"cjj5u1tye009a1av8w5ngq1ps"}],"Tag":[{"name":"java","_id":"cjj5u1tum00031av8plpe12yy"},{"name":"并发","_id":"cjj5u1tur00081av852okvumz"},{"name":"源码","_id":"cjj5u1tuw000c1av835qpn1u7"},{"name":"中间件","_id":"cjj5u1tva000x1av8e4d3f2wu"},{"name":"开源","_id":"cjj5u1tve00161av8mm42b7iu"},{"name":"集合","_id":"cjj5u1tw100291av83jem3l8t"},{"name":"多线程","_id":"cjj5u1twa002n1av80sacuahj"},{"name":"框架","_id":"cjj5u1twj00321av8g9ekeeaq"},{"name":"sharding-jdbc","_id":"cjj5u1twq003c1av8nsn407k1"},{"name":"mysql","_id":"cjj5u1tx200401av8jgcu5nwq"},{"name":"rocketmq","_id":"cjj5u1tx9004u1av84h375ana"},{"name":"redis","_id":"cjj5u1txc00571av816oyf6e7"},{"name":"jvm","_id":"cjj5u1txj005w1av8no87cudo"},{"name":"gc","_id":"cjj5u1txm00621av8fnwg9wqn"},{"name":"cms","_id":"cjj5u1txn00681av8quz6ikek"},{"name":"g1","_id":"cjj5u1txo006e1av8pmiu0e7l"},{"name":"jmm","_id":"cjj5u1txt00731av8npjuf7fo"},{"name":"随笔","_id":"cjj5u1txt00761av89eutbedt"},{"name":"基础","_id":"cjj5u1txv007b1av8hbnzpi0d"},{"name":"关键字","_id":"cjj5u1txv007e1av8r7yw3d0m"},{"name":"io","_id":"cjj5u1txw007i1av8i0buzciz"},{"name":"tcp","_id":"cjj5u1txx007n1av8yx2iia5p"},{"name":"网络","_id":"cjj5u1txy007p1av80pkl036g"},{"name":"分布式","_id":"cjj5u1ty200811av8bbifkinl"},{"name":"jit","_id":"cjj5u1ty400871av8mtygm8bu"},{"name":"锁","_id":"cjj5u1ty5008b1av8vho4lfmp"},{"name":"微服务","_id":"cjj5u1ty6008g1av89qhh796b"},{"name":"攻击","_id":"cjj5u1ty8008n1av8aqz4fp0d"},{"name":"设计模式","_id":"cjj5u1tyc00931av89xo4bhgx"}]}}